# 认知负荷是关键

> [原文](https://zakirullin.md/cognitive)

## 介绍

现在有很多流行语和最佳实践，但让我们关注一些更基本的东西。重要的是，开发人员在阅读代码时会感到多少困惑。

混乱会耗费时间和金钱。混乱是由高**认知负荷**引起的。这不是一些花哨的抽象概念，而是**人类的基本约束**。

因为我们花在阅读和理解代码上的时间远远多于写代码的时间，所以我们应该不断地问自己是否在代码中嵌入了过多的认知负荷。

![Cognitive Load](/images/cognitiveloadv5.png)

## 认知负荷

> 认知负荷是指开发人员为完成一项任务需要思考的程度。

阅读代码时，您会将变量值、控制流逻辑和调用序列等内容放入脑海中。一般人的工作记忆中可以容纳大约[四个这样的块](https://github.com/zakirullin/cognitive-load/issues/16)。一旦认知负荷达到这个阈值，理解事物就会变得更加困难。

*比方说，我们被要求对一个完全陌生的项目进行一些修正。我们被告知，一位非常聪明的开发人员为该项目做出了贡献。他使用了很多很酷的架构、花哨的库和时髦的技术。换句话说，***作者为我们创造了很高的认知负荷。***

我们应尽可能减少项目中的认知负荷。

## 认知负荷的类型

**内在** - 由任务的内在难度造成。它无法降低，是软件开发的核心。

**外来** - 信息呈现方式造成的。由与任务无直接关系的因素造成，如聪明的作者的怪癖。可以大大减少。我们将重点讨论这类认知负荷。

![Intrinsic vs Extraneous](/images/smartauthorv13.png)

让我们直接跳到无关认知负荷的具体实例。

---

我们将认知负荷水平称为如下：

🧠：新鲜工作记忆，零认知负荷

🧠++：我们工作记忆中的两个事实，认知负荷增加

🤯：工作记忆溢出，超过 4 个事实

> 我们的大脑要复杂得多且未经探索，但我们可以采用这个简单化的模型。

## 复杂条件句

```go
if val > someConstant // 🧠+
    && (condition2 || condition3) // 🧠+++, prev cond should be true, one of c2 or c3 has be true
    && (condition4 && !condition5) { // 🤯, we are messed up by this point
    ...
}
```

引入具有有意义名称的中间变量：

```go
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5 
// 🧠, we don't need to remember the conditions, there are descriptive variables
if isValid && isAllowed && isSecure {
    ...
}
```

## 嵌套 if

```go
if isValid { // 🧠+, okay nested code applies to valid input only
    if isSecure { // 🧠++, we do stuff for valid and secure input only
        stuff // 🧠+++
    }
} 
```

与早期回报进行比较：

```go
if !isValid
    return
 
if !isSecure
    return

// 🧠, we don't really care about earlier returns, if we are here then all good

stuff // 🧠+
```

我们可以只专注于快乐的道路，从而将我们的工作记忆从各种先决条件中解放出来。

## 继承噩梦

我们被要求为我们的管理员用户更改一些内容：🧠

`AdminController 扩展了 UserController 扩展了 GuestController 扩展了 BaseController`

- 部分功能在 `BaseController` 中，让我们看一下：`🧠+` 
- 在 `GuestController` 中引入了基本角色机制：`🧠++` 
- 在 `UserController` 中进行了部分更改：`🧠+++ ` 
- 终于到了，`AdminController`，让我们编写代码吧！ `🧠++++`
- 等等，有一个扩展了“AdminController”的“SuperuserController”。通过修改“AdminController”，我们可以破坏继承类中的内容，所以让我们首先深入了解“SuperuserController”：“🤯”

优先选择组合而不是继承。

## 太多的小方法、类或模块

> 方法、类和模块在这种情况下是可以互换的

诸如“方法应该少于 15 行代码”或“类应该很小”之类的咒语被证明是有些错误的。

**深层模块** - 界面简单，功能复杂

**浅层模块** - 界面相对于它提供的小功能来说相对复杂

![Deep module](/images/deepmodulev5.png)

过多的浅层模块会使项目难以理解。 **我们不仅要牢记每个模块的职责，还要牢记它们所有的交互**。要理解浅层模块的用途，我们首先需要查看所有相关模块的功能。 `🤯`

> 信息隐藏至关重要，我们不会在浅层模块中隐藏太多复杂性。

我有两个喜欢的项目，它们都有 5K 行代码。第一个有 80 个浅层类，而第二个只有 7 个深层类。我已经一年半没有维护任何这些项目了。

回来后，我意识到在第一个项目中理清这 80 个类之间的所有交互是极其困难的。在开始编码之前，我必须重建大量的认知负荷。另一方面，我能够很快掌握第二个项目，因为它只有几个深层类和一个简单的接口。

>最好的组件是那些提供强大功能但界面简单的组件。
>--**约翰·K·奥斯特豪特**

UNIX I/O 的接口非常简单。它只有五个基本调用：

```python
open(path, flags, permissions)
read(fd, buffer, count)
write(fd, buffer, count)
lseek(fd, offset, referencePosition)
close(fd)
```

该接口的现代实现有**数十万行代码**。许多复杂性隐藏在幕后。然而，由于其简单的界面，它很容易使用。

> 这个深层模块示例取自 John K. Ousterhout 所著的[《软件设计哲学》](https://web.stanford.edu/~ouster/cgi-bin/book.php)一书。本书不仅涵盖了软件开发中复杂性的本质，而且还对Parnas颇具影响力的论文[On the Criteria To Be Use in Decomusing Systems into Modules](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf)。两者都是必备读物。其他相关阅读：[可能是时候停止推荐干净代码了](https://qntm.org/clean)、[被认为有害的小函数](https://copyconstruct.medium.com/small-functions-considered-harmful -91035d316c29)。

附：如果你认为我们支持臃肿的上帝对象和太多的责任，那你就错了。

## 浅层模块和 SRP

很多时候，我们最终会创建大量浅层模块，遵循一些模糊的“一个模块应该负责一个且只负责一个事物”的原则。这模糊的一件事是什么？实例化一个对象是一回事，对吧？所以 `MetricsProviderFactoryFactory` 似乎就很好。这些类的名称和接口往往比它们的整个实现更费脑力，那是一种什么样的抽象？出了点问题。

> 在如此浅层的组件之间跳转也很费脑力，[线性思维](https://blog.separateconcerns.com/2023-09-11-linear-code.html)对我们人类来说更自然。

我们对系统进行更改以满足我们的用户和利益相关者的需求。我们对他们负责。

> 一个模块应该对一个且仅对一个用户或利益相关者负责。

这就是单一责任原则的全部内容。简单来说，如果我们在一个地方引入了一个bug，然后两个不同的业务人员来抱怨，我们就违反了原则。它与我们在模块中所做的事情的数量无关。    

但即使是现在，这种解释也弊大于利。这条规则可以以多种不同的方式来理解，就像有多少个人一样。更好的方法是看看这一切会产生多少认知负荷。记住一个模块的变化可能会在不同的业务流中引发一系列反应，这对心理上的要求很高。就是这样。

## 太多浅层微服务

这种浅深模块原则与规模无关，我们可以将其应用到微服务架构中。太多的浅层微服务不会有任何好处——行业正在走向某种程度的“宏观服务”，即不那么浅层（=深层）的服务。最糟糕和最难修复的现象之一是所谓的分布式整体，这通常是这种过于细粒度的浅层分离的结果。

我曾经咨询过一家初创公司，该公司的 5 名开发人员团队引入了 17 个(!)微服务。它们比原计划晚了 10 个月，而且距离公开发布还差得很远。每一个新需求都会导致 4 个以上微服务的变化。集成空间的诊断难度急剧上升。上市时间和认知负荷都高得令人无法接受。 `🤯`

这是处理新系统不确定性的正确方法吗？一开始就很难得出正确的逻辑界限。关键是在负责任地等待的时间内尽可能晚地做出决定，因为那时你拥有最多的信息来做出决定。通过预先引入网络层，我们的设计决策很难从一开始就恢复。该团队唯一的理由是：“FAANG 公司证明了微服务架构是有效的”。 *你好，你不能再做大梦了。*

[Tanenbaum-Torvalds 辩论](https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate) 认为 Linux 的整体设计是有缺陷且过时的，应该使用微内核架构来代替。事实上，“从理论和美学”的角度来看，微内核设计似乎更优越。从实际情况来看，三十年过去了，基于微内核的 GNU Hurd 仍在开发中，而整体 Linux 已经无处不在。此页面由 Linux 提供支持，您的智能茶壶由 Linux 提供支持。通过单片Linux。

具有真正隔离模块的精心设计的整体通常比一堆微服务灵活得多。它还需要更少的认知努力来维持。只有当单独部署的需求变得至关重要时（例如扩展开发团队），您才应该考虑在模块和未来的微服务之间添加网络层。

## 功能丰富的语言

当我们喜爱的语言发布新功能时，我们会感到兴奋。我们花一些时间学习这些功能，并在此基础上编写代码。

如果有很多功能，我们可能要花半小时来处理几行代码，以使用这样或那样的功能。这有点浪费时间。但更糟糕的是，当你稍后再回来时，你将不得不重新经历那个思考过程！ 

你不仅要理解这个复杂的程序，还要理解为什么程序员决定用这种方法来解决现有功能中的问题。🤯

发表这些言论的不是别人，正是罗伯-派克。

> 通过限制选择数量来减少认知负荷。

只要语言特征是相互正交的，就没有问题。

  一位拥有20年C++经验的工程师的想法️⭐️:

> 前几天，我在看我的 RSS 阅读器时发现，我的 "C++"标签下有三百多篇未读文章。从去年夏天到现在，我一篇关于 C++ 语言的文章都没读过，感觉好极了！
>
> 我使用 C++ 已经有 20 年了，这几乎是我人生的三分之二的时间。我的大部分经验都在于处理语言中最黑暗的角落（例如各种未定义的行为）。这不是一个可重复使用的体验，现在把它全部扔掉有点令人毛骨悚然。
>
> 比如，你能想象 || 符号在 requires ((! P<T> || ! Q<T>) 和 requires (! (P<T> || Q<T>)) 中的含义不同吗？）前者是约束析取，后者是古老的逻辑 OR 运算符，它们的行为是不同的。
>
> 你不能为简单的类型分配空间，而无需额外的努力就可以在其中 memcpy 一组字节 - 这不会启动对象的生命周期。 C++20之前就是这种情况。它在 C++20 中得到了修复，但该语言的认知负荷只是增加了。
>
> 尽管事情已经解决，但认知负荷却在不断增加。我应该知道修复了什么，什么时候修复的，修复前是什么样子。毕竟我是专业人士。当然，C++ 擅长遗留问题支持，这也意味着你将面对遗留问题。例如，上个月我的一位同事向我询问 C++03 中的一些行为。
>
> 有 20 种初始化方式。现在增加了统一初始化语法。现在我们有 21 种初始化方式。顺便问一句，还有人记得从初始化列表中选择构造函数的规则吗？关于隐式转换，信息损失最小，但如果值是静态已知的，那么......
>
> 这种认知负荷的增加并不是由手头的业务任务造成的。它不是领域的内在复杂性。它只是由于历史原因而存在（外在认知负荷）。
>
> 我不得不想出一些规则。比如，如果那行代码不那么明显，而我又必须记住标准，那我最好不要那样写。顺便说一句，该标准长达 1500 页。
>
> 我绝不是在指责 C++。我热爱这门语言。只是我现在累了

## 业务逻辑和 HTTP 状态代码



未完待续~~~