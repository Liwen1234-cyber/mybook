# 二叉树

## 基础知识

### 二叉树的种类

在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树

#### 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

这棵二叉树为满二叉树，也可以说深度为k，有$2^{k-1}$个节点的二叉树。

#### 完全二叉树

完全二叉树的定义：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 $1-2^{(h-1)}$ 个节点。

![img](/images/20200920221638903.png)

**优先级队列其实是一个堆**，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

#### 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

下面这两棵树都是搜索树:

![img](/images/20200806190304693.png)

#### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如图：

![img](/images/20200806190511967.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是$logn$，而unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

###  二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。

链式存储如图：

![img](/images/2020092019554618.png)

顺序存储（用数组来存储二叉树）的方式如图：

![img](/images/20200920200429452.png)

用数组来存储二叉树如何遍历的呢？

如果父节点的数组下标是 i，那么它的左孩子就是 $i * 2 + 1$，右孩子就是 $i * 2 + 2$。

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

**所以大家要了解，用数组依然可以表示二叉树。**

### 二叉树的遍历方式

主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

这两种遍历是**图论**中最基本的两种遍历方式。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是**中间节点的遍历顺序**。

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

![img](、images/20200806191109896.png)

深度优先和广度优先的遍历方式：

- 二叉树相关题目中，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。**之前说过栈其实就是递归的一种实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。
- 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

### 二叉树的定义

链式存储的二叉树节点的定义方式。

C++代码如下：

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

java 代码：

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

二叉树的定义和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。

## 二叉树的递归遍历

[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

给你二叉树的根节点 `root` ，返回它节点值的 **前序、中序和后序** 遍历。

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */


//前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        preorder(root, res);
        return res;
    }
    public void preorder(TreeNode root, List<Integer> result) {
        if(root == null) return;
        result.add(root.val);
        preorder(root.left, result);
        preorder(root.right, result);
    }
}

//中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }
    public void inorder(TreeNode root, List<Integer> result){
        if(root == null) return;
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}

//后序遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }
    public void postorder(TreeNode root, List<Integer> result){
        if(root == null) return;
        postorder(root.left, result);
        postorder(root.right, result);
        result.add(root.val);
    }
}
```



## 二叉树的迭代遍历

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//迭代前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.addFirst(root);
        while(!deque.isEmpty()){
            TreeNode temp = deque.poll();
            if(temp.right != null) deque.addFirst(temp.right);
            if(temp.left != null) deque.addFirst(temp.left);
            res.add(temp.val);
        }
        return res;
    }
}

//迭代后序循环遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.addFirst(root);
        while(!deque.isEmpty()){
            TreeNode temp = deque.poll();
            if(temp.left != null) deque.addFirst(temp.left);
            if(temp.right != null) deque.addFirst(temp.right);
            res.add(temp.val);
        }
        Collections.reverse(res);//翻转
        return res;
    }
}

//迭代中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.addFirst(root);

        while(!deque.isEmpty()){
            TreeNode temp = deque.peek();
            while(temp.left != null){
                deque.addFirst(temp.left);
                temp = temp.left;
            }
            while(deque.peek().right == null){
                res.add(deque.poll().val);
                if(deque.peek() == null) return res;
            }
            
            res.add(deque.peek().val);
            deque.addFirst(deque.poll().right);
        }
        return res;
    }
}


```



## 统一迭代法

将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.addFirst(root);

        while(!deque.isEmpty()){
            TreeNode node = deque.peek();
            res.add(deque.poll().val);
            if(node.right != null){
                deque.addFirst(node.right);
            }
            if(node.left != null){
                deque.addFirst(node.left);
            }
        }
        return res;
    }
}

//中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.addFirst(root);

        while(!deque.isEmpty()){
            TreeNode node = deque.peek();
            if(node != null){
                deque.poll();
                if(node.right != null){
                    deque.addFirst(node.right);
                }
                deque.addFirst(node);
                deque.addFirst(null);
                if(node.left != null){
                    deque.addFirst(node.left);
                }
            } else{
                deque.poll();
                if(deque.peek() != null) res.add(deque.poll().val);
            }
        }
        return res;
    }
}

//后序遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.addFirst(root);

        while(!deque.isEmpty()){
            TreeNode node = deque.peek();
            if(node != null){
                deque.addFirst(null);
                if(node.right != null){
                    deque.addFirst(node.right);
                }
                if(node.left != null){
                    deque.addFirst(node.left);
                }                

            } else{
                deque.poll();
                if(deque.peek() != null) res.add(deque.poll().val);
            }
        }
        return res;
    }
}
```



## 二叉树层序遍历

### 102.二叉树的层序遍历

[力扣题目链接(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checknode(root, 0);
        // checknode1(root);
        return resList;
    }
    //BFS 递归
    private void checknode(TreeNode node, int deep){
        if(node == null) return;
        deep++;
        if(resList.size() < deep){
            List<Integer> temp = new ArrayList<>();
            resList.add(temp);
        }
        resList.get(deep-1).add(node.val);
        checknode(node.left, deep);
        checknode(node.right, deep);
    }

    //BFS 迭代
    private void checknode1(TreeNode node){
        if(node == null) return;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(node);

        while(!deque.isEmpty()){
            int len = deque.size();
            List<Integer> temp = new ArrayList<>();
            while(len > 0){
                if(deque.peek().left != null) deque.offer(deque.peek().left);
                if(deque.peek().right != null) deque.offer(deque.peek().right);
                len--;
                temp.add(deque.poll().val);
            }
            resList.add(temp);
        }
        
    }
}
```



### 107.二叉树的层次遍历 II

[力扣题目链接(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> resList = new ArrayList<>();
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        // checknode(root, 0);
        // List<List<Integer>> res = new ArrayList<>();
        // for(int i = resList.size()-1; i >= 0; i--){
        //     res.add(resList.get(i));
        // }
        checknode1(root);
        return resList;
    }
    //递归
    private void checknode(TreeNode node, int deep){
        if(node == null) return;
        deep++;
        if(resList.size() < deep){
            List<Integer> temp = new ArrayList<>();
            resList.add(temp);
        }
        resList.get(deep-1).add(node.val);
        checknode(node.left, deep);
        checknode(node.right, deep);
    }
    //迭代
    private void checknode1(TreeNode node){
        if(node == null) return;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(node);

        while(!deque.isEmpty()){
            int len = deque.size();
            List<Integer> temp = new ArrayList<>();
            while(len > 0){
                if(deque.peek().left != null) deque.offer(deque.peek().left);
                if(deque.peek().right != null) deque.offer(deque.peek().right);
                len--;
                temp.add(deque.poll().val);
            }
            resList.addFirst(temp);//新遍历到的层插到头部, 这样就满足按照层次反序的要求
        }
        
    }
}

```



199.二叉树的右视图

[力扣题目链接(opens new window)](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.offer(root);
        int deep = 0;
        while(!deque.isEmpty()){
            int len = deque.size();
            res.add(deque.peekLast().val);
            while(len > 0){
                len--;
                if(deque.peek().left != null) deque.offer(deque.peek().left);
                if(deque.peek().right != null) deque.offer(deque.peek().right); 
                deque.poll();               
            }
        }
        return res;
    }
}
```



### 637.二叉树的层平均值

[力扣题目链接(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.offer(root);
        int deep = 0;
        double sum = (double)root.val;
        while(!deque.isEmpty()){
            int len = deque.size();
            res.add(sum/len);
            sum = 0;
            while(len > 0){
                len--;
                if(deque.peek().left != null){
                    deque.offer(deque.peek().left);
                    sum += deque.peek().left.val;
                } 
                if(deque.peek().right != null){
                    deque.offer(deque.peek().right); 
                    sum += deque.peek().right.val;
                } 
                deque.poll();
            }
        }
        return res;
    }
}
```



### 429.N叉树的层序遍历

[力扣题目链接(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

解答：

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();
    public List<List<Integer>> levelOrder(Node root) {
        checknode(root, 0);
        // checknode1(root);//迭代的写法类似
        return resList;
    }
    //BFS 递归
    private void checknode(Node node, int deep){
        if(node == null) return;
        deep++;
        if(resList.size() < deep){
            List<Integer> temp = new ArrayList<>();
            resList.add(temp);
        }
        resList.get(deep-1).add(node.val);
        for(Node a : node.children){
            checknode(a, deep);
        }
    }
}
```



### 515.在每个树行中找最大值

[力扣题目链接(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

您需要在二叉树的每一行中找到最大的值。

解答：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> deque = new LinkedList<>();
        if(root == null) return res;
        deque.offer(root);
        int max_num = root.val;
        while(!deque.isEmpty()){
            int len = deque.size();
            res.add(max_num);
            max_num = Integer.MIN_VALUE;
            while(len > 0){
                len--;
                if(deque.peek().left != null){
                    deque.offer(deque.peek().left);
                    max_num = max_num > deque.peek().left.val ? max_num : deque.peek().left.val;
                } 
                if(deque.peek().right != null){
                    deque.offer(deque.peek().right); 
                    max_num = max_num > deque.peek().right.val ? max_num : deque.peek().right.val;
                } 
                deque.poll();
            }
        }
        return res;
    }
}
```



###  116.填充每个节点的下一个右侧节点指针

[力扣题目链接(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

解答：

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        Deque<Node> deque = new LinkedList<>();
        if(root == null) return root;
        deque.offer(root);
        while(!deque.isEmpty()){
            int len = deque.size();
            Node cur = deque.poll();
            if(cur.left != null) deque.offer(cur.left);
            if(cur.right != null) deque.offer(cur.right);
            len--;
            while(len > 0){
                len--;
                Node next = deque.poll();
                if(next.left != null) deque.offer(next.left);
                if(next.right != null) deque.offer(next.right);
                
                cur.next = next;
                cur = next;
            }
            cur.next = null;
        }
        return root;
    }
}
```



### 117.填充每个节点的下一个右侧节点指针II

[力扣题目链接(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

解答和上一题一样



### 104.二叉树的最大深度

[力扣题目链接(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```java
/**
 * Definition for a binary tree TreeNode.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        int res = 0;
        if(root == null) return res;
        deque.offer(root);
        while(!deque.isEmpty()){
            int len = deque.size();

            while(len > 0){
                len--;
                TreeNode temp = deque.poll();
                if(temp.left != null) deque.offer(temp.left);
                if(temp.right != null) deque.offer(temp.right);
            }
            res++;
        }
        return res;
    }
}
```



### 111.二叉树的最小深度

[力扣题目链接(opens new window)](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        int res = 0;
        if(root == null) return res;
        deque.offer(root);
        res++;
        while(!deque.isEmpty()){
            int len = deque.size();
            while(len > 0){
                len--;
                TreeNode temp = deque.poll();
                if(temp.left != null) deque.offer(temp.left);
                if(temp.right != null) deque.offer(temp.right);
                if(temp.left != null || temp.right != null){}
                else return res;
            }
            res++;
        }
        return res;
    }
}
```



## 226.翻转二叉树

[力扣题目链接(opens new window)](https://leetcode.cn/problems/invert-binary-tree/)

翻转一棵二叉树。

解答：

```java
```



未完待续~~~