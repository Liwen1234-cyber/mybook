# 动态规划

## 基础知识

题目分类：

```mermaid
graph LR
    A[动态规划] --> B((基础题目))
    A --> C((背包问题))
    A --> D((打家劫舍))
    A --> E((股票问题))
    A --> F((子序列问题))

    B --> B1[509.斐波那契数]
    B --> B2[70.爬楼梯]
    B --> B3[746.使用最小花费爬楼梯]
    B --> B4[62.不同路径]
    B --> B5[63.不同路径II]
    B --> B6[343.整数拆分]
    B --> B7[96.不同的二叉搜索树]

    C --> C1[01背包]
    C --> C2[完全背包]
    C --> C3[多重背包]
    C --> C4[背包问题大总结]

    C1 --> C1A[01背包理论基础]
    C1 --> C1B[01背包理论基础-滚动数组]
    C1 --> C1C[0416.分割等和子集]
    C1 --> C1D[1049.最后一块石头的重量II]
    C1 --> C1E[0494.目标和]
    C1 --> C1F[0474.一和零]

    C2 --> C2A[完全背包理论基础]
    C2 --> C2B[0518.零钱兑换II]
    C2 --> C2C[0377.组合总和IV]
    C2 --> C2D[0070.爬楼梯-完全背包解法]
    C2 --> C2E[0322.零钱兑换]
    C2 --> C2F[0279.完全平方数]
    C2 --> C2G[0139.单词拆分]

    D --> D1[198.打家劫舍]
    D --> D2[213.打家劫舍II]
    D --> D3[337.打家劫舍III]

    E --> E1[121.买卖股票的最佳时机I]
    E --> E2[122.买卖股票的最佳时机II]
    E --> E3[123.买卖股票的最佳时机III]
    E --> E4[188.买卖股票的最佳时机IV]
    E --> E5[309.最佳买卖股票时机含冷冻期]
    E --> E6[714.买卖股票的最佳时机含手续费]

    F --> F1[子序列-不连续]
    F --> F2[子序列-连续]
    F --> F3[编辑距离]
    F --> F4[回文]

    F1 --> F1A[300.最长上升子序列]
    F1 --> F1B[1143.最长公共子序列]
    F1 --> F1C[1035.不相交的线]
    F1 --> F1D[674.最长连续递增序列]

    F2 --> F2A[718.最长重复子数组]
    F2 --> F2B[53.最大子序和]

    F3 --> F3A[392.判断子序列]
    F3 --> F3B[115.不同的子序列]
    F3 --> F3C[583.两个字符串的删除操作]
    F3 --> F3D[72.编辑距离]

    F4 --> F4A[647.回文子串]
    F4 --> F4B[516.最长回文子序列]
```

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，

动态规划的三要素:

1. 最优子结构
2. 状态转移方程((包含最优子结构))
3. 边界

##  509. 斐波那契数

[力扣题目链接(opens new window)](https://leetcode.cn/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

解答：

```java
class Solution {
    public int fib(int n) {
        if(n == 0) return 0;
        if(n <= 2) return 1;
        int[] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            int temp = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = temp;
        }
        return dp[1];
    }
}
```

## 70. 爬楼梯

[力扣题目链接(opens new window)](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

解答：

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2; i < n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
}
```

## 746. 使用最小花费爬楼梯

[力扣题目链接(opens new window)](https://leetcode.cn/problems/min-cost-climbing-stairs/)

**旧题目描述**：

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

解答：

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length+1];
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2; i < dp.length; i++){
            dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);
        }
        return dp[dp.length-1];
    }
}
```

## 62.不同路径

[力扣题目链接(opens new window)](https://leetcode.cn/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

解答：

<!-- tabs:start -->

#### **数理方法**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        long res = 1;
        for(int a = n, b = 1; b < m; a++,b++){
            res = res*a/b;
        } 
        return (int)res;
    }
}
```
#### **dp**

```java

class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
}
```

#### **dp压缩**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 在二维dp数组中，当前值的计算只依赖正上方和正左方，因此可以压缩成一维数组。
        int[] dp = new int[n];
        // 初始化，第一行只能从正左方跳过来，所以只有一条路径。
        Arrays.fill(dp, 1);
        for (int i = 1; i < m; i ++) {
            // 第一列也只有一条路，不用迭代，所以从第二列开始
            for (int j = 1; j < n; j ++) {
                dp[j] += dp[j - 1]; // dp[j] = dp[j] (正上方)+ dp[j - 1] (正左方)
            }
        }
        return dp[n - 1];
    }
}
```

<!-- tabs:end -->

## 63. 不同路径 II

[力扣题目链接(opens new window)](https://leetcode.cn/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

解答：

<!-- tabs:start -->

#### **dp**

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0] == 1) return 0;
        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];
        for(int i = 0; i < dp.length; i++){
            if(obstacleGrid[i][0] == 1) break;
            dp[i][0] = 1;

        }

        for(int j = 1; j < dp[0].length; j++){
            if(obstacleGrid[0][j] == 1) break;
            dp[0][j] = 1;
        }
        for(int i = 1; i < dp.length; i++){
            for(int j = 1; j < dp[0].length; j++){
                dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1];

            }
        }

        return dp[dp.length-1][dp[0].length-1];
    }
}
```

**dp压缩**

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.length;
        int n =obstacleGrid[0].length;

        int[] dp = new int[n];
        for(int i = 0; i < n && obstacleGrid[0][i] != 1; i++){
            dp[i] = 1;

        } 

        for(int i = 1; i < m; i++){
            for(int j = 0; j < n; j++){
                if(obstacleGrid[i][j] == 1) dp[j] = 0;
                else if(j > 0) dp[j] += dp[j-1];
            }
        }

        return dp[n-1];
    }
}
```

<!-- tabs:end -->



未完待续~~~