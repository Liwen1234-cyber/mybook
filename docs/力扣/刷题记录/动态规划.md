# 动态规划

## 基础知识

题目分类：

```mermaid
graph LR
    A[动态规划] --> B((基础题目))
    A --> C((背包问题))
    A --> D((打家劫舍))
    A --> E((股票问题))
    A --> F((子序列问题))

    B --> B1[509.斐波那契数]
    B --> B2[70.爬楼梯]
    B --> B3[746.使用最小花费爬楼梯]
    B --> B4[62.不同路径]
    B --> B5[63.不同路径II]
    B --> B6[343.整数拆分]
    B --> B7[96.不同的二叉搜索树]

    C --> C1[01背包]
    C --> C2[完全背包]
    C --> C3[多重背包]
    C --> C4[背包问题大总结]

    C1 --> C1A[01背包理论基础]
    C1 --> C1B[01背包理论基础-滚动数组]
    C1 --> C1C[0416.分割等和子集]
    C1 --> C1D[1049.最后一块石头的重量II]
    C1 --> C1E[0494.目标和]
    C1 --> C1F[0474.一和零]

    C2 --> C2A[完全背包理论基础]
    C2 --> C2B[0518.零钱兑换II]
    C2 --> C2C[0377.组合总和IV]
    C2 --> C2D[0070.爬楼梯-完全背包解法]
    C2 --> C2E[0322.零钱兑换]
    C2 --> C2F[0279.完全平方数]
    C2 --> C2G[0139.单词拆分]

    D --> D1[198.打家劫舍]
    D --> D2[213.打家劫舍II]
    D --> D3[337.打家劫舍III]

    E --> E1[121.买卖股票的最佳时机I]
    E --> E2[122.买卖股票的最佳时机II]
    E --> E3[123.买卖股票的最佳时机III]
    E --> E4[188.买卖股票的最佳时机IV]
    E --> E5[309.最佳买卖股票时机含冷冻期]
    E --> E6[714.买卖股票的最佳时机含手续费]

    F --> F1[子序列-不连续]
    F --> F2[子序列-连续]
    F --> F3[编辑距离]
    F --> F4[回文]

    F1 --> F1A[300.最长上升子序列]
    F1 --> F1B[1143.最长公共子序列]
    F1 --> F1C[1035.不相交的线]
    F1 --> F1D[674.最长连续递增序列]

    F2 --> F2A[718.最长重复子数组]
    F2 --> F2B[53.最大子序和]

    F3 --> F3A[392.判断子序列]
    F3 --> F3B[115.不同的子序列]
    F3 --> F3C[583.两个字符串的删除操作]
    F3 --> F3D[72.编辑距离]

    F4 --> F4A[647.回文子串]
    F4 --> F4B[516.最长回文子序列]
```

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，

动态规划的三要素:

1. 最优子结构
2. 状态转移方程((包含最优子结构))
3. 边界

##  509. 斐波那契数

[力扣题目链接(opens new window)](https://leetcode.cn/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

解答：

```java
class Solution {
    public int fib(int n) {
        if(n == 0) return 0;
        if(n <= 2) return 1;
        int[] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            int temp = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = temp;
        }
        return dp[1];
    }
}
```

## 70. 爬楼梯

[力扣题目链接(opens new window)](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

解答：

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 2;
        for(int i = 2; i < n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
}
```

## 746. 使用最小花费爬楼梯

[力扣题目链接(opens new window)](https://leetcode.cn/problems/min-cost-climbing-stairs/)

**旧题目描述**：

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

解答：

```java
```



未完待续~~~