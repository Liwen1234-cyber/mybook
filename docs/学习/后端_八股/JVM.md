# JVM

## 知识点汇总

![](./images/20250709_171125_359.png)

## 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意一个安装了Java虚拟机的平台上，而不需要程序员为每一个平台单独重写或者是重新编译,Java虚拟机知道底层硬件平台的指令长度和其他特性。


## JMM(Java Memory Model)
> 为什么要有内存模型？
> 在传统计算机硬件内存架构中由于 CPU 和主内存间存在数量级的速率差，于是就引入了多级高速缓存来解决这个问题,但是多级缓存的引入又带来了缓存一致性的问题,为了解决缓存一致性问题,就抽象出了 JMM.

JMM 同步规定：
- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

由于 JVM 运行程序的实体是**线程**，而每个线程创建时 JVM 都会为其创建一个**工作内存**(每个线程的私有数据区域)，而 Java 内存模型中规定所有变量都存储在主内存，主内存是**共享内存区域**，所有线程都可访问，但线程对变量的操作必须在工作内存中进行。

首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存，不能直接操作主内存中的变量，不同的线程无法访问对方的工作内存，线程之间的通讯必须通过主内存来完成，其简要访问过程如下图:

![](./images/20250709_235338_942.png)

为了更精准控制工作内存和主内存间的交互，JMM 还定义了八种操作：

```text
lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态。
unclock（解锁）：作用于主内存的变量，把一个处于锁定的状态释放出来。
read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中
load（载入）：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。
use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎
assign（赋值）：作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量
store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递到主内存，以便write操作使用。
write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
```

JMM 是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作。由于**指令重排**,读写的顺序会被打乱,因此 JMM 需要保证原子性,可见性,有序性。主内存可以认为就是物理内存，而工作内存就是CPU缓存
    ```mermaid
    flowchart LR
    2["`基本数据类型读写,除long、double`"]
    3["`synchronized`"]
    4["`volatile`"]
    5["`happens-before`"]
    6(("`原子性`"))
    7(("`可见性`"))
    8(("`有序性`"))
    2-->6
    3-->6
    3-->7
    4-->7
    4-->8
    5-->8
    ```

**原子性**：Java内存模型通过**上述8种操作**(基本数据类型读写)来保证原子性操作，其中 lock 和 unlock 对应着 synchronized 关键字
**可见性**：当一个线程修改了某个变量的值,其他线程立即可以看到这个修改,这就是内存的可见性。通过volatile、synchronized、final来保证可见性。
**有序性**：由于处理器和编译器的重排序导致的有序性问题，通过volatile和happens-before来保证。

happens-before 原则：
1. 程序次序规则：一个线程内，按照代码顺序运行
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作
3. volatile 变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

### 线程私有区和线程共享区
![](./images/20250710_104935_308.png)

- 线程独占:栈、本地方法栈、程序计数器 
- 线程共享:堆、方法区

1. 栈：又称方法栈,线程私有的,线程在执行 Java 方法时都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息,调用方法时执行入栈,方法返回时执行出栈
2. 本地方法栈:与栈类似,也是用来保存执行方法的信息,执行Java方法是使用栈,执行Native方法时使用本地方法栈
3. 程序计数器:保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空
4. 堆:JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所有的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常。根据对象的存活周期不同,JVM把对象进行分代管理,然后由垃圾回收器进行垃圾的回收管理
5. 方法区：又称非堆区,用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据。1.7的永久代和1.8的元空间都是方法区的一种实现

### 栈和堆的区别
栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。
- 异常错误不同:栈空间不足：java.lang.StackOverFlowError;堆空间不足：java.lang.OutOfMemoryError
- 空间大小:栈的空间大小远远小于堆的

### 说说对象分配规则
- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

## 类加载与卸载
类加载过程:
![](./images/20250710_003751_216.png)

其中验证,准备,解析合称链接

- 加载:通过类的**完全限定名**查找此类字节码文件,再创建该字节码文件对应的Class对象
- 验证:确保Class文件符合当前虚拟机的要求
- 准备:进行内存分配,为static修饰的类变量分配内存(不包含final修饰的静态变量,因为final变量在编译时分配),并设置初始值
- 解析:将常量池中的符号引用替换为直接引用的过程,直接引用为直接指向目标的指针或者相对偏移量等.
- 初始化:主要完成静态块执行以及静态变量的赋值;当类被主动使用时时,先初始化父类,再初始化当前类(触发条件包括创建类的实例;访问类的静态方法或静态变量;使用Class.forName反射类;子类初始化)
- 卸载:Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,**只有**用户自定义的加载器加载的类才可以被卸载

### 加载机制-双亲委派模型
![](./images/20250710_005111_738.png)

双亲委派模式:即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器,父类加载器能够完成加载则成功返回,不能则子类加载器自己尝试加载

优点：
1. 避免类的重复加载
2. 避免Java的核心API被篡改

### 描述一下JVM加载class文件的原理机制？
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在**运行时查找和装入**类文件中的类。由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的
Class对象。加载完成后，此时Class对象还不完整;进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）。最后JVM对类进行初始化，包括：如果类存在直接的父类且还没有被初始化，就先初始化父类；如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了双亲委派机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM**不会**向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
- Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
- Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
- System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

### 说说Java对象创建过程
1. JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类
2. 为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”
3. 将除对象头外的对象内存空间初始化为0
4. 对对象头进行必要设置

### 知道类的生命周期吗？ 
类的生命周期包括加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程

加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。验证，文件格式、元数据、字节码、符号引用验证；准备，为类的静态变量分配内存，并将其初始化为默认值；解析，把类中的符号引用转换为直接引用初始化，为类的静态变量赋予正确的初始值;使用;卸载，执行垃圾回收 

### 简述Java的对象结构
Java对象由三个部分组成：对象头、实例数据、对齐填充。对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型 （即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）;对齐填充：JVM 要求对象起始地址必须是8字节的整数倍（8字节对齐）

## 垃圾回收

### 分代回收
分代回收基于两个事实:
1. 大部分对象很快就不使用了
2. 还有一部分不会立即无用,但也不会持续很长时间

![](./images/20250710_100805_076.png)

### 什么时候会触发FullGC
1. 老年代空间不足:只有在新生代对象转入和创建大对象、大数组时才会出现不足的现象。当执行Full GC后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space,为避免出错,调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
2. Permanet Generation空间满:PermanetGeneration中存放一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space,为避免出错，可增大Perm Gen空间或转为使用CMS GC。
3. CMS GC时出现promotion failed和concurrent mode failure:对于采用CMS进行老年代GC的程序，promotionfailed是在进行Minor GC时，survivor space放不下,而此时老年代也放不下造成的；concurrent mode failure是在执行 CMS GC的过程中同时有对象要放入老年代，而此时空间不足造成的.应对措施为：增大 survivor space、老年代空间或调低触发并发GC的比率
4. 在进行Minor GC时,统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间

### Minor GC与Full GC分别在什么时候发生？   
新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC 

### 垃圾回收算法
**G1算法**
![](./images/20250710_102519_816.png)

1.9后默认的垃圾回收算法,特点:同时注重高吞吐量(回收率)的低延迟(减少停顿),采用每次只清理一部分,而非全部来保证 STW 时间不会过长

其取消了幸存区与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),整体分为四种：Eden、Survioor、Old、Humongous(存储大对象)

整体上是**标记+整理**算法，两个区域之间是**复制**算法

G1垃圾收集过程主要分为4个阶段：
1. 初始标记(Initial Marking):标记 GC Roots 直接关联到的对象,会 STW
2. 并发标记(Concurrent Marking):GC 线程和应用线程并发执行,标记出所有回收对象
3. 最终标记(Final Marking):处理和标记并发标记后新产生的对象,会 STW
4. 筛选回收(Live Data Counting and Evacuation):根据回收价值和成本(暂停时间),选择性回收 region,回收时采用标记复制算法,多条收集器线程并发执行,不追求全部清理完,会 STW

CMS(Concurrent Mark-Sweep)以低延迟为目标的垃圾收集器
![](./images/20250710_102842_413.png)

### 如何判断对象可以被回收？   
判断对象是否存活一般有两种方式： 1
1. 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，但是无法解决对象相互循环引用的问题。 
2. 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的

### JVM的永久代中会发生垃圾回收么？ 
永久代会发生垃圾回收，如果永久代满了或者是超过了临界值，会触发Full GC。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。

### 你知道哪些垃圾收集算法
GC最基础的算法有三种： 标记-清除算法、复制算法、标记-整理算法，常用的垃圾回收器一般都采用**分代收集**算法。 
- 标记-清除（Mark-Sweep）算法:首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 
- 复制算法，将可用内存按容量划分为大小相等的两块(from和to)，每次只使用其中的一块。当这from内存用完了，就将还存活着的对象复制到to上面，然后 再把from的内存空间一次清理掉,然后交换from和to。 
- 标记-整理算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，形成一块连续的内存空间,然后直接清理掉端边界以外的内存
- 分代收集算法（Generational Collection），把Java堆分为新生代和老年代， 这样就可以根据各个年代的特点采用最适当的收集算法。 

### 调优命令有哪些？
Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo 
- jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 
- jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟 机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 
- jmap，JVM Memory Map命令用于生成heap dump文件 
- jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内 置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 
- jstack，用于生成java虚拟机当前时刻的线程快照。 
- jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 

### 常见调优工具有哪些 
常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 

- jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 
- jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 
- MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的 Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 
- GChisto，一款专业分析gc日志的工具 

### 你知道哪些JVM性能调优参数？（简单版回答） 
- 设定堆内存大小 -Xmx：堆内存最大限制。 
- 设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代 
  -XX:NewSize：新生代大小 
  -XX:NewRatio 新生代和老生代占比 
  -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比 
- 设定垃圾回收器 
  年轻代用 -XX:+UseParNewGC 
  年老代用-XX:+UseConcMarkSweepGC 

### 对象一定分配在堆中吗？有没有了解逃逸分析技术？   
「对象一定分配在堆中吗？」 不一定的，JVM通过「逃逸分析」，那些逃不出方法的对象会在栈上分配。 

如果一个对象的指针被多个方法或者线程引用时，那么就称这个对象的指针发生了**逃逸**。 

「什么是逃逸分析？」 逃逸分析(Escape Analysis)，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。 

「逃逸分析的好处」 
- 栈上分配，可以降低垃圾收集器运行的频率。 
- 同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。 
- 标量替换，把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。二、程序内存回收效率高，并 且GC频率也会减少。 



















未完待续...