# JVM

## 知识点汇总

![](./images/20250709_171125_359.png)

## 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意一个安装了Java虚拟机的平台上，而不需要程序员为每一个平台单独重写或者是重新编译,Java虚拟机知道底层硬件平台的指令长度和其他特性。


## JMM(Java Memory Model)
> 为什么要有内存模型？
> 在传统计算机硬件内存架构中由于 CPU 和主内存间存在数量级的速率差，于是就引入了多级高速缓存来解决这个问题,但是多级缓存的引入又带来了缓存一致性的问题,为了解决缓存一致性问题,就抽象出了 JMM.

JMM 同步规定：
- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

由于 JVM 运行程序的实体是**线程**，而每个线程创建时 JVM 都会为其创建一个**工作内存**(每个线程的私有数据区域)，而 Java 内存模型中规定所有变量都存储在主内存，主内存是**共享内存区域**，所有线程都可访问，但线程对变量的操作必须在工作内存中进行。

首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存，不能直接操作主内存中的变量，不同的线程无法访问对方的工作内存，线程之间的通讯必须通过主内存来完成，其简要访问过程如下图:

![](./images/20250709_235338_942.png)

为了更精准控制工作内存和主内存间的交互，JMM 还定义了八种操作：

```text
lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态。
unclock（解锁）：作用于主内存的变量，把一个处于锁定的状态释放出来。
read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中
load（载入）：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。
use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎
assign（赋值）：作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量
store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递到主内存，以便write操作使用。
write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
```

JMM 是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作。由于**指令重排**,读写的顺序会被打乱,因此 JMM 需要保证原子性,可见性,有序性。主内存可以认为就是物理内存，而工作内存就是CPU缓存
    ```mermaid
    flowchart LR
    2["`基本数据类型读写,除long、double`"]
    3["`synchronized`"]
    4["`volatile`"]
    5["`happens-before`"]
    6(("`原子性`"))
    7(("`可见性`"))
    8(("`有序性`"))
    2-->6
    3-->6
    3-->7
    4-->7
    4-->8
    5-->8
    ```

**原子性**：Java内存模型通过**上述8种操作**(基本数据类型读写)来保证原子性操作，其中 lock 和 unlock 对应着 synchronized 关键字
**可见性**：当一个线程修改了某个变量的值,其他线程立即可以看到这个修改,这就是内存的可见性。通过volatile、synchronized、final来保证可见性。
**有序性**：由于处理器和编译器的重排序导致的有序性问题，通过volatile和happens-before来保证。

happens-before 原则：
1. 程序次序规则：一个线程内，按照代码顺序运行
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作
3. volatile 变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

### 线程私有区和线程共享区
![](./images/20250710_104935_308.png)

- 线程独占:栈、本地方法栈、程序计数器 
- 线程共享:堆、方法区

1. 栈：又称方法栈,线程私有的,线程在执行 Java 方法时都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息,调用方法时执行入栈,方法返回时执行出栈
2. 本地方法栈:与栈类似,也是用来保存执行方法的信息,执行Java方法是使用栈,执行Native方法时使用本地方法栈
3. 程序计数器:保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空
4. 堆:JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所有的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常。根据对象的存活周期不同,JVM把对象进行分代管理,然后由垃圾回收器进行垃圾的回收管理
5. 方法区：又称非堆区,用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据。1.7的永久代和1.8的元空间都是方法区的一种实现

### 栈和堆的区别
栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。
- 异常错误不同:栈空间不足：java.lang.StackOverFlowError;堆空间不足：java.lang.OutOfMemoryError
- 空间大小:栈的空间大小远远小于堆的

### 说说对象分配规则
- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

## 类加载与卸载
类加载过程:
![](./images/20250710_003751_216.png)

其中验证,准备,解析合称链接

- 加载:通过类的**完全限定名**查找此类字节码文件,再创建该字节码文件对应的Class对象
- 验证:确保Class文件符合当前虚拟机的要求
- 准备:进行内存分配,为static修饰的类变量分配内存(不包含final修饰的静态变量,因为final变量在编译时分配),并设置初始值
- 解析:将常量池中的符号引用替换为直接引用的过程,直接引用为直接指向目标的指针或者相对偏移量等.
- 初始化:主要完成静态块执行以及静态变量的赋值;当类被主动使用时时,先初始化父类,再初始化当前类(触发条件包括创建类的实例;访问类的静态方法或静态变量;使用Class.forName反射类;子类初始化)
- 卸载:Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,**只有**用户自定义的加载器加载的类才可以被卸载

### 加载机制-双亲委派模型
![](./images/20250710_005111_738.png)

双亲委派模式:即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器,父类加载器能够完成加载则成功返回,不能则子类加载器自己尝试加载

优点：
1. 避免类的重复加载
2. 避免Java的核心API被篡改

### 描述一下JVM加载class文件的原理机制？
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在**运行时查找和装入**类文件中的类。由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的
Class对象。加载完成后，此时Class对象还不完整;进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）。最后JVM对类进行初始化，包括：如果类存在直接的父类且还没有被初始化，就先初始化父类；如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了双亲委派机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM**不会**向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
- Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
- Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
- System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

### 说说Java对象创建过程
1. JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类
2. 为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”
3. 将除对象头外的对象内存空间初始化为0
4. 对对象头进行必要设置

## 垃圾回收

### 分代回收
分代回收基于两个事实:
1. 大部分对象很快就不使用了
2. 还有一部分不会立即无用,但也不会持续很长时间

![](./images/20250710_100805_076.png)

### 什么时候会触发FullGC
1. 老年代空间不足:只有在新生代对象转入和创建大对象、大数组时才会出现不足的现象。当执行Full GC后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space,为避免出错,调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
2. Permanet Generation空间满:PermanetGeneration中存放一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space,为避免出错，可增大Perm Gen空间或转为使用CMS GC。
3. CMS GC时出现promotion failed和concurrent mode failure:对于采用CMS进行老年代GC的程序，promotionfailed是在进行Minor GC时，survivor space放不下,而此时老年代也放不下造成的；concurrent mode failure是在执行 CMS GC的过程中同时有对象要放入老年代，而此时空间不足造成的.应对措施为：增大 survivor space、老年代空间或调低触发并发GC的比率
4. 在进行Minor GC时,统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间



### 垃圾回收算法
**G1算法**
![](./images/20250710_102519_816.png)

1.9后默认的垃圾回收算法,特点:同时注重高吞吐量(回收率)的低延迟(减少停顿),采用每次只清理一部分,而非全部来保证 STW 时间不会过长

其取消了幸存区与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),整体分为四种：Eden、Survioor、Old、Humongous(存储大对象)

整体上是**标记+整理**算法，两个区域之间是**复制**算法

G1垃圾收集过程主要分为4个阶段：
1. 初始标记(Initial Marking):标记 GC Roots 直接关联到的对象,会 STW
2. 并发标记(Concurrent Marking):GC 线程和应用线程并发执行,标记出所有回收对象
3. 最终标记(Final Marking):处理和标记并发标记后新产生的对象,会 STW
4. 筛选回收(Live Data Counting and Evacuation):根据回收价值和成本(暂停时间),选择性回收 region,回收时采用标记复制算法,多条收集器线程并发执行,不追求全部清理完,会 STW

CMS(Concurrent Mark-Sweep)以低延迟为目标的垃圾收集器
![](./images/20250710_102842_413.png)


未完待续...