# JVM

## 知识点汇总

![](./images/20250709_171125_359.png)

## JMM(Java Memory Model)
- 线程独占:栈、本地方法栈、程序计数器 
- 线程共享:堆、方法区

JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作。由于**指令重排**,读写的顺序会被打乱,因此 JMM 需要保证原子性,可见性,有序性
    ```mermaid
    flowchart LR
    2["`基本数据类型读写,除long、double`"]
    3["`synchronized`"]
    4["`volatile`"]
    5["`happens-before`"]
    6(("`原子性`"))
    7(("`可见性`"))
    8(("`有序性`"))
    2-->6
    3-->6
    3-->7
    4-->7
    4-->8
    5-->8
    ```


JMM同步规定：
- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

由于 JVM 运行程序的实体是**线程**，而每个线程创建时 JVM 都会为其创建一个**工作内存**(每个线程的私有数据区域)，而 Java 内存模型中规定所有变量都存储在主内存，主内存是**共享内存区域**，所有线程都可访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存存着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，线程之间的通讯（传值）必须通过主内存来完成，其简要访问过程如下图:

1. 栈：又称方法栈,线程私有的,线程在执行 Java 方法时都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息,调用方法时执行入栈,方法返回时执行出栈
2. 本地方法栈:与栈类似,也是用来保存执行方法的信息,执行Java方法是使用栈,执行Native方法时使用本地方法栈
3. 程序计数器:保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空
4. 堆:JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所有的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常。根据对象的存活周期不同,JVM把对象进行分代管理,然后由垃圾回收器进行垃圾的回收管理
5. 方法区：又称非堆区,用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据。1.7的永久代和1.8的元空间都是方法区的一种实现
6. JVM 内存的可见性：当一个线程修改了某个变量的值,其他线程立即可以看到这个修改,这就是内存的可见性。JVM通过volatile关键字来保证内存可见性。
    



未完待续...