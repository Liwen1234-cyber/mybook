# 基础知识

## 计算机基础

### 计算机⽹络

#### 基础知识讲解

##### 在浏览器中输⼊URL并按下回车之后会发生什么

1. 第一步：输⼊URL并解析
   
   > 这⾥可以引申到URL的组成部分
   
   输⼊URL后，浏览器会解析出协议、主机、端⼝、路径等信息，并构造⼀个HTTP请求（浏览器会根据请求头判断是否有HTTP缓存，并根据是否有缓存决定是从服务器获取资源还是使⽤缓存资源，具体内容会在HTTP缓存章节讲解）
   
2. 第二步：DNS域名解析, 将域名解析成对应的IP地址
   
   在发送HTTP请求之前，浏览器需要知道想要访问⽹⻚(url)对应的IP地址，这就需要使⽤到 DNS域名解析 （DNS域名解析的具体内容也会在后⾯章节）。
   
3. 第三步：建⽴起TCP连接之三次握⼿
   
   > 这⾥是重中之重，可以扩展很多问题，⽐如为什么是三次，不是两次、四次？如果第⼀次握⼿丢失了会发⽣什么？三次握手过程中可以携带数据吗？
   
   客户端和服务器之间进⾏HTTP请求和HTTP响应的过程中，需要建⽴起TCP连接，TCP连接需要进⾏三次握⼿（具体内容在后⾯章节中讲解）。
   
4. 第四步：浏览器发送HTTP/HTTPS请求到web服务器
   
   > 这⼀步也可以扩展很多问题，⽐如HTTP/HTTPS的区别？请求的⽅式？请求的状态码，凡是与HTTP请求的问题都可以问
   
5. 第五步：服务器处理HTTP请求并返回HTTP报⽂
   
   > HTTP响应报⽂和状态码也是常考的内容
   
   服务器会接受请求并将其传递给请求处理程序并发送HTTP响应，⼀般响应报⽂包含：请求的⽹⻚以及状态码，压缩类型，如何缓存的⻚⾯，设置的cookie；
   
6. 第六步：浏览器渲染页面

   > 浏览器渲染⻚⾯的流程对于前端同学来说也是必会的、还会牵扯到回流和重绘的问题。

7. 第七步：断开连接之TCP四次挥⼿

   > 这⾥也是特别重要的知识点，四次挥⼿的过程，为什么是四次？
   
   客户端和服务器之间断开连接需要进⾏四次挥⼿（具体内容在后⾯章节汇总讲解）。

![image-20241127213142505](/images/image-20241127213142505.png)



##### DNS

DNS（Domain Name System）是⼀种⽤于将域名（例如www.baidu.com）转换为IP地址（例如220.181.111.188 ）的分布式系统。在互联⽹上，计算机和其他⽹络设备使⽤IP地址来相互识别和通信。然⽽，IP地址是⼀串数字，不太⽅便⼈们使⽤和记忆，所以就使⽤了域名来代替复杂的IP地址

![image-20241127231119212](/images/image-20241127231119212.png)

对于DNS服务器若采⽤集中式的设计有以下问题:

1. 单点故障

   如果 DNS 服务器崩溃，那么整个⽹络随之瘫痪。通信容量(traaffic volume) ，单个 DNS 服务器不得不处理所有的DNS 查询，这种查询级别可能是上百万上千万级，⼀台服务器很难满⾜;

2. 远距离集中式数据库

   单个DNS服务器不可能邻近所有的⽤户，假设在美国的DNS服务器不可能临近让澳⼤利亚的查询使⽤，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延；

3. 维护

   维护成本巨⼤，⽽且还需要频繁更新。

###### 域名的层级关系

DNS 中的域名都是⽤句点来分隔的，⽐如 www.server.com ，这⾥的句点代表了不同层次之间的界限。 在域名中，越靠右的位置表示其层级越⾼。

![image-20241127231641755](/images/image-20241127231641755.png)

###### DNS 解析过程

1. 先查询浏览器缓存是否有该域名对应的IP地址。
2. 如果浏览器缓存中没有，会去计算机本地的Host⽂件中查询是否有对应的缓存。
3. 如果Host⽂件中也没有则会向本地的DNS服务器（通常由你的互联⽹服务提供商（ISP）提供， ⽐如中国移动）发送⼀个DNS查询请求。
4. 如果本地DNS解析器有该域名的ip地址，就会直接返回，如果没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域（.com/.net/.org）的DNS服务器继续查询。
5. 本地 DNS 解析器接着向指定的顶级域名DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能告诉本地DNS解析器应该前往哪个权威DNS服务器查询下⼀步的信息。
6. 本地DNS解析器最后向权威DNS服务器发送查询请求。 权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找"example.com"域名对应的IP地址，并将结果返回给本地DNS解析器。
7. 本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地响应。
8. 浏览器发起连接： 本地DNS解析器已经将IP地址返回给您的计算机，您的浏览器可以使⽤该IP地址与⽬标服务器建⽴连接，开始获取⽹⻚内容。

![image-20241127231807661](/images/image-20241127231807661.png)

![image-20241127231831616](/images/image-20241127231831616.png)

![image-20241127231851436](/images/image-20241127231851436.png)

###### 递归查询和迭代查询

递归查询和迭代查询是在DNS解析过程中⽤于获取域名解析信息的两种不同⽅法。
1. 递归查询

  在递归查询中，DNS客户端（通常是本地DNS解析器）向上层DNS服务器（如根域名服务器、顶级域名服务器）发起查询请求，并要求这些服务器直接提供完整的解析结果。递归查询的特点是，DNS客户端只需要发送⼀个查询请求，然后等待完整的解析结果。上层DNS服务器会⾃⾏查询下⼀级的服务器，并将最终结果返回给DNS客户端。

2. 迭代查询

  在迭代查询中，DNS客户端向上层DNS服务器发起查询请求，但不要求直接提供完整的解析结果。相反，DNS客户端只是询问上层服务器⼀个更⾼级的域名服务器的地址，然后再⾃⾏向那个更⾼级的服务器发起查询请求，以此类推，直到获取完整的解析结果为⽌。

递归查询适合普通⽤户和客户端，⽽迭代查询适⽤于DNS服务器之间的通信。

##### HTTP特性与简述

特性：简单、灵活、易于扩展、应⽤⼴泛和跨平台。

**简述**：

Web 上的通信都是建⽴在 HTTP 协议上的

1. 客户端发起 HTTP 请求；
2. 服务器做出响应处理后，返回 HTTP 响应报⽂

最初设想的基本理念是：借助多⽂档之间相互关联形成的超⽂本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维⽹）

**WWW 构建技术（3 项）**：

1. HTML (HyperText Markup Language)：作为⻚⾯的⽂本标记语⾔
2. HTTP (HyperText Transfer Protocol)：⽂档传递协议；
3. URL (Uniform Resource Locator)：指定⽂档所在地址

**HTTP 版本**：

1. 1996 年的 5 ⽉，HTTP/1.0，并记载于 RFC1945。现在 HTTP/1.0，仍然被使⽤在服务器端；
2. 1997 年 1 ⽉，发布 HTTP/1.1 ，是⽬前主流的 HTTP 协议版本
3. 现今，HTTP/2.0 正在制订中，但还未得到⼴泛的使⽤

**特性**：

1. 简单

  基本报⽂格式为header+body，头部信息也是key-value简单⽂本的形式，易于理解。

2. 灵活和易于扩展

  - HTTP协议⾥的各种请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，允许开发⼈员⾃定义和扩充;
  - HTTP⼯作在应⽤层（OSI第七层），下层可以随意变化;
  - HTTPS就是在HTTP与TCP之间增加了SSL/TSL安全传输层，HTTP/3把TCP换成了基于UDP的QUIC。

3. ⽆状态、明⽂传输、不安全

  ⽆状态：

  服务器不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担。但它在完成有关联性的操作时会⾮常麻烦。

> 对于⽆状态的问题，解决⽅案友很多种，其中⽐较简单的⽅式的是 Cookie 技术， Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。

  ![image-20241130010107061](/images/image-20241130010107061.png)

  明⽂传输：

  传输过程中的信息，是可⽅便阅读的，通过浏览器的F12控制台或Wireshark抓包都可以直接⾁眼查看明⽂传输为我们调试⼯作带来了极⼤的便利性，但信息透明，容易被窃取。

  不安全：

  1. 通信使⽤明⽂（不加密），内容可能被窃听
  2. 不验证通信⽅的身份，因此有可能遭遇伪装
  3. ⽆法证明报⽂的完整性，所以有可能已遭篡改

  可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致。

##### HTTP版本演变

⽬前为⽌，HTTP 常⻅的版本有 HTTP/1.1 ， HTTP/2.0 ， HTTP/3.0 ，不同版本的 HTTP 特性是不⼀样的。

**HTTP/0.9**

HTTP/0.9 是最早的HTTP版本，在1991年就已经发布，只⽀持 GET ⽅法，也没有请求头，服务器只能返回 HTML格式的内容。

**HTTP/1.0**

HTTP/1.0 是HTTTP 协议的第⼀个正式版本, 主要具有以下特性：

- 引⼊了请求头和响应头，⽀持多种请求⽅法和状态码
- 不⽀持持久连接，每次请求都需要建⽴新的连接

**HTTP/1.1**

1. ⻓连接

  为了解决 HTTP/1.0 每次请求都需要建⽴新的连接的问题， HTTP/1.1 提出了⻓连接（持久连接），只要客户端和
  服务器任意⼀端没有明确提出断开连接，则保持TCP连接状态。

  ![image-20241130010837364](/images/image-20241130010837364.png)

2. 管道⽹络传输

  在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

  客户端需要请求两个资源。以前的做法是，在同⼀个 TCP 连接⾥⾯，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求

  ![image-20241130011003183](/images/image-20241130011003183.png)

  但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。

  如果服务端在处理 A 请求时耗时⽐较⻓，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

  所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。

> HTTP/1.1 管道化技术不是默认开启，⽽且浏览器基本都没有⽀持

3. 队头阻塞

  当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是「队头阻塞」

  ![image-20241130011129260](/images/image-20241130011129260.png)

  但是 HTTP1.1 仍然存在着不少问题：

  - 头部冗余：每个请求和响应都需要带有⼀定的头部信息，每次互相发送相同的⾸部造成的浪费较多；
  - 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
  - 没有请求优先级控制；
  - 请求只能从客户端开始，服务器只能被动响应。

**HTTP/2**

HTTP/2 协议是基于 HTTPS 的, 所以HTTP/2的安全性也是有保障的

![image-20241130011248674](/images/image-20241130011248674.png)

1. 头部压缩：HTTP/2 使⽤ HPACK 压缩算法对请求和响应头部进⾏压缩，减少了传输的头部数据量，降低了延迟。
2. ⼆进制帧：HTTP/2 将数据分割成⼆进制帧进⾏传输，分为**头信息帧**（Headers Frame）和**数据帧**（Data Frame），增加了数据传输的效率。
3. 并发传输：引出了 Stream 概念，多个 Stream 复⽤在⼀条 TCP 连接，针对不同的 HTTP 请求⽤独⼀⽆⼆的Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并⾏交错地发送请求和响应。
4. 服务器推送：在 HTTP/2 中，服务器可以对客户端的⼀个请求发送多个响应，即服务器可以额外的向客户端推送资源，⽽⽆需客户端明确的请求。

但是 HTTP/2 仍然存在着队头阻塞的问题，只不过问题是在传输层。

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节数据到达时，HTTP/2 应⽤层才能从内核中拿到数据，这就是 HTTP/2队头阻塞问题。

![image-20241130011453939](/images/image-20241130011453939.png)





未完待续~~~
