# 二分

## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**朴素解法**

如果忽略进阶的 O(log(m+n)) 要求，这道题就非常简单。

一个比较直观的做法：将两个数组合并，排序，然后分别取得 total / 2 和 (total - 1) / 2 两个位置的数，取两者平均值。

时间复杂度：合并两个数组的复杂度是 O(m+n)，对合并数组进行排序的复杂度是 O((m+n)log(m+n))。整体复杂度是 O((m+n)log(m+n))
空间复杂度：O(1)

解答：

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        boolean isOdd = (m + n) % 2 == 1;
        if(isOdd){
            return getKth(nums1, 0, nums2, 0, (m + n) / 2 + 1);
        } else {
            int first = getKth(nums1, 0, nums2, 0, (m + n) / 2);
            int second = getKth(nums1, 0, nums2, 0, (m + n) / 2 + 1);
            return (double)(first + second) / 2;
        }

    }
    private int getKth(int[] nums1, int i, int[] nums2, int j, int k){ // i, j are the start indices of nums1 and nums2 respectively, k is the kth element.
        if(nums1.length - i > nums2.length - j){ // if nums1 has more elements, then we need to swap nums1 and nums2.
            return getKth(nums2, j, nums1, i, k);
        }
        if(i >= nums1.length) return nums2[j + k - 1];

        if(k == 1) return Math.min(nums1[i], nums2[j]);
        else{
            int si = Math.min((i + k / 2 - 1), (nums1.length - 1));
            int sj = k - (si - i + 1) + (j - 1);
            if(nums1[si] > nums2[sj]){ // the kth element isn't in nums2[j, sj]
                return getKth(nums1, i, nums2, sj + 1, k - (sj - j + 1));
            } else if(nums1[si] < nums2[sj]){ // the kth element isn't in nums1[i, si]
                return getKth(nums1, si + 1, nums2, j, k - (si - i + 1));
            } else {
                return nums1[si];
            }
        }
    }
}
```



未完待续~~~