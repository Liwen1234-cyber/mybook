# å…¶ä»–

## [åˆ é™¤ä¸‰å…ƒç»„](https://kamacoder.com/problempage.php?pid=1246)

é¢˜ç›®æè¿°

å°çº¢æœ‰ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ aï¼Œå¥¹æ¯æ¬¡æ“ä½œå¯ä»¥åˆ æ‰ä¸€ä¸ªä¸‰å…ƒç»„ï¼ˆx,y,zï¼‰ï¼Œè¦æ±‚ x < y < zï¼Œy æ˜¯ x çš„å€æ•°ï¼Œz æ˜¯ y çš„å€æ•°ã€‚å°çº¢æƒ³çŸ¥é“æœ€å¤šå¯ä»¥æ‰§è¡Œå¤šå°‘æ¬¡æ“ä½œã€‚

è¾“å…¥æè¿°

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° nï¼ˆ1 <= n <= 10^5ï¼‰ï¼Œè¡¨ç¤ºæ•°ç»„çš„é•¿åº¦ã€‚

ç¬¬äºŒè¡Œ n ä¸ªæ•´æ•° a1ï¼Œa2ï¼Œ...ï¼Œan (1 <= ai <= 6)ï¼Œè¡¨ç¤ºæ•°ç»„çš„å…ƒç´ ã€‚

è¾“å‡ºæè¿°

è¾“å‡ºä¸€ä¸ªéè´Ÿæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å¤šå¯ä»¥æ‰§è¡Œå¤šå°‘æ¬¡æ“ä½œã€‚

è¾“å…¥ç¤ºä¾‹

```
7
1 1 2 3 4 5 6
```

è¾“å‡ºç¤ºä¾‹

```
2
```

æç¤ºä¿¡æ¯

å…ˆåˆ é™¤(1, 2, 4)ï¼Œå†åˆ é™¤(1, 3, 6)

**è§£ç­”**ï¼š

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] count = new int[7];
        int cnt = 0;
        for(int i = 0;i < n;i++){
            count[scanner.nextInt()]++;
        }
        for(int i = 2;i <= 3;i++){
            for(int j = 2 * i;j <= 6;j+=i){
                int minnum = Math.min(Math.min(count[1],count[i]),count[j]);
                    count[i]-=minnum;
                    count[j]-=minnum;
                    count[1]-=minnum;
                    cnt+=minnum;
                    if(count[1] ==0){
                        System.out.println(cnt);
                        return;
                    }
            }
        }
        System.out.println(cnt);
    }
}
```

## [éè¿ç»­åˆæ³•å­—ç¬¦ä¸²](https://kamacoder.com/problempage.php?pid=1247)

é¢˜ç›®æè¿°

å°çº¢æœ‰ä¸€ä¸ªå­—ç¬¦ä¸² sï¼ŒåªåŒ…å«å°å†™å­—æ¯ã€‚å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ï¼Œä¸åŒ…å«è¿ç»­çš„ä¸‰ä¸ªç›¸åŒçš„å­—æ¯ï¼Œå¹¶ä¸”ä¸å­˜åœ¨ä¸¤ä¸ªç›¸åŒçš„å­—æ¯ç´§æŒ¨ç€ä¸¤ä¸ªç›¸åŒçš„å­—æ¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸²å°±æ˜¯åˆæ³•çš„ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²"aaa"æ˜¯ä¸åˆæ³•çš„ï¼Œå­—ç¬¦ä¸²"aabb"ä¹Ÿæ˜¯ä¸åˆæ³•çš„ã€‚å­—ç¬¦ä¸²"aab"æ˜¯åˆæ³•çš„ã€‚

å°çº¢æƒ³çŸ¥é“ï¼Œæœ€å°‘éœ€è¦åˆ é™¤å¤šå°‘ä¸ªå­—ç¬¦ï¼Œæ‰èƒ½ä½¿å¾—å­—ç¬¦ä¸²å˜æˆåˆæ³•çš„ã€‚

è¾“å…¥æè¿°

ç¬¬ä¸€è¡Œä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œé•¿åº¦ä¸è¶…è¿‡ 10^5ï¼ŒåªåŒ…å«å°å†™å­—æ¯ã€‚

è¾“å‡ºæè¿°

è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å°‘éœ€è¦åˆ é™¤çš„å­—ç¬¦ä¸ªæ•°ã€‚

è¾“å…¥ç¤ºä¾‹

```
aabbaa
```

è¾“å‡ºç¤ºä¾‹

```
1
```

æç¤ºä¿¡æ¯

åˆ é™¤ä¸€ä¸ªå­—ç¬¦ bï¼Œå¾—åˆ° aabaaï¼Œæ˜¯ä¸€ä¸ªåˆæ³•çš„å­—ç¬¦ä¸²ã€‚

**è§£ç­”**ï¼š

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

        String str = in.readLine();
        int count = 0;
        int n = str.length();
        for(int i = 0; i < n; ++i){
            //aaa
            if((i + 2) < n && str.charAt(i) == str.charAt(i+1) && str.charAt(i+1) == str.charAt(i+2)){
                str = i == n - 3 ? str.substring(0, i+2) : str.substring(0, i+2) + str.substring(i+3, n);
                n--;
                i--;
                count++;
            }
            //aabb
            if(i < 0){
                continue;
            }
            if((i + 3) < n && str.charAt(i) == str.charAt(i+1) && str.charAt(i+2) == str.charAt(i+3) && str.charAt(i) != str.charAt(i+2) ){
                str =  i == n-4 ? str.substring(0, i+3) : str.substring(0, i+3) + str.substring(i+4, n);
                n--;
                i--;
                count++;
            }
        }

        System.out.println(count);
    }
}
```

## çº¦ç‘Ÿå¤«ç¯

çº¦ç‘Ÿå¤«é—®é¢˜æ˜¯ä¸ªè‘—åçš„é—®é¢˜ï¼šN ä¸ªäººå›´æˆä¸€åœˆï¼Œç¬¬ä¸€ä¸ªäººä» 1 å¼€å§‹æŠ¥æ•°ï¼ŒæŠ¥ M çš„å°†è¢«æ€æ‰ï¼Œä¸‹ä¸€ä¸ªäººæ¥ç€ä» 1 å¼€å§‹æŠ¥ã€‚å¦‚æ­¤åå¤ï¼Œæœ€åå‰©ä¸‹ä¸€ä¸ªï¼Œæ±‚æœ€åçš„èƒœåˆ©è€…ã€‚
ä¾‹å¦‚åªæœ‰ä¸‰ä¸ªäººï¼ŒæŠŠä»–ä»¬å«åš Aã€Bã€Cï¼Œä»–ä»¬å›´æˆä¸€åœˆï¼Œä» A å¼€å§‹æŠ¥æ•°ï¼Œå‡è®¾æŠ¥ 2 çš„äººè¢«æ€æ‰ã€‚

å…¬å¼æ³•
çº¦ç‘Ÿå¤«ç¯æ˜¯ä¸€ä¸ªç»å…¸çš„æ•°å­¦é—®é¢˜ï¼Œæˆ‘ä»¬ä¸éš¾å‘ç°è¿™æ ·çš„ä¾æ¬¡æŠ¥æ•°ï¼Œä¼¼ä¹æœ‰è§„å¾‹å¯å¾ªã€‚ä¸ºäº†æ–¹ä¾¿å¯¼å‡ºé€’æ¨å¼ï¼Œæˆ‘ä»¬é‡æ–°å®šä¹‰ä¸€ä¸‹é¢˜ç›®ã€‚
é—®é¢˜ï¼š N ä¸ªäººç¼–å·ä¸º 1ï¼Œ2ï¼Œâ€¦â€¦ï¼ŒNï¼Œä¾æ¬¡æŠ¥æ•°ï¼Œæ¯æŠ¥åˆ° M æ—¶ï¼Œæ€æ‰é‚£ä¸ªäººï¼Œæ±‚æœ€åèƒœåˆ©è€…çš„ç¼–å·ã€‚

è¿™è¾¹æˆ‘ä»¬å…ˆæŠŠç»“è®ºæŠ›å‡ºäº†ã€‚ä¹‹åå¸¦é¢†å¤§å®¶ä¸€æ­¥ä¸€æ­¥çš„ç†è§£è¿™ä¸ªå…¬å¼æ˜¯ä»€ä¹ˆæ¥çš„ã€‚
é€’æ¨å…¬å¼ï¼š

$$
f(N,M)=(f(N-1,M)+M)\%N
$$

$f(N,M)$ è¡¨ç¤ºï¼ŒN ä¸ªäººæŠ¥æ•°ï¼Œæ¯æŠ¥åˆ° M æ—¶æ€æ‰é‚£ä¸ªäººï¼Œæœ€ç»ˆèƒœåˆ©è€…çš„ç¼–å·
$f(N-1,M)$ è¡¨ç¤ºï¼ŒN-1 ä¸ªäººæŠ¥æ•°ï¼Œæ¯æŠ¥åˆ° M æ—¶æ€æ‰é‚£ä¸ªäººï¼Œæœ€ç»ˆèƒœåˆ©è€…çš„ç¼–å·

ä¸‹å›¾è¡¨ç¤ºè¿™ä¸€è¿‡ç¨‹ï¼ˆå…ˆå¿½è§†ç»¿è‰²çš„ä¸€è¡Œï¼‰:

![è¿™é‡Œå†™å›¾ç‰‡æè¿°](./images/92c80e4b888fded8c7cb8535756675e6.png)

æ¨å¯¼è¿™ä¸ªå…¬å¼ã€‚

- é—®é¢˜ 1ï¼š å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“ 11 ä¸ªäººæ—¶ï¼Œèƒœåˆ©è€…çš„ä¸‹æ ‡ä½ç½®ä¸º 6ã€‚é‚£ä¸‹ä¸€è½® 10 ä¸ªäººæ—¶ï¼Œèƒœåˆ©è€…çš„ä¸‹æ ‡ä½ç½®ä¸ºå¤šå°‘ï¼Ÿ

  ç­”ï¼š å…¶å®å§ï¼Œç¬¬ä¸€è½®åˆ æ‰ç¼–å·ä¸º 3 çš„äººåï¼Œä¹‹åçš„äººéƒ½å¾€å‰é¢ç§»åŠ¨äº† 3 ä½ï¼Œèƒœåˆ©è¿™ä¹Ÿå¾€å‰ç§»åŠ¨äº† 3 ä½ï¼Œæ‰€ä»¥ä»–çš„ä¸‹æ ‡ä½ç½®ç”± 6 å˜æˆ 3ã€‚

- é—®é¢˜ 2ï¼š å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“ 10 ä¸ªäººæ—¶ï¼Œèƒœåˆ©è€…çš„ä¸‹æ ‡ä½ç½®ä¸º 3ã€‚é‚£ä¸‹ä¸€è½® 11 ä¸ªäººæ—¶ï¼Œèƒœåˆ©è€…çš„ä¸‹æ ‡ä½ç½®ä¸ºå¤šå°‘ï¼Ÿ

  ç­”ï¼š è¿™å¯ä»¥çœ‹é”™æ˜¯ä¸Šä¸€ä¸ªé—®é¢˜çš„é€†è¿‡ç¨‹ï¼Œå¤§å®¶éƒ½å¾€åç§»åŠ¨ 3 ä½ï¼Œä¸è¿‡æœ‰å¯èƒ½æ•°ç»„ä¼šè¶Šç•Œï¼Œæ‰€ä»¥æœ€åæ¨¡ä¸Šå½“å‰äººæ•°çš„ä¸ªæ•°

- é—®é¢˜ 3ï¼š ç°åœ¨æ”¹ä¸ºäººæ•°æ”¹ä¸º Nï¼ŒæŠ¥åˆ° M æ—¶ï¼ŒæŠŠé‚£ä¸ªäººæ€æ‰ï¼Œé‚£ä¹ˆæ•°ç»„æ˜¯æ€ä¹ˆç§»åŠ¨çš„ï¼Ÿ
  ç­”ï¼š æ¯æ€æ‰ä¸€ä¸ªäººï¼Œä¸‹ä¸€ä¸ªäººæˆä¸ºå¤´ï¼Œç›¸å½“äºæŠŠæ•°ç»„å‘å‰ç§»åŠ¨ M ä½ã€‚è‹¥å·²çŸ¥ N-1 ä¸ªäººæ—¶ï¼Œèƒœåˆ©è€…çš„ä¸‹æ ‡ä½ç½®ä½$f(N-1,M)$ï¼Œåˆ™ N ä¸ªäººçš„æ—¶å€™ï¼Œå°±æ˜¯å¾€åç§»åŠ¨ M ä¸ºï¼Œ(å› ä¸ºæœ‰å¯èƒ½æ•°ç»„è¶Šç•Œï¼Œè¶…è¿‡çš„éƒ¨åˆ†ä¼šè¢«æ¥åˆ°å¤´ä¸Šï¼Œæ‰€ä»¥è¿˜è¦æ¨¡ N)ï¼Œæ—¢$f(N,M)=(f(N-1,M)+M)\%N$

**æ³¨ï¼š**ç†è§£è¿™ä¸ªé€’æ¨å¼çš„æ ¸å¿ƒåœ¨äºå…³æ³¨èƒœåˆ©è€…çš„ä¸‹æ ‡ä½ç½®æ˜¯æ€ä¹ˆå˜çš„ã€‚æ¯æ€æ‰ä¸€ä¸ªäººï¼Œå…¶å®å°±æ˜¯æŠŠè¿™ä¸ªæ•°ç»„å‘å‰ç§»åŠ¨äº† M ä½ã€‚ç„¶åé€†è¿‡æ¥ï¼Œå°±å¯ä»¥å¾—åˆ°è¿™ä¸ªé€’æ¨å¼ã€‚

å› ä¸ºæ±‚å‡ºçš„ç»“æœæ˜¯æ•°ç»„ä¸­çš„ä¸‹æ ‡ï¼Œæœ€ç»ˆçš„ç¼–å·è¿˜è¦åŠ  1

```java
    // çº¦ç‘Ÿå¤«ç¯é—®é¢˜çš„è§£å†³æ–¹æ³•ï¼Œæ¥æ”¶æ€»äººæ•° n å’ŒæŠ¥æ•° m ä½œä¸ºå‚æ•°
    public static int josephus(int n, int m) {
        // åˆå§‹åŒ–ç»“æœä¸º 0
        int result = 0;
        // ä» 2 å¼€å§‹å¾ªç¯åˆ° nï¼Œæ¨¡æ‹Ÿçº¦ç‘Ÿå¤«ç¯çš„æŠ¥æ•°è¿‡ç¨‹
        for (int i = 2; i <= n; i++) {
            // æ ¹æ®çº¦ç‘Ÿå¤«ç¯çš„é€’æ¨å…¬å¼æ›´æ–°ç»“æœ
            result = (result + m) % i;
        }
        // è¿”å›æœ€åå‰©ä¸‹çš„äººçš„ç¼–å·ï¼Œå› ä¸ºç¼–å·ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥åŠ  1
        return result + 1;
    }

```

### [390. æ¶ˆé™¤æ¸¸æˆ](https://leetcode.cn/problems/elimination-game/)

åˆ—è¡¨ `arr` ç”±åœ¨èŒƒå›´ `[1, n]` ä¸­çš„æ‰€æœ‰æ•´æ•°ç»„æˆï¼Œå¹¶æŒ‰ä¸¥æ ¼é€’å¢æ’åºã€‚è¯·ä½ å¯¹ `arr` åº”ç”¨ä¸‹è¿°ç®—æ³•ï¼š

- ä»å·¦åˆ°å³ï¼Œåˆ é™¤ç¬¬ä¸€ä¸ªæ•°å­—ï¼Œç„¶åæ¯éš”ä¸€ä¸ªæ•°å­—åˆ é™¤ä¸€ä¸ªï¼Œç›´åˆ°åˆ°è¾¾åˆ—è¡¨æœ«å°¾ã€‚
- é‡å¤ä¸Šé¢çš„æ­¥éª¤ï¼Œä½†è¿™æ¬¡æ˜¯ä»å³åˆ°å·¦ã€‚ä¹Ÿå°±æ˜¯ï¼Œåˆ é™¤æœ€å³ä¾§çš„æ•°å­—ï¼Œç„¶åå‰©ä¸‹çš„æ•°å­—æ¯éš”ä¸€ä¸ªåˆ é™¤ä¸€ä¸ªã€‚
- ä¸æ–­é‡å¤è¿™ä¸¤æ­¥ï¼Œä»å·¦åˆ°å³å’Œä»å³åˆ°å·¦äº¤æ›¿è¿›è¡Œï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªæ•°å­—ã€‚

ç»™ä½ æ•´æ•° `n` ï¼Œè¿”å› `arr` æœ€åå‰©ä¸‹çš„æ•°å­—ã€‚

è§£ç­”ï¼š

```java
class Solution {
    public int lastRemaining(int n) {
        if(n == 1) return 1;
        boolean left = true;
        int step = 1, head = 1;
        while(n > 1){
            if(left || (n & 1) == 1){ //if people in the odd positions are removed, the head will change
                head += step;
            }
            step <<= 1;
            left = !left;
            n >>= 1;
        }
        return head;
    }
}
```

## æ’åº

```java
import java.util.ArrayList;
import java.util.List;

class SortingAlgorithms {

    // Bubble Sort
    public void bubbleSort(int[] array) {
        int n = array.length;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    swapped = true;
                }
            }
            if (!swapped) break;
        }
    }

    // Selection Sort
    public void selectionSort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
    }

    // Insertion Sort
    public void insertionSort(int[] array) {
        int n = array.length;
        for (int i = 1; i < n; i++) {
            int key = array[i];
            int j = i - 1;
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j = j - 1;
            }
            array[j + 1] = key;
        }
    }

    // Merge Sort
    public void mergeSort(int[] array) {
        if (array.length < 2) {
            return;
        }
        int mid = array.length / 2;
        int[] left = new int[mid];
        int[] right = new int[array.length - mid];
        System.arraycopy(array, 0, left, 0, mid);
        System.arraycopy(array, mid, right, 0, array.length - mid);
        mergeSort(left);
        mergeSort(right);
        merge(array, left, right);
    }

    private void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k++] = left[i++];
            } else {
                array[k++] = right[j++];
            }
        }
        while (i < left.length) {
            array[k++] = left[i++];
        }
        while (j < right.length) {
            array[k++] = right[j++];
        }
    }

    // Quick Sort
    public void quickSort(int[] array) {
        quickSort(array, 0, array.length - 1);
    }

    private void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int pi = partition(array, low, high);
            quickSort(array, low, pi - 1);
            quickSort(array, pi + 1, high);
        }
    }

    private int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int i = (low - 1);
        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
        int temp = array[i + 1];
        array[i + 1] = array[high];
        array[high] = temp;
        return i + 1;
    }

    // Heap Sort
    public void heapSort(int[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }
        for (int i = n - 1; i > 0; i--) {
            int temp = array[0];
            array[0] = array[i];
            array[i] = temp;
            heapify(array, i, 0);
        }
    }

    private void heapify(int[] array, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        if (left < n && array[left] > array[largest]) {
            largest = left;
        }
        if (right < n && array[right] > array[largest]) {
            largest = right;
        }
        if (largest != i) {
            int swap = array[i];
            array[i] = array[largest];
            array[largest] = swap;
            heapify(array, n, largest);
        }
    }

    // Counting Sort
    public void countingSort(int[] array) {
        int max = getMax(array);
        int[] count = new int[max + 1];
        for (int value : array) {
            count[value]++;
        }
        int index = 0;
        for (int i = 0; i < count.length; i++) {
            while (count[i] > 0) {
                array[index++] = i;
                count[i]--;
            }
        }
    }

    private int getMax(int[] array) {
        int max = array[0];
        for (int value : array) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }

    // Radix Sort
    public void radixSort(int[] array) {
        int max = getMax(array);
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(array, exp);
        }
    }

    private void countingSortByDigit(int[] array, int exp) {
        int n = array.length;
        int[] output = new int[n];
        int[] count = new int[10];
        for (int value : array) {
            count[(value / exp) % 10]++;
        }
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        for (int i = n - 1; i >= 0; i--) {
            output[count[(array[i] / exp) % 10] - 1] = array[i];
            count[(array[i] / exp) % 10]--;
        }
        System.arraycopy(output, 0, array, 0, n);
    }

    // Bucket Sort
    public void bucketSort(int[] array) {
        int max = getMax(array);
        int min = getMin(array);
        int bucketSize = max - min + 1;
        List<Integer>[] buckets = new List[bucketSize];
        for (int i = 0; i < bucketSize; i++) {
            buckets[i] = new ArrayList<>();
        }
        for (int value : array) {
            buckets[value - min].add(value);
        }
        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (int value : bucket) {
                array[index++] = value;
            }
        }
    }

    private int getMin(int[] array) {
        int min = array[0];
        for (int value : array) {
            if (value < min) {
                min = value;
            }
        }
        return min;
    }

    // Shell Sort
    public void shellSort(int[] array) {
        int n = array.length;
        for (int gap = n / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < n; i++) {
                int key = array[i];
                int j = i;
                while (j >= gap && array[j - gap] > key) {
                    array[j] = array[j - gap];
                    j -= gap;
                }
                array[j] = key;
            }
        }
    }

    // Print Array
    public void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

}
```

## 31.ä¸‹ä¸€ä¸ªæ’åˆ—

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/next-permutation/)

å®ç°è·å– ä¸‹ä¸€ä¸ªæ’åˆ— çš„å‡½æ•°ï¼Œç®—æ³•éœ€è¦å°†ç»™å®šæ•°å­—åºåˆ—é‡æ–°æ’åˆ—æˆå­—å…¸åºä¸­ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ã€‚

å¦‚æœä¸å­˜åœ¨ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ï¼Œåˆ™å°†æ•°å­—é‡æ–°æ’åˆ—æˆæœ€å°çš„æ’åˆ—ï¼ˆå³å‡åºæ’åˆ—ï¼‰ã€‚

å¿…é¡» åŸåœ° ä¿®æ”¹ï¼Œåªå…è®¸ä½¿ç”¨é¢å¤–å¸¸æ•°ç©ºé—´ã€‚

è§£ç­”ï¼š

```java
import java.util.Arrays;

class Solution {
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length <= 1) return;
        int prev = nums.length - 1;
        for(int i = nums.length - 1; i >= 0; i--){
            if(nums[prev] > nums[i]){ // find the first number that is lower than nums[prev]
                for(int j = prev + 1; j < nums.length; j++){ // find the smallest number greater than nums[i]
                    if(nums[j] > nums[i] && nums[j] < nums[prev]) prev = j;
                }
                swap(nums, prev, i);
                prev = i + 1;

                break;
            }
            else if(nums[prev] <= nums[i]){
                prev = i;
            }
        }

        Arrays.sort(nums, prev, nums.length);
    }
    public void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## 1356. æ ¹æ®æ•°å­—äºŒè¿›åˆ¶ä¸‹ 1 çš„æ•°ç›®æ’åº

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)

é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ arr ã€‚è¯·ä½ å°†æ•°ç»„ä¸­çš„å…ƒç´ æŒ‰ç…§å…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ•°å­— 1 çš„æ•°ç›®å‡åºæ’åºã€‚

å¦‚æœå­˜åœ¨å¤šä¸ªæ•°å­—äºŒè¿›åˆ¶ä¸­ 1 çš„æ•°ç›®ç›¸åŒï¼Œåˆ™å¿…é¡»å°†å®ƒä»¬æŒ‰ç…§æ•°å€¼å¤§å°å‡åºæ’åˆ—ã€‚

è¯·ä½ è¿”å›æ’åºåçš„æ•°ç»„ã€‚

è§£ç­”ï¼š

```java
import java.util.Arrays;
import java.util.Comparator;

class Solution {
    public int[] sortByBits(int[] arr) {
        return Arrays.stream(arr).boxed()
                .sorted(new Comparator<Integer>() {
                    @Override
                    public int compare(Integer o1, Integer o2) {
                        if(countBits(o1) == countBits(o2)) return o1 - o2;
                        else return countBits(o1) - countBits(o2);
                    }
                })
                .mapToInt(i -> i)
                .toArray();
    }

    public int countBits(int num){
        int count = 0;
        while(num > 0) {
            count++;
            num &= (num - 1);
        }
        return count;
    }
}
```

## [CACC å¤èµ›](https://snail.cronlygames.cn/home)

### å“ˆå¸Œç¢°æ’

ç»™å®šé•¿åº¦ n ä¸ä¸€ä¸ªéšæœºå­—ç¬¦ä¸² key ï¼Œå®šä¹‰ $SHA256_n(S)$ ä¸ºå–å­—ç¬¦ä¸² S çš„$SHA256$å“ˆå¸Œçš„å‰ n ä¸ª 16 è¿›åˆ¶ä½æ„æˆå­—ç¬¦ä¸²ï¼Œè¦æ±‚ä½ æ„é€ ä¸¤ä¸ªé•¿åº¦å‡ä¸ºçš„ä¸åŒçš„å­—ç¬¦ä¸² S1 ä¸ S2 ï¼Œä½¿å¾— $S1\ne S2$ ï¼Œ $|S1|=|S2|=n$ ä¸” $SHA256_n(key+S1)=SHA256_n(key+S2)$ ã€‚

è¿™ä¸ªé¢˜çœ‹èµ·æ¥æ˜¯å®‰å…¨ç›¸å…³ï¼Œä½†å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ•°å­¦é¢˜åŠ ä¸Šä»£ç ä¼˜åŒ–æœ‰å…³çš„é¢˜ç›®ã€‚é¢˜æ„è¾ƒä¸ºå®¹æ˜“ç†è§£ï¼Œä½†æ˜¯å®ƒç‰¹å®šçš„è¦æ±‚æ˜¯å¡ç©ºé—´ 128KBï¼Œæ‰€ä»¥è¿™é‡Œå‡ ä¹åªèƒ½å­˜å‚¨å¸¸æ•°çº§åˆ«çš„æ•°æ®ã€‚

å®¹æ˜“å‘ç°ç›´æ¥æšä¸¾ç„¶åè®°å½•ä¸€ä¸‹å·²ç»å‡ºç°è¿‡çš„å“ˆå¸Œå€¼ï¼Œå°±å¯ä»¥åœ¨ $n\leq 7$ çš„æƒ…å†µå¾ˆå¿«è·‘å‡ºæ¥ï¼Œä½†æ˜¯å®ƒå®åœ¨æ˜¯å¤ªå ç©ºé—´äº†ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§å¸¸æ•°ç©ºé—´å¤æ‚åº¦å³å°½å¯èƒ½è¾¾åˆ° $O(1)$ ç©ºé—´å ç”¨ã€‚

æœ‰ä¸€ç§å¸¸ç”¨çš„åˆ¤æ–­ç­‰å€¼å‡½æ•°çš„æ–¹å¼å°±æ˜¯è¿­ä»£æ³•ï¼Œä¹Ÿå³é€šè¿‡è®¡ç®— $x , f(x) , f(f(x)) ...$ æ–¹å¼ï¼Œè®°å½•ä¸€ä¸‹è‡ªå˜é‡ä¸å‡½æ•°å€¼ï¼Œå®¹æ˜“å‘ç°è¿™ä¸ªçš„æœ¬è´¨æ˜¯åœ¨éå†ä¸€å¼ æœ‰ n ä¸ªç‚¹ n æ¡è¾¹çš„ï¼Œæœ‰å”¯ä¸€ä¸€ä¸ªç¯å’Œè‡³å¤šä¸€æ¡é“¾çš„åŸºç¯æ ‘ï¼Œé‚£ä¹ˆè¿™é¢˜ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œéšæœºä¸€ä¸ªåˆå§‹å­—ç¬¦ä¸²åå¤è¿­ä»£ï¼Œè‹¥å‡ºç°ç¯ï¼ˆå½“ç„¶éœ€è¦é“¾å¤§å°ä¸ä¸º 0ï¼‰é‚£å°±æ‰¾åˆ°äº†ä¸€ç»„å†²çªï¼Œä½†æ˜¾ç„¶ä¸èƒ½æŠŠç¯è®°å½•ä¸‹æ¥ã€‚ç”±äºç”Ÿæ—¥æ‚–è®ºä¸å“ˆå¸Œçš„éšæœºæ€§ï¼Œè¿™ä¸ªæ‰¾åˆ°ç¯çš„æ­¥æ•°è¿œè¿œå°äºå–å€¼ç©ºé—´çš„å¤§å°ï¼Œè¿™å°±ç»™äº†æˆ‘ä»¬åœ¨çŸ­æ—¶é—´å†…è§£å†³é—®é¢˜çš„å¥‘æœºã€‚

å¯ä»¥è®¤ä¸ºæ˜¯ç»“ç‚¹ x çš„ä¸‹ä¸€è·³æŒ‡åˆ° f(x) ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹å¼æ¥åˆ¤ç¯ï¼ŒåŒæ—¶è·å¾—ä¸€ä¸ªå¾ˆé‡è¦çš„æ•°æ® step ï¼Œ step çš„å«ä¹‰æ˜¯ï¼šä»åˆå§‹å­—ç¬¦ä¸²å‡ºå‘ï¼Œç»ç”± step è½®ä¸Šè¿°æ“ä½œåï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²ä¸€æ ·ã€‚

step ç»™äº†æˆ‘ä»¬ä¸‰ä¸ªå¾ˆé‡è¦çš„ä¿¡æ¯ï¼šç¬¬ä¸€ï¼Œè¿™ä¸ªåŸºç¯æ ‘çš„å¤§å°å¤§äºç­‰äº step ï¼Œå› ä¸ºä¸¤ä¸ªæŒ‡é’ˆèµ°åˆ°ä¸€èµ·æ—¶ï¼Œæ¯æ¬¡åªè·³ä¸€æ­¥çš„æŒ‡é’ˆä¸€å®šèµ°åœ¨ç¯ä¸Šï¼Œä¸”å®ƒæ¯ä¸ªç‚¹è‡³å¤šéå†ä¸€æ¬¡ï¼ˆè‡ªè¡Œæ‰‹ç©å³å¯å¾—çŸ¥ï¼Œè¯ä¹Ÿä¸éš¾ï¼‰ï¼›ç¬¬äºŒï¼Œç¯é•¿ä¸€å®šæ˜¯ step çš„å› æ•°ï¼Œè¿™ä¸ªä¹Ÿä¸éš¾ç†è§£ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆæ¯”ç¬¬ä¸€ä¸ªæŒ‡é’ˆå¤šèµ°äº†è‹¥å¹²ç¯é•¿ã€‚ç¬¬ä¸‰ï¼Œç”±ä¸Šé¢çš„ç»“è®ºæˆ‘ä»¬è¿˜å¯ä»¥çŸ¥é“ï¼Œ step åŠ ä¸Šç¯é•¿ä¸€å®šå¤§äºç­‰äºåŸºç¯æ ‘çš„ç‚¹æ•°ã€‚

æœ‰äº†è¿™å‡ ä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥æšä¸¾ç¯é•¿ c ï¼Œå–ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œç¬¬ä¸€ä¸ªæ˜¯åˆå§‹å­—ç¬¦ä¸²ï¼Œç¬¬äºŒä¸ªæ˜¯åˆå§‹å­—ç¬¦ä¸²è¿­ä»£ c è½®åçš„ç»“æœï¼Œç„¶åè®©è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²åŒæ—¶å¼€å§‹è¿­ä»£ã€‚ç”±å‰æ–‡æ‰€è¿°ï¼Œè‹¥ç¯é•¿çœŸçš„ä¸º c ï¼Œé‚£ä¹ˆåœ¨ä¸è¶…è¿‡ step+c è½®å†…å¿…ç„¶ä¼šå‡ºç°ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ H å€¼ä¸€æ ·ï¼Œé‚£ä¹Ÿå°±æ‰¾åˆ°äº†ä¸€ç»„è§£ã€‚

æ­¤æ—¶ç©ºé—´å¤æ‚åº¦å·²ç»è¾¾åˆ°äº† $O(1)$ ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ $O(step\sqrt {step}) $

æ¥ä¸‹æ¥å¼€å§‹ä¼˜åŒ–æ—¶é—´ï¼š

1.  å®¹æ˜“å‘ç°è¿™ä¸ªåšæ³•æåº¦ä¾èµ–äºåˆå§‹å€¼ï¼Œç»è¿‡æµ‹è¯•ï¼Œ $n=9$ æ—¶éšæœºå‡ºæ¥çš„åˆå€¼å­—ç¬¦ä¸²çš„ step å°åˆ™ 3 ä¸‡ï¼Œå¤§åˆ™ 50 å¤šä¸‡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¤šéšæœºå‡ ä¸ªåˆå€¼ï¼Œè‹¥ step è¿‡å¤§åˆ™ passï¼ˆå¯ä»¥ç›´æ¥åœ¨å¾ªç¯é‡Œåˆ¤æ‰ï¼Œæˆ‘çš„é˜ˆå€¼æ˜¯å– 20 ä¸‡ï¼‰ï¼Œå–ä¸€ä¸ªè¾ƒå°çš„ä½œä¸ºæˆ‘ä»¬çš„å‡ºå‘ç‚¹
2.  ç»è¿‡æ‰‹æµ‹éšæœºæ•°æ®å‘ç°ï¼Œç¯æ™®ééƒ½æ¯”è¾ƒå¤§ï¼Œæ‰€ä»¥æšä¸¾å› å­çš„æ—¶å€™å¯ä»¥ä»å¤§åˆ°å°æšä¸¾ï¼Œå‘ç°ä¸€ä¸ªè§£å°±é€€å‡ºï¼Œè¿™ä¸ªä¼˜åŒ–å¾ˆæ˜æ˜¾
3.  å®¹æ˜“å‘ç° H(x) æœ‰å¤§é‡çš„å†—ä½™æ“ä½œï¼šç¬¬ä¸€æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥çš„å‰åŠéƒ¨åˆ†ä¸€ç›´ä¸å˜ï¼Œæ‰€ä»¥å¹²è„†ç›´æ¥æŠŠå­—ç¬¦ä¸²å†™è¿›é™æ€ç¼“å†²åŒºï¼Œåªæ‹·è´ç¬¬äºŒä¸ªå­—ç¬¦ä¸²è¿›å»ï¼›ç¬¬äºŒæ˜¯å®ƒä¼šå®Œæ•´åœ°æŠŠ SHA256 çš„å­—ç¬¦ä¸²è¡¨ç¤ºå†™å‡ºæ¥ï¼Œä½†æˆ‘ä»¬åªéœ€è¦å‰ n ä½å³å¯ï¼Œæ‰€ä»¥å½“ç”Ÿæˆçš„å­—ç¬¦ä¸²çš„é•¿åº¦è¾¾åˆ° n åå°±ç›´æ¥è·³å‡º

ç»è¿‡ä¸Šè¿°ä¼˜åŒ–ï¼Œ $n\le 8$ è·‘çš„é£å¿«ï¼Œ$n=9$ æœ¬åœ°ä¹ŸåŸºæœ¬ä¸Šèƒ½åœ¨ 2 ç§’å†…è·‘å‡ºã€‚

ä¸€ä¸ªå¾ˆæç«¯çš„æƒ…å†µæ˜¯ï¼šè¿™ä¸ªåŸºç¯æ ‘æ²¡æœ‰é“¾ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªå¾ªç¯å†…æ²¡æœ‰ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ H ä¸€è‡´ï¼Œé‚£ä¹ˆç†è®ºä¸Šå°±éœ€è¦é‡æ–°æ¥è¿‡ã€‚ä½†æ˜¯ç¯è¶Šå¤§ï¼Œè¿™ä¸ªæƒ…å†µå‡ºç°æ¦‚ç‡å°±è¶Šä½ï¼Œæ‰€ä»¥æˆ‘èµŒå®ƒæ²¡æœ‰è¿™ç§æƒ…å†µå‡ºç°ï¼Œäº¤ä¸Šå»å°±æ‹¿ä¸‹ 500 åˆ†æ»¡åˆ†ã€‚

å¦ä¸€ä¸ªæœ´ç´ æ–¹æ¡ˆï¼š

```java
// æœ´ç´ çš„dfsï¼Œä¼šçˆ†å†…å­˜
static char[] chars = new char[] {
    '0','1','2','3','4','5','6','7','8','9',
    'a','b','c','d','e','f'
};
static Map<String, String> map = new HashMap<>();

static void findCollisions(String parent, int currentLen, int targetLen) {
    if(currentLen == targetLen){
        String hash = H(parent); // éœ€è¦å®ç°å“ˆå¸Œå‡½æ•°
        if(map.containsKey(hash)) {
            System.out.println(parent + " " + map.get(hash));
            return;
        }
        map.put(hash, parent);
        return;
    }

    for(char c : chars) {
        findCollisions(parent + c, currentLen + 1, targetLen);
    }
}
```

å¦ä¸€ä¸ªæ–¹æ¡ˆï¼š

æ ¹æ®å†…å­˜é™åˆ¶ï¼Œå‘ç°æœ€å¤šèƒ½å¼€åä¸‡å·¦å³çš„æ•°ç»„ï¼Œäºæ˜¯æƒ³ç€æŠŠ H å‡ºæ¥çš„å­—ç¬¦ä¸²å†å“ˆå¸Œï¼ˆå°±æ˜¯åŸºç¡€çš„å“ˆå¸Œå˜æˆä¸€ä¸ªæ•°å­—ï¼‰ç„¶åæŠŠæ•°å­—å–æ¨¡ä½œä¸ºç´¢å¼•å°†å½“å‰æšä¸¾çš„å­—ç¬¦ä¸²æ”¾åœ¨è¿™ä¸ªæ¨¡æ•°å¤§å°çš„æ•°ç»„é‡Œï¼ˆåä¸‡å·¦å³ï¼‰ï¼Œå¦‚æœæ­¤æ—¶æ•°ç»„é‡Œæœ‰å­—ç¬¦ä¸²å°±å¯ä»¥æ‹å‡ºæ¥åˆ¤æ–­ä¸€ä¸‹ H æ˜¯å¦ç›¸ç­‰

### [Bob çš„æ—…è¡Œ/[ROI 2017] å‰å¾€å¤§éƒ½ä¼š](https://snail.cronlygames.cn/problem/P2047)

é¢˜ç›®æè¿°

ROI å›½æœ‰ n ä¸ªåŸå¸‚ï¼Œä»¥åŠ m æ¡é“è·¯ï¼Œæ¯æ¡é“è·¯éƒ½æ˜¯**å•å‘**è¿è¡Œçš„ï¼Œç¬¬ i æ¡é“è·¯ä¾æ¬¡ç»è¿‡ $v_{i,1},v_{i,2},â€¦,v_{i,l_i+1}$ å·åŸå¸‚å¹¶åœé ï¼Œå…¶ä¸­ $v_{i,j}\to v_{i,j+1}$ çš„é“è·¯é•¿åº¦æ˜¯ $t_{i,j}$ã€‚

å¦‚æœå¤šæ¡é“è·¯ç»è¿‡ u å·åŸå¸‚ï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨ u å·åŸå¸‚æ¢ä¹˜å…¶ä»–é“è·¯ã€‚ï¼ˆæ¯æ¡é“è·¯éƒ½å¯ä»¥åœ¨åœé ç‚¹ä»»æ„ä¸Šè½¦/ä¸‹è½¦ï¼‰

ä½ éœ€è¦æ‰¾åˆ°ä¸€æ¡ä» 1 å·åŸå¸‚åˆ° n å·åŸå¸‚çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„éœ€è¦æ»¡è¶³å…¶æ€»é•¿åº¦æœ€å°ï¼Œå¹¶ä¸”åœ¨æ­¤æ¡ä»¶ä¸Šè·¯å¾„ä¸Šç›¸é‚»ä¸¤ä¸ª**æ¢ä¹˜ç‚¹**é—´**ç«è½¦ä¸Š**è·ç¦»çš„å¹³æ–¹å’Œæœ€å¤§ã€‚

æ³¨ï¼šèµ·ç‚¹å’Œç»ˆç‚¹éƒ½æ˜¯æ¢ä¹˜ç‚¹ï¼Œé¢˜ç›®ä¿è¯æœ‰è§£ã€‚

è¾“å…¥æè¿°

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° n,m è¡¨ç¤ºæœ‰ n ä¸ªåŸå¸‚ï¼Œm æ¡é“è·¯ã€‚

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œå…ˆæ˜¯ä¸€ä¸ªæ•´æ•° $l_i$ è¡¨ç¤ºé“è·¯é•¿åº¦ï¼Œæ¥ä¸‹æ¥ $2l_i+1$ ä¸ªæ•´æ•°å½¢å¦‚ $v_{i,1},t_{i,1},v_{i,2},â€¦,v_{i,l_i},t_{i,l_i},v_{i,l_i+1}$ï¼Œå«ä¹‰å¦‚é¢˜æ‰€ç¤ºã€‚

è¾“å‡ºæè¿°

ä¸€è¡Œä¸¤ä¸ªæ•´æ•°ï¼Œç¬¬ä¸€ä¸ªæ•°è¡¨ç¤ºæœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œç¬¬äºŒä¸ªæ•°è¡¨ç¤ºå¹³æ–¹å’Œæœ€å¤§å€¼ã€‚

é¢˜è§£ï¼š

**æœ€çŸ­è·¯å›¾**

é¦–å…ˆ `dijkstra`ï¼Œå»ºå‡ºæœ€çŸ­è·¯å›¾ï¼Œæ•°ç»„ä¸º `d`ï¼Œè¾¹ (u,v,w) åœ¨æœ€çŸ­è·¯å›¾ä¸Šå½“ä¸”ä»…å½“ $d_u+w=d_v$ã€‚

**åˆ†æˆè‹¥å¹²è¿ç»­é“è·¯æ‰¹æ¬¡**

è€ƒè™‘é‡æ„ï¼Œä¸€æ¡é“è·¯åœ¨æœ€çŸ­è·¯å›¾ä¸Šçš„ã€Œæ®µã€ä¸€å®šæ˜¯èƒ½å½¢æˆè‹¥å¹²è¿ç»­æ®µï¼Œè€ƒè™‘æŠŠè¿™äº›è¿ç»­æ®µé‡æ–°æ„æˆè‹¥å¹²æ¡æ–°çš„é“è·¯ï¼Œå¿½ç•¥åŸæ¥å®Œæ•´çš„é“è·¯ã€‚ä¸‹é¢é“è·¯æŒ‡çš„æ˜¯æ–°é“è·¯ã€‚

è€ƒè™‘ dpï¼Œä»¤ $f_i$ è¡¨ç¤ºåˆ° i ç‚¹çš„å¹³æ–¹å’Œ maxï¼Œåˆ™è‹¥ i,j åœ¨åŒä¸€æ¡é“è·¯ä¸Šï¼Œåˆ™ $f_i \gets f_j+(d_jâˆ’d_i)^2$ï¼Œå¹³æ–¹è€ƒè™‘æ–œç‡ä¼˜åŒ–ã€‚

è‹¥ A å¤„è½¬ç§»ä¼˜äº Bï¼Œå³$f_A+d_A^2+d_i^2âˆ’2d_Ad_iâˆ’f_Bâˆ’d_B^2âˆ’d_i^2+2d_Bd_i\ge 0$ã€‚

äºæ˜¯ $\frac{(f_A+d_A^2)âˆ’(f_B+d_B^2)}{d_Aâˆ’d_B}\ge 2d_i$ã€‚æœ´ç´ [æ–œç‡ä¼˜åŒ–](https://oi-wiki.org/dp/opt/slope/)ï¼Œå¯¹æ¯æ¡é“è·¯å¼€å•è°ƒæ ˆã€‚

ç”±äºè¿™æ ·è¦æ±‚ $d_i$ å•è°ƒé€’å¢ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥æŠŠç‚¹æŒ‰ d æ’åºï¼Œæšä¸¾æ—¶æŒ‰æ’åºåçš„é¡ºåºæšä¸¾å³å¯ã€‚

å¯¹æ¯æ¡é“è·¯å¼€å•è°ƒæ ˆå³å¯ã€‚å•è°ƒæ ˆç”¨ vector å®ç°å³å¯ã€‚

ä¸‹é¢è¯´ä¸‹ $O(n)$ åšæ³•ï¼Œè€ƒè™‘[å››è¾¹å½¢ä¸ç­‰å¼](https://oi-wiki.org/dp/opt/quadrangle/)(äº¤å‰å°äºåŒ…å«)/å†³ç­–å•è°ƒæ€§ç›¸å…³ã€‚

$w(i,j)=(d_iâˆ’d_j)^2ï¼Œw(i,j)+w(i+1,j+1)âˆ’w(i+1,j)âˆ’w(i,j+1)=âˆ’2(d_{i+1}âˆ’di)(d_{j+1}âˆ’dj)\le 0$ï¼Œè¿™æ˜¯ç”±äºæŒ‰æšä¸¾é¡ºåº d å•è°ƒä¸å‡ã€‚

è§£ç­”ï¼š

```cpp
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <unordered_map>
#include <set>
#include <map>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <queue>

using std::cin;
using std::cout;
using std::vector;

typedef long long lld;

const int kSiz = 1e6 + 10;

struct Node {
    int x, y, w;
};

int N, M, idx;
int hd[kSiz], ne[kSiz], to[kSiz], wt[kSiz]; // é‚»æ¥è¡¨ï¼Œneæ—¢åŒ…å«é“¾è¡¨å¤´ï¼Œä¹ŸåŒ…å«æ•´ä¸ªé“¾è¡¨

// æœ€çŸ­è·¯
bool vis[kSiz];
int dis[kSiz];

// æ±‚ f å€¼
int id[kSiz];
lld f[kSiz];

int cnt;
vector<Node> tr[kSiz], sg[kSiz]; // åŸå§‹é“è·¯, è¿ç»­èµ·ä½œç”¨çš„é“è·¯
vector<int> pt[kSiz];   // æ¯ç«™ç‚¹æ‰€åœ¨çš„è¿ç»­é“è·¯æ‰¹æ¬¡
vector<int> que[kSiz];  // æ¯æ®µ/æ¯è¿ç»­é“è·¯ æ‰€æœ‰èŠ‚ç‚¹çš„å•è°ƒæ ˆ

void add(int a, int b, int w) {
    ne[++idx] = hd[a];
    hd[a] = idx;
    to[idx] = b;
    wt[idx] = w;
}

void read() {
    cin >> N >> M;
    int p;
    Node o;
    for (int i = 1; i <= M; i++) {
        cin >> p >> o.x;
        for (int j = 1; j <= p; j++) {
            cin >> o.w >> o.y;
            add(o.x, o.y, o.w); // åŸå§‹è¾¹
            tr[i].push_back(o); // åŸå§‹é“è·¯
            o.x = o.y;
        }
    }
}

// æœ€çŸ­è·¯
void dijkstra() {
    memset(dis, 0x3f, sizeof dis); //åˆå§‹åŒ–ä¸€ä¸ªå¤§æ•°
    dis[1] = 0;
    std::priority_queue<std::pair<int, int> > pq;
    pq.push({ -0, 1 });
    while (!pq.empty()) {
        int x = pq.top().second;
        pq.pop();
        if (vis[x]) {
            continue;
        }
        vis[x] = true;
        for (int i = hd[x]; i; i = ne[i]) {
            int y = to[i];
            if (dis[y] > dis[x] + wt[i]) {
                dis[y] = dis[x] + wt[i];
                if (!vis[y]) {
                    pq.push({ -dis[y], y });
                }
            }
        }
    }
}

bool match(Node& o) {
    return dis[o.x] + o.w == dis[o.y];
}

// æŠŠåŸå§‹é“è·¯åˆ†æˆ è¿ç»­çš„é“è·¯æ‰¹æ¬¡
void split() {
    cnt = 1;
    for (int i = 1; i <= M; i++) {
        for (int j = 0; j < tr[i].size();) {
            bool flag = false;
            for (; j < tr[i].size() && match(tr[i][j]); j++) {
                flag = true;
                sg[cnt].push_back(tr[i][j]);
            }
            if (flag) {
                ++cnt;
            }

            for (; j < tr[i].size() && !match(tr[i][j]); j++) {
            }
        }
    }

    cnt--;
    for (int i = 1; i <= cnt; i++) {
        if (sg[i].size()) {
            pt[sg[i][0].x].push_back(i);
            pt[sg[i][0].y].push_back(i);
            for (int j = 1; j < sg[i].size(); j++) {
                pt[sg[i][j].y].push_back(i);
            }
        }
    }
}

bool cmp(int a, int b) {
    return dis[a] < dis[b];
}

lld p2(int d) {
    return 1ll * d * d;
}

// æ±‚ [a, b] æ–œç‡
double slope(int a, int b) {
    double y = f[b] + p2(dis[b]) - f[a] - p2(dis[a]);
    return y / (dis[b] - dis[a]);
}

void solve() {
    for (int i = 1; i <= N; i++) {
        id[i] = i;
    }
    std::sort(id + 1, id + 1 + N, cmp);

    int sz;
    for (int i = 1; i <= N; i++) {
        int x = id[i];
        if (dis[x] > dis[N]) { // æ— ç”¨èŠ‚ç‚¹
            continue;
        }
        for (int t : pt[x]){
            while ((sz = que[t].size()) > 1){
                if (slope(que[t][sz - 2], que[t].back()) < 2 * dis[x]) { // æ‰¾åˆ°äº†æ›´ä¼˜çš„èŠ‚ç‚¹
                    // åˆ é™¤æ–œç‡ä¸è¾¾æ ‡èŠ‚ç‚¹
                    que[t].pop_back();
                }
                else {
                    break;
                }
            }
            if (que[t].size()) {
                // æ›´æ–°få€¼
                int y = que[t].back();
                f[x] = std::max(f[x], f[y] + p2(dis[x] - dis[y]));
            }
        }

        for (int t : pt[x]) {
            while ((sz = que[t].size()) > 1) {
                if (slope(que[t][sz - 2], que[t].back()) < slope(que[t].back(), x)) { // ä¿è¯æ–œç‡é€’å‡
                    // åˆ é™¤å°¾éƒ¨èŠ‚ç‚¹
                    que[t].pop_back();
                }
                else {
                    break;
                }
            }
            // åŠ å…¥æ–°èŠ‚ç‚¹
            que[t].push_back(x);
        }
    }
}

void work() {
    dijkstra();
    split();
    solve();
    cout << dis[N] << " " << f[N] << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    read();
    work();

    return 0;
}

```

## æ´—ç‰Œç®—æ³•

[384. æ‰“ä¹±æ•°ç»„](https://leetcode.cn/problems/shuffle-an-array/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œè®¾è®¡ç®—æ³•æ¥æ‰“ä¹±ä¸€ä¸ªæ²¡æœ‰é‡å¤å…ƒç´ çš„æ•°ç»„ã€‚æ‰“ä¹±åï¼Œæ•°ç»„çš„æ‰€æœ‰æ’åˆ—åº”è¯¥æ˜¯ **ç­‰å¯èƒ½** çš„ã€‚

å®ç° `Solution` class:

- `Solution(int[] nums)` ä½¿ç”¨æ•´æ•°æ•°ç»„ `nums` åˆå§‹åŒ–å¯¹è±¡
- `int[] reset()` é‡è®¾æ•°ç»„åˆ°å®ƒçš„åˆå§‹çŠ¶æ€å¹¶è¿”å›
- `int[] shuffle()` è¿”å›æ•°ç»„éšæœºæ‰“ä¹±åçš„ç»“æœ

è§£ç­”ï¼š

```java
class Solution {
    int[] nums;
    int n = 0;
    Random random = new Random();

    public Solution(int[] nums) {
        n = nums.length;
        this.nums = nums.clone();
    }

    public int[] reset() {
        return nums;
    }

    public int[] shuffle() {
        int[] res = nums.clone();
        for(int i = 0; i < n; i++){
            swap(res, i, i + random.nextInt(n-i));
        }

        return res;
    }

    void swap(int[] nums, int i, int j){
        int temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }
}
```

## æœ€å°è¡¨ç¤ºæ³•

**ç®—æ³•æ ¸å¿ƒ**

è€ƒè™‘å¯¹äºä¸€å¯¹å­—ç¬¦ä¸² $A,B$, å®ƒä»¬åœ¨åŸå­—ç¬¦ä¸² $S$ ä¸­çš„èµ·å§‹ä½ç½®åˆ†åˆ«ä¸º $i,j$, ä¸”å®ƒä»¬çš„å‰ $k$ ä¸ªå­—ç¬¦å‡ç›¸åŒï¼Œå³

$S[i \cdots i+k-1] = S[j \cdots j+k-1]$

ä¸å¦¨å…ˆè€ƒè™‘ $S[i+k]>S[j+k]$ çš„æƒ…å†µï¼Œæˆ‘ä»¬å‘ç°èµ·å§‹ä½ç½®ä¸‹æ ‡ $l$ æ»¡è¶³ $i\le l\le i+k$ çš„å­—ç¬¦ä¸²å‡ä¸èƒ½æˆä¸ºç­”æ¡ˆã€‚å› ä¸ºå¯¹äºä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸² $S_{i+p}$ï¼ˆè¡¨ç¤ºä»¥ $i+p$ ä¸ºèµ·å§‹ä½ç½®çš„å­—ç¬¦ä¸²ï¼Œ$p \in [0, k]$ï¼‰ä¸€å®šå­˜åœ¨å­—ç¬¦ä¸² $S_{j+p}$ æ¯”å®ƒæ›´ä¼˜ã€‚

æ‰€ä»¥æˆ‘ä»¬æ¯”è¾ƒæ—¶å¯ä»¥è·³è¿‡ä¸‹æ ‡ $l\in [i,i+k]$, ç›´æ¥æ¯”è¾ƒ $S_{i+k+1}$

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†å¯¹äºä¸Šæ–‡æš´åŠ›çš„ä¼˜åŒ–ã€‚

**æ—¶é—´å¤æ‚åº¦**

$O(n)$

### [899. æœ‰åºé˜Ÿåˆ—](https://leetcode.cn/problems/orderly-queue/)

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s` å’Œä¸€ä¸ªæ•´æ•° `k` ã€‚ä½ å¯ä»¥ä» `s` çš„å‰ `k` ä¸ªå­—æ¯ä¸­é€‰æ‹©ä¸€ä¸ªï¼Œå¹¶æŠŠå®ƒåŠ åˆ°å­—ç¬¦ä¸²çš„æœ«å°¾ã€‚

è¿”å› åœ¨åº”ç”¨ä¸Šè¿°æ­¥éª¤çš„ä»»æ„æ•°é‡çš„ç§»åŠ¨åï¼Œå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸² ã€‚

```java
class Solution {
    public String orderlyQueue(String s, int k) {
        char[] ss = s.toCharArray();
        if(k > 1) {
            Arrays.sort(ss);
            return new String(ss);
        } else{
            int i = 0, j = 1, n = ss.length;
            k = 0;
            while(i < n && j < n && k < n){
                char c1 = ss[(i+k)%n], c2 = ss[(j+k)%n];
                if(c1 == c2) k++;
                else{
                    if(c1 < c2) j += k+1;
                    else i += k+1;

                    if(i == j) j++;
                    k = 0;
                }

            }
            i = Math.min(i, j);
            return s.substring(i) + s.substring(0, i);
        }
    }
}
```

## æ¨¡æ‹Ÿ

### [166. åˆ†æ•°åˆ°å°æ•°](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

ç»™å®šä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºåˆ†æ•°çš„åˆ†å­ `numerator` å’Œåˆ†æ¯ `denominator`ï¼Œä»¥ **å­—ç¬¦ä¸²å½¢å¼è¿”å›å°æ•°** ã€‚

å¦‚æœå°æ•°éƒ¨åˆ†ä¸ºå¾ªç¯å°æ•°ï¼Œåˆ™å°†å¾ªç¯çš„éƒ¨åˆ†æ‹¬åœ¨æ‹¬å·å†…ã€‚

å¦‚æœå­˜åœ¨å¤šä¸ªç­”æ¡ˆï¼Œåªéœ€è¿”å› **ä»»æ„ä¸€ä¸ª** ã€‚

å¯¹äºæ‰€æœ‰ç»™å®šçš„è¾“å…¥ï¼Œ**ä¿è¯** ç­”æ¡ˆå­—ç¬¦ä¸²çš„é•¿åº¦å°äº `104` ã€‚

è§£ç­”ï¼š

```java
class Solution {

    public Map<Long, Integer> map = new HashMap<>();
    public String fractionToDecimal(int numerator, int denominator) {
        if(numerator == 0) return "0";
        StringBuilder res = new StringBuilder();
        if((numerator < 0) ^ (denominator < 0)) res.append("-");
        //å¦‚æœå…ˆå–ç»å¯¹å€¼ï¼Œ-2147483648ä¼šå˜æˆ2147483648ï¼Œä¼šå¯¼è‡´æº¢å‡ºï¼Œæ­¤å¤–è¦è½¬ä¸ºlongç±»å‹ï¼Œé¿å…intç±»å‹æº¢å‡º
        Long num = Math.abs((long)numerator);
        Long den = Math.abs((long)denominator);

        res.append(num / den);
        num %= den;

        if(num == 0){
            return res.toString();
        }

        res.append(".");
        String temp = backtracking(num * 10, den, new StringBuilder());

        res.append(temp);
        return res.toString();

    }

    public String backtracking(long numerator, long denominator, StringBuilder sb){
        if(numerator == 0) return sb.toString();

        if(map.containsKey(numerator)){
            sb.insert(map.get(numerator), "(");
            sb.append(")");
            return sb.toString();
        }
        map.put(numerator, sb.length());

        if(numerator < denominator){
            sb.append("0");
            return backtracking(numerator * 10, denominator, sb);
        }
        long quotient = numerator / denominator;
        long remainder = numerator % denominator;

        sb.append(quotient);

        return backtracking(remainder * 10, denominator, sb);
    }
}
```

## æ‰“è¡¨

### [2698. æ±‚ä¸€ä¸ªæ•´æ•°çš„æƒ©ç½šæ•°](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/)

ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° `n` ï¼Œè¯·ä½ è¿”å› `n` çš„ **æƒ©ç½šæ•°** ã€‚

`n` çš„ **æƒ©ç½šæ•°** å®šä¹‰ä¸ºæ‰€æœ‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ `i` çš„æ•°çš„å¹³æ–¹å’Œï¼š

- `1 <= i <= n`
- `i * i` çš„åè¿›åˆ¶è¡¨ç¤ºçš„å­—ç¬¦ä¸²å¯ä»¥åˆ†å‰²æˆè‹¥å¹²è¿ç»­å­å­—ç¬¦ä¸²ï¼Œä¸”è¿™äº›å­å­—ç¬¦ä¸²å¯¹åº”çš„æ•´æ•°å€¼ä¹‹å’Œç­‰äº `i` ã€‚

è§£ç­”ï¼š

```java
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn^2)
class Solution {
    public int punishmentNumber(int n) {
        int sum = 0;
        for(int i = 1; i <= n; i++){
            if(backtrack(i * i, i)){
                sum += i * i;
                System.out.println(i * i);
            }
        }
        return sum;
    }

    public boolean backtrack(int res, int target){
        if(target == 0 && res == 0){
            return true;
        } else if(target < 0 || res == 0){
            return false;
        }

        int cnt = (int)Math.log10(res) + 1;

        for(int i = 1; i <= cnt; i++){
            int digit = (int)Math.pow(10, i);
            if(backtrack(res/digit, target-(res%digit))) return true;
        }

        return false;
    }
}

// é€šè¿‡ã€Œæ‰“è¡¨ã€è¿›è¡Œé¢„å¤„ç†ï¼Œå°†æ¯ä¸ªæ•°çš„ã€Œæƒ©ç½šå€¼ã€é¢„å…ˆè®¡ç®—å¥½ï¼Œå¹¶å­˜å…¥æ•°ç»„memoä¸­ã€‚
class Solution {
    static int[] memo = new int[1001];
    static{
        for(int i = 1; i < memo.length; i++){
            memo[i] = memo[i-1];
            if(backtrack(i * i, i)) memo[i] += i * i;
        }
    }
    public int punishmentNumber(int n) {
        return memo[n];
    }

    public static boolean backtrack(int res, int target){
        if(target == 0 && res == 0){
            return true;
        } else if(target < 0 || res == 0){
            return false;
        }

        int cnt = (int)Math.log10(res) + 1;

        for(int i = 1; i <= cnt; i++){
            int digit = (int)Math.pow(10, i);
            if(backtrack(res/digit, target-(res%digit))) return true;
        }

        return false;
    }
}
```

### çŸ©é˜µå¿«é€Ÿå¹‚

[1137. ç¬¬ N ä¸ªæ³°æ³¢é‚£å¥‘æ•°](https://leetcode.cn/problems/n-th-tribonacci-number/)

æ³°æ³¢é‚£å¥‘åºåˆ— Tn å®šä¹‰å¦‚ä¸‹ï¼š

T0 = 0, T1 = 1, T2 = 1, ä¸”åœ¨ n >= 0 çš„æ¡ä»¶ä¸‹ Tn+3 = Tn + Tn+1 + Tn+2

ç»™ä½ æ•´æ•° `n`ï¼Œè¯·è¿”å›ç¬¬ n ä¸ªæ³°æ³¢é‚£å¥‘æ•° Tn çš„å€¼ã€‚

è§£ç­”ï¼š

```java
class Solution {
    int N = 3;
    int[][] mul(int[][] a, int[][] b){
        int[][] res = new int[N][N];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                res[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j];
            }
        }
        return res;
    }
    public int tribonacci(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        if(n == 2) return 1;
        int[][] a = {
            {1,1,1},
            {1,0,0},
            {0,1,0}
        };

        int[][] b = {
            {1,0,0},
            {0,1,0},
            {0,0,1}
        };

        for(int i = 0; i < n-2; i++){
            b = mul(a, b);
        }
        return (b[0][0] + b[0][1])%(Integer.MAX_VALUE);
    }
}
```

## äºŒç»´å‡¸åŒ…ï¼ˆAndrew ç®—æ³•ï¼‰

> æ˜¯ç½‘ä¸Šå¤§å¤šæ•° Andrew ç®—æ³•çš„æ¿å­éƒ½æ˜¯æœ‰é—®é¢˜çš„ã€‚

Andrew ç®—æ³•æ­£æ˜¯ç”¨äºæ±‚è§£å‡¸åŒ…ä¸Šçš„æ‰€æœ‰ç‚¹ï¼ˆå›´æˆæ‰€æœ‰ç‚¹çš„æœ€å°å‘¨é•¿ï¼‰ï¼Œå…¶ç®—æ³•é€»è¾‘å°†å‡¸åŒ…åˆ†ä¸ºã€Œä¸Šå‡¸å£³ã€å’Œã€Œä¸‹å‡¸å£³ã€ï¼Œå¹¶åˆ†åˆ«ç”»å‡ºï¼ˆè“è‰²åˆ†å‰²çº¿å°†å‡¸åŒ…åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼‰ï¼š

![](./images/1650675817-tJTwGT-image.png)

åŸºæœ¬æµç¨‹ä¸ºï¼š

1. å¯¹æ‰€æœ‰ç‚¹è¿›è¡ŒåŒå…³é”®å­—æ’åºï¼Œå…ˆæ ¹æ® x åæ ‡æ’å‡åºï¼Œåæ ¹æ® y æ’å‡åºï¼›
   æ ¹æ® x æ’å‡åºçš„ç›®çš„ï¼Œæ˜¯ä¸ºäº†æˆ‘ä»¬èƒ½å¤Ÿå¾€ä¸€ä¸ªæ–¹å‘ç”»å‡ºå‡¸åŒ…è¾¹ç¼˜ï¼ˆä»å·¦å¾€åç”»å‡ºä¸€åŠå‡¸å£³ï¼Œä»å³å¾€å·¦ç”»å‡ºå¦å¤–ä¸€åŠï¼‰ï¼Œè€Œå°† y å‡åºç›®çš„æ˜¯å¯ä»¥ç¡®ä¿ä¸€æ—¦æˆ‘ä»¬ç°åœ¨ä» a åˆ° b è¿›è¡Œè¿çº¿ï¼Œé‚£ä¹ˆ a åˆ° b ä¹‹é—´çš„æ‰€æœ‰ç‚¹èƒ½å¤Ÿç¡®ä¿è¢«å›´ä½ï¼›

2. ä½¿ç”¨æ ˆæ¥ç»´æŠ¤æ‰€æœ‰å‡¸åŒ…ä¸Šçš„ç‚¹ï¼Œæˆ–è€…è¯´å‡¸åŒ…ä¸Šçš„è¾¹ï¼Œä¼šæ›´ä¸ºå‡†ç¡®ï¼Œå‡¸åŒ…èµ·ç‚¹å…ƒç´ ä¼šåœ¨æ ˆä¸­å‡ºç°ä¸¤æ¬¡ï¼ˆé¦–å°¾ï¼‰ï¼Œå› æ­¤æ›´ä¸ºå‡†ç¡®çš„æè¿°åº”è¯¥æ˜¯ä½¿ç”¨æ ˆç»´æŠ¤å‡¸åŒ…çš„æ‰€æœ‰çš„è¾¹ï¼Œæ ˆä¸­ç›¸é‚»å…ƒç´ ä»£è¡¨å‡¸åŒ…ä¸Šçš„ä¸€æ¡è¾¹ï¼›

3. åˆ†åˆ«ã€Œä»å‰å¾€åã€å’Œã€Œä»åå¾€å‰ã€å¤„ç†æ’åºå¥½çš„æ‰€æœ‰ç‚¹ï¼Œæ¥åˆ†åˆ«ç”»å‡ºå‡¸åŒ…çš„ä¸¤åŠéƒ¨åˆ†ï¼Œæ ¹æ®ç”»çš„æ˜¯ç¬¬ä¸€éƒ¨åˆ†è¿˜æ˜¯ç¬¬äºŒéƒ¨åˆ†ï¼Œç»´æŠ¤æ ˆå†…å…ƒçš„å¤„ç†é€»è¾‘ç¨æœ‰ä¸åŒï¼š

   - ç”»çš„æ˜¯å‡¸åŒ…çš„ç¬¬ä¸€éƒ¨åˆ†ï¼š

     è‹¥æ ˆå†…å…ƒç´ å°‘äº 2 ä¸ªï¼Œç»„æˆä¸€æ¡çº¿è‡³å°‘éœ€è¦ä¸¤ä¸ªç‚¹ï¼Œè¯´æ˜æ­¤æ—¶ç¬¬ä¸€æ¡è¾¹éƒ½è¿˜æ²¡ç”»å‡ºï¼Œç›´æ¥å°†å…ƒç´ æ·»åŠ åˆ°æ ˆä¸­ï¼›

     è‹¥æ ˆå†…å…ƒç´ ä¸å°‘äº 2 ä¸ªï¼Œè€ƒè™‘æ˜¯å¦è¦å°†æ ˆé¡¶çš„è¾¹åˆ æ‰ï¼ˆç”±æ ˆé¡¶å‰ä¸¤ä¸ªå…ƒç´ ç»„æˆçš„è¾¹ï¼‰å‡è®¾æ ˆé¡¶å…ƒç´ ä¸º bï¼Œæ ˆé¡¶å…ƒç´ çš„ä¸‹ä¸€ä½ä¸º aï¼Œå³æ ˆé¡¶å­˜åœ¨ä¸€æ¡ a åˆ° b çš„è¾¹ï¼Œå½“å‰å¤„ç†åˆ°çš„ç‚¹ä¸º cï¼Œæ­¤æ—¶æˆ‘ä»¬æ ¹æ® ac è¾¹æ˜¯å¦åœ¨ ab è¾¹çš„æ—¶é’ˆæ–¹å‘æ¥å†³å®šæ˜¯å¦è¦å°† ab è¾¹å»æ‰ï¼š

     ![](./images/1650678200-VMOiaM-image.png)

     æŒ‰ç…§ä¸Šè¿°é€»è¾‘å¤„ç†å®Œæ‰€æœ‰ç‚¹ï¼Œå‡¸åŒ…ç¬¬ä¸€éƒ¨åˆ†çš„ç‚¹ï¼ˆè¾¹ï¼‰éƒ½å­˜åœ¨äºæ ˆä¸­ã€‚

   - ç”»çš„æ˜¯å‡¸åŒ…çš„ç¬¬äºŒéƒ¨åˆ†ï¼šé€»è¾‘åŒç†ï¼Œå”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç¬¬ä¸€éƒ¨åˆ†çš„å‡¸åŒ…è¾¹æˆ‘ä»¬ä¸èƒ½åˆ å»ï¼Œå‡å®šå¤„ç†å®Œç¬¬ä¸€éƒ¨åˆ†å‡¸åŒ…ï¼Œæˆ‘ä»¬æ ˆå†…æœ‰ m ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸Šè¿°ã€Œæ ˆé¡¶å…ƒç´ ä¸å°‘äº 2 ä¸ªã€çš„é€»è¾‘æ›¿æ¢ä¸ºã€Œæ ˆé¡¶å…ƒç´ å¤§äº m ä¸ªã€ï¼ŒåŒæ—¶å·²å‚ä¸åˆ°å‡¸åŒ…ç¬¬ä¸€éƒ¨åˆ†çš„ç‚¹ï¼Œä¸èƒ½å†è€ƒè™‘ï¼Œå› æ­¤éœ€è¦é¢å¤–ä½¿ç”¨ä¸€ä¸ª vis æ•°ç»„æ¥è®°å½•ä½¿ç”¨è¿‡çš„ç‚¹ã€‚

ä¸€äº›ç»†èŠ‚ï¼Œä¸ºäº†æ–¹ä¾¿å–å¾—æ ˆé¡¶çš„å‰ä¸¤ä½å…ƒç´ ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•°ç»„å®ç°æ ˆï¼Œstk ä»£è¡¨æ ˆå®¹å™¨ï¼Œtp ä»£è¡¨æ ˆé¡¶å…ƒç´ ä¸‹æ ‡ã€‚

æ­£å¦‚åˆšåˆšè®²åˆ°ï¼Œèµ·ç‚¹ä¼šè¢«å…¥æ ˆä¸¤æ¬¡ï¼ˆå¯¹åº”ç¬¬ä¸€æ¡è¾¹å’Œæœ€åä¸€æ¡è¾¹ï¼‰ï¼Œå› æ­¤è¾“å‡ºæ–¹æ¡ˆæ—¶ï¼Œæ ˆé¡¶å’Œæ ˆåº•æˆ‘ä»¬åªé€‰å…¶ä¸€å³å¯ã€‚

æ¨¡æ¿ï¼š

```java
import java.util.Arrays;

class Solution {
    int[] subtraction(int[] a, int[] b) {
        return new int[] {a[0] - b[0], a[1] - b[1]};
    }
    double cross(int[] a, int[] b) {
        return (a[0] * b[1] - a[1] * b[0]);
    }
    double getArea(int[] a, int[] b, int[] c){
        return cross(subtraction(b, a), subtraction(c, a));
    }
    public int[][] outerTrees(int[][] trees) {
        Arrays.sort(trees, (a, b)->{
            return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];
        });

        int n = trees.length, tp = 0;
        int[] stack = new int[n+10]; // stack to store indices of trees
        boolean[] vis = new boolean[n+10]; // to mark visited trees
        stack[++tp] = 0;

        for(int i = 1; i < n; i++){ // the upper bound
            int[] c = trees[i];
            while(tp >= 2){
                int[] a = trees[stack[tp-1]], b = trees[stack[tp]]; // b is the top of stack
                if(getArea(a, b, c) > 0) vis[stack[tp--]] = false; // remove b from stack
                else break;
            }
            stack[++tp] = i; // add c to stack, and the top index of stack is tp;
            vis[i] = true;

        }
        int first = tp;
        for(int i = n - 1; i >= 0; i--){ // the lower bound
            if(vis[i]) continue;
            int[] c = trees[i];
            while(tp > first){
                int[] a = trees[stack[tp-1]], b = trees[stack[tp]];
                if(getArea(a, b, c) > 0) tp--;
                else break;

            }
            stack[++tp] = i;
        }
        int[][] res = new int[tp-1][2]; // the leftest point has been added to stack in the bottom and the top, so we need tp-1
        for(int i = 1; i < tp; i++){
            res[i-1] = trees[stack[i]];
        }
        return res;
    }
}
```

## [593. æœ‰æ•ˆçš„æ­£æ–¹å½¢](https://leetcode.cn/problems/valid-square/)

ç»™å®š 2D ç©ºé—´ä¸­å››ä¸ªç‚¹çš„åæ ‡ `p1`, `p2`, `p3` å’Œ `p4`ï¼Œå¦‚æœè¿™å››ä¸ªç‚¹æ„æˆä¸€ä¸ªæ­£æ–¹å½¢ï¼Œåˆ™è¿”å› `true` ã€‚

ç‚¹çš„åæ ‡ `pi` è¡¨ç¤ºä¸º `[xi, yi]` ã€‚ `è¾“å…¥æ²¡æœ‰ä»»ä½•é¡ºåº` ã€‚

ä¸€ä¸ª **æœ‰æ•ˆçš„æ­£æ–¹å½¢** æœ‰å››æ¡ç­‰è¾¹å’Œå››ä¸ªç­‰è§’(90 åº¦è§’)ã€‚

è§£ç­”ï¼š

```java
class Solution {
    long len = -1;
    public boolean calc(int[] a, int[] b, int[] c){
        long l1 = (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);
        long l2 = (a[0] - c[0]) * (a[0] - c[0]) + (a[1] - c[1]) * (a[1] - c[1]);
        long l3 = (b[0] - c[0]) * (b[0] - c[0]) + (b[1] - c[1]) * (b[1] - c[1]);
        boolean flag = (l1 == l2 + l3) || (l2 == l3 + l1) || (l3 == l1 + l2);
        if(!flag) return false;
        if(len == -1) len = Math.min(l1, l2);
        else if(len == 0 || len != Math.min(l1, l2)) return false; // é•¿åº¦ä¸èƒ½ä¸º0ï¼Œä¸”å¿…é¡»æ˜¯æœ€å°çš„é‚£ä¸ª
        return true;
    }

    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        return calc(p1, p2, p3) && calc(p1, p3, p4) && calc(p1, p4, p2) && calc(p2, p4, p3); // é¡ºåºä¸èƒ½é”™ï¼Œå‰ä¸‰ä¸ªæ˜¯å¯¹æ¯”ä»p1å‡ºå‘çš„ä¸‰ä¸ªè¾¹ï¼Œè¿™æ ·å¯ä»¥å¯¹æ¯”å‡ºæ˜¯ä¸æ˜¯é‚»è¾¹ç›¸ç­‰
    }
}
```

## [C. Maximum Subarray Sum](https://codeforces.com/contest/2107/problem/C)

è§£ç­”ï¼š

```java
import java.util.Scanner;
import java.util.*;

public class Main {
    static class Solution {
        int n, edge1 = 0, edge2 = 0;
        long k;
        long[] a;
        List<Integer> default_index = new ArrayList<>();
        long[] prefix_sum;

        void readInput(Scanner in) {
            n = in.nextInt();
            k = in.nextLong();
            in.nextLine();
            String s = in.nextLine();
            char[] c = s.toCharArray();
            for (int i = 0; i < c.length; i++) {
                if (c[i] == '0') default_index.add(i);
            }
            edge2 = default_index.size() > 1 ? default_index.get(1)-1 : n-1;
            String s1 = in.nextLine();
            String[] arr = s1.split(" ");
            a = new long[n];
            for (int i = 0; i < n; i++) {
                a[i] = Long.parseLong(arr[i]);
                if(c[i] == '0') a[i] = Integer.MIN_VALUE; // split the array with MIN_VALUE
            }
            prefix_sum = new long[n];
            prefix_sum[0] = a[0];
            for (int i = 1; i < n; i++) {
                prefix_sum[i] = prefix_sum[i-1] + a[i];
            }
        }

        long maxSum(long[] a) { // the max sum of subarray of a
            long sum = a[0];
            long[] dp = new long[n];
            dp[0] = a[0];
            int temp = 0;
            for (int i = 1; i < n; i++) {
                if (dp[i-1] < 0) {
                    temp = i;
                }
                dp[i] = Math.max(dp[i-1], 0) + a[i];
                if (dp[i] > sum) {
                    sum = dp[i];
                }
            }
            return sum;
        }
        long preSum(long[] a, int index) { // the sum of between the maxsum before index and the maxsum after index
            long sum = 0;
            long curr = 0;
            long R = 0;
            for (int i = index+1; i < a.length; i++) {
                curr += a[i];
                sum = Math.max(sum, curr);
            }
            R = sum;
            curr = 0;
            sum = 0;
            for (int i = index-1; i >= 0; i--) {
                curr += a[i];
                sum = Math.max(sum, curr);
            }
            return R + sum;
        }
        void printResult() {
            System.out.println("Yes");
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < n - 1; i++) {
                sb.append(a[i]);
                sb.append(" ");
            }
            sb.append(a[n - 1]);
            System.out.println(sb.toString());
        }

        void solve() {
            long max_sum = maxSum(a);
            if (default_index.size() == 0) {
                if (max_sum == k) {
                    printResult();
                    return;
                } else {
                    System.out.println("No");
                    return;
                }
            } else{
                int index = default_index.get(0);

                if(max_sum > k){
                    System.out.println("No");
                    return;
                }else{
                    a[index] = k - preSum(a, index);
                    printResult();
                    return;
                }
            }

        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int t = in.nextInt();
        for (int i = 0; i < t; i++) {
            Solution solution = new Solution();
            solution.readInput(in);
            solution.solve();
        }
        in.close();
    }
}
```

## å¤šè·¯å½’å¹¶

### [264. ä¸‘æ•° II](https://leetcode.cn/problems/ugly-number-ii/)

ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ç¬¬ `n` ä¸ª **ä¸‘æ•°** ã€‚

**ä¸‘æ•°** å°±æ˜¯è´¨å› å­åªåŒ…å« `2`ã€`3` å’Œ `5` çš„æ­£æ•´æ•°ã€‚

**ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°æ ¹å †ï¼‰**

æœ‰äº†åŸºæœ¬çš„åˆ†ææ€è·¯ï¼Œä¸€ä¸ªç®€å•çš„è§£æ³•æ˜¯ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼š

    èµ·å§‹å…ˆå°†æœ€å°ä¸‘æ•° 1 æ”¾å…¥é˜Ÿåˆ—
    æ¯æ¬¡ä»é˜Ÿåˆ—å–å‡ºæœ€å°å€¼ xï¼Œç„¶åå°† x æ‰€å¯¹åº”çš„ä¸‘æ•° 2xã€3x å’Œ 5x è¿›è¡Œå…¥é˜Ÿã€‚
    å¯¹æ­¥éª¤ 2 å¾ªç¯å¤šæ¬¡ï¼Œç¬¬ n æ¬¡å‡ºé˜Ÿçš„å€¼å³æ˜¯ç­”æ¡ˆã€‚

ä¸ºäº†é˜²æ­¢åŒä¸€ä¸‘æ•°å¤šæ¬¡è¿›é˜Ÿï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ•°æ®ç»“æ„ Set æ¥è®°å½•å…¥è¿‡é˜Ÿåˆ—çš„ä¸‘æ•°ã€‚

è§£ç­”

```java
class Solution {
    public int nthUglyNumber(int n) {
		int[] a = new int[]{2,3,5};
		Queue<Long> pq = new PriorityQueue<>();
		Set<Long> set = new HashSet<>();
		pq.add(1L);
		set.add(1L);
		int cnt = 1;
		while(cnt < n){
			long x = pq.poll();
			for(int i = 0; i < 3; i++){
				long temp = a[i] * x;
				if(!set.contains(temp)){
					pq.add(temp);
					set.add(temp);
				}
			}
			cnt++;
		}
		return (int) (long)pq.poll();
	}
}

```



**å¤šè·¯å½’å¹¶**

ä»è§£æ³•ä¸€ä¸­ä¸éš¾å‘ç°ï¼Œæˆ‘ä»¬ã€Œå¾€åäº§ç”Ÿçš„ä¸‘æ•°ã€éƒ½æ˜¯åŸºäºã€Œå·²æœ‰ä¸‘æ•°ã€è€Œæ¥ï¼ˆä½¿ç”¨ã€Œå·²æœ‰ä¸‘æ•°ã€ä¹˜ä¸Šã€Œè´¨å› æ•°ã€2ã€3ã€5ï¼‰ã€‚

å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æ‰€æœ‰ä¸‘æ•°çš„æœ‰åºåºåˆ—ä¸º a1,a2,a3,...,an çš„è¯ï¼Œåºåˆ—ä¸­çš„æ¯ä¸€ä¸ªæ•°éƒ½å¿…ç„¶èƒ½å¤Ÿè¢«ä»¥ä¸‹ä¸‰ä¸ªåºåˆ—ï¼ˆä¸­çš„è‡³å°‘ä¸€ä¸ªï¼‰è¦†ç›–ï¼š

    ç”±ä¸‘æ•° Ã—2 æ‰€å¾—çš„æœ‰åºåºåˆ—ï¼š1Ã—2ã€2Ã—2ã€3Ã—2ã€4Ã—2ã€5Ã—2ã€6Ã—2ã€8Ã—2 ...
    ç”±ä¸‘æ•° Ã—3 æ‰€å¾—çš„æœ‰åºåºåˆ—ï¼š1Ã—3ã€2Ã—3ã€3Ã—3ã€4Ã—3ã€5Ã—3ã€6Ã—3ã€8Ã—3 ...
    ç”±ä¸‘æ•° Ã—5 æ‰€å¾—çš„æœ‰åºåºåˆ—ï¼š1Ã—5ã€2Ã—5ã€3Ã—5ã€4Ã—5ã€5Ã—5ã€6Ã—5ã€8Ã—5 ...

ä¸¾ä¸ªğŸŒ°ï¼Œå‡è®¾æˆ‘ä»¬éœ€è¦æ±‚å¾— [1,2,3,...,10,12] ä¸‘æ•°åºåˆ— arr çš„æœ€åä¸€ä½ï¼Œé‚£ä¹ˆè¯¥åºåˆ—å¯ä»¥çœ‹ä½œä»¥ä¸‹ä¸‰ä¸ªæœ‰åºåºåˆ—å½’å¹¶è€Œæ¥ï¼š

    1Ã—2,2Ã—2,3Ã—2,...,10Ã—2,12Ã—2 ï¼Œå°† 2 æå‡ºï¼Œå³ arrÃ—2
    1Ã—3,2Ã—3,3Ã—3,...,10Ã—3,12Ã—3 ï¼Œå°† 3 æå‡ºï¼Œå³ arrÃ—3
    1Ã—5,2Ã—5,3Ã—5,...,10Ã—5,12Ã—5 ï¼Œå°† 5 æå‡ºï¼Œå³ arrÃ—5

å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªæŒ‡é’ˆæ¥æŒ‡å‘ç›®æ ‡åºåˆ— arr çš„æŸä¸ªä¸‹æ ‡ï¼ˆä¸‹æ ‡ 0 ä½œä¸ºå“¨å…µä¸ä½¿ç”¨ï¼Œèµ·å§‹éƒ½ä¸º 1ï¼‰ï¼Œä½¿ç”¨ arr[ä¸‹æ ‡]Ã—è´¨å› æ•° ä»£è¡¨å½“å‰ä½¿ç”¨åˆ°ä¸‰ä¸ªæœ‰åºåºåˆ—ä¸­çš„å“ªä¸€ä½ï¼ŒåŒæ—¶ä½¿ç”¨ idx è¡¨ç¤ºå½“å‰ç”Ÿæˆåˆ° arr å“ªä¸€ä½ä¸‘æ•°ã€‚

è§£ç­”ï¼š

```java
class Solution {
    public int nthUglyNumber(int n) {
		int[] arr = new int[n+1];
		arr[1] = 1;
		for(int idx = 2, id2 = 1, id3 = 1, id5 = 1; idx <= n; idx++){
			int[] temp = new int[]{arr[id2]*2,arr[id3]*3,arr[id5]*5};	
			int min = Math.min(Math.min(temp[0],temp[1]),temp[2]);
			if(min == temp[0]) id2++;
			if(min == temp[1]) id3++;
			if(min == temp[2]) id5++;
			arr[idx] = min;
		}
		return arr[n];
	}
}
```



### [373. æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

ç»™å®šä¸¤ä¸ªä»¥ **éé€’å‡é¡ºåºæ’åˆ—** çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` , ä»¥åŠä¸€ä¸ªæ•´æ•° `k` ã€‚

å®šä¹‰ä¸€å¯¹å€¼ `(u,v)`ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ æ¥è‡ª `nums1`ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ¥è‡ª `nums2` ã€‚

è¯·æ‰¾åˆ°å’Œæœ€å°çš„ `k` ä¸ªæ•°å¯¹ `(u1,v1)`, ` (u2,v2)`  ...  `(uk,vk)` ã€‚

ä»¤ nums1 çš„é•¿åº¦ä¸º nï¼Œnums2 çš„é•¿åº¦ä¸º mï¼Œæ‰€æœ‰çš„ç‚¹å¯¹æ•°é‡ä¸º nÃ—mã€‚

å…¶ä¸­æ¯ä¸ª nums1[i] å‚ä¸æ‰€ç»„æˆçš„ç‚¹åºåˆ—ä¸ºï¼š
[(nums1[0],nums2[0]),(nums1[0],nums2[1]),...,(nums1[0],nums2[mâˆ’1])]
[(nums1[1],nums2[0]),(nums1[1],nums2[1]),...,(nums1[1],nums2[mâˆ’1])]
[(nums1[nâˆ’1],nums2[0]),(nums1[nâˆ’1],nums2[1]),...,(nums1[nâˆ’1],nums2[mâˆ’1])]

ç”±äº nums1 å’Œ nums2 å‡å·²æŒ‰å‡åºæ’åºï¼Œå› æ­¤æ¯ä¸ª nums1[i] å‚ä¸æ„æˆçš„ç‚¹åºåˆ—ä¹Ÿä¸ºå‡åºæ’åºï¼Œè¿™å¼•å¯¼æˆ‘ä»¬ä½¿ç”¨ã€Œå¤šè·¯å½’å¹¶ã€æ¥è¿›è¡Œæ±‚è§£ã€‚

å…·ä½“çš„ï¼Œèµ·å§‹æˆ‘ä»¬å°†è¿™ n ä¸ªåºåˆ—çš„é¦–ä½å…ƒç´ ï¼ˆç‚¹å¯¹ï¼‰ä»¥äºŒå…ƒç»„ (i,j) æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå°æ ¹å †ï¼‰ï¼Œå…¶ä¸­ i ä¸ºè¯¥ç‚¹å¯¹ä¸­ nums1[i] çš„ä¸‹æ ‡ï¼Œj ä¸ºè¯¥ç‚¹å¯¹ä¸­ nums2[j] çš„ä¸‹æ ‡ï¼Œè¿™æ­¥æ“ä½œçš„å¤æ‚åº¦ä¸º O(nlogn)ã€‚è¿™é‡Œä¹Ÿå¯ä»¥å¾—å‡ºä¸€ä¸ªå°ä¼˜åŒ–æ˜¯ï¼šæˆ‘ä»¬å§‹ç»ˆç¡®ä¿ nums1 ä¸ºä¸¤æ•°ç»„ä¸­é•¿åº¦è¾ƒå°‘çš„é‚£ä¸ªï¼Œç„¶åé€šè¿‡æ ‡è¯†ä½æ¥è®°å½•æ˜¯å¦å‘ç”Ÿè¿‡äº¤æ¢ï¼Œç¡®ä¿ç­”æ¡ˆçš„ç‚¹é¡ºåºçš„æ­£ç¡®æ€§ã€‚

æ¯æ¬¡ä»ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­å–å‡ºå †é¡¶å…ƒç´ ï¼ˆå«ä¹‰ä¸ºå½“å‰æœªè¢«åŠ å…¥åˆ°ç­”æ¡ˆçš„æ‰€æœ‰ç‚¹å¯¹ä¸­çš„æœ€å°å€¼ï¼‰ï¼ŒåŠ å…¥ç­”æ¡ˆï¼Œå¹¶å°†è¯¥ç‚¹å¯¹æ‰€åœ¨åºåˆ—çš„ä¸‹ä¸€ä½ï¼ˆå¦‚æœæœ‰ï¼‰åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ã€‚

ä¸¾ä¸ª ğŸŒ°ï¼Œé¦–æ¬¡å–å‡ºçš„äºŒå…ƒç»„ä¸º (0,0)ï¼Œå³ç‚¹å¯¹ (nums1[0],nums2[0])ï¼Œå–å®Œåå°†åºåˆ—çš„ä¸‹ä¸€ä½ç‚¹å¯¹ (nums1[0],nums2[1]) ä»¥äºŒå…ƒç»„ (0,1) å½¢å¼æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ã€‚

å¯é€šè¿‡ã€Œåè¯æ³•ã€è¯æ˜ï¼Œæ¯æ¬¡è¿™æ ·çš„ã€Œå–å½“å‰ï¼Œæ”¾å…¥ä¸‹ä¸€ä½ã€çš„æ“ä½œï¼Œå¯ä»¥ç¡®ä¿å½“å‰æœªè¢«åŠ å…¥ç­”æ¡ˆçš„æ‰€æœ‰ç‚¹å¯¹çš„æœ€å°å€¼å¿…ç„¶åœ¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ä¸­ï¼Œå³å‰ k ä¸ªå‡ºå †çš„å…ƒç´ å¿…ç„¶æ˜¯æ‰€æœ‰ç‚¹å¯¹çš„å‰ k å°çš„å€¼ã€‚

è§£ç­”ï¼š

```java
import java.util.*;

class Solution {
	int flag = true;
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        int n = nums1.length, m = nums2.length;
        if(n > m && !(flag = false)) return kSmallestPairs(nums2, nums1, k); //guarantee nums1.length <= nums2.length
        List<List<Integer>> res = new ArrayList<>();
        
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> {
            return (nums1[a[0]] + nums2[a[1]]) - (nums1[b[0]] + nums2[b[1]]);
        });
        for(int i = 0; i < Math.min(n, k); i++) pq.add(new int[]{i, 0});
        while(res.size() < k && !pq.isEmpty()){
            int[] temp = pq.poll();
            int a = temp[0], b = temp[1];
            res.add(Arrays.asList(flag ? nums1[a] : nums2[b], flag ? nums2[b] : nums1[a]));

            if(b+1 < m) pq.add(new int[]{a, b+1});

        }
        return res;

    }
}

```



## [324. æ‘†åŠ¨æ’åº II](https://leetcode.cn/problems/wiggle-sort-ii/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œå°†å®ƒé‡æ–°æ’åˆ—æˆ `nums[0] < nums[1] > nums[2] < nums[3]...` çš„é¡ºåºã€‚

ä½ å¯ä»¥å‡è®¾æ‰€æœ‰è¾“å…¥æ•°ç»„éƒ½å¯ä»¥å¾—åˆ°æ»¡è¶³é¢˜ç›®è¦æ±‚çš„ç»“æœã€‚

è§£é¢˜æ€è·¯

å†™åœ¨å‰é¢ï¼Œæœ¬è§£æ³•ä¸æ»¡è¶³è¿›é˜¶çš„æ¡ä»¶ã€‚

é¢˜ç›®ç»™å®šäº†æ‰€æœ‰è¾“å…¥æ•°ç»„éƒ½å¯ä»¥å¾—åˆ°æ»¡è¶³é¢˜ç›®è¦æ±‚çš„ç»“æœï¼Œ

æŒ‰é¢˜ç›®æ¡ä»¶æˆ‘ä»¬æƒ³å¶æ•°åæ ‡ä½å¡«å°ä¸€äº›çš„æ•°ï¼Œå¥‡æ•°åæ ‡ä½å¡«å¤§ä¸€äº›çš„æ•°ï¼Œæƒ³åˆ°æ’åºååˆ†æˆä¸¤éƒ¨åˆ†ã€‚

ä½†æ˜¯è¿™ä¸¤éƒ¨åˆ†çš„åˆ†ç•Œå¤„å¯èƒ½æ˜¯ä¸€æ ·å¤§çš„ï¼Œæ¯”å¦‚[4,5,5,6]çš„åˆ†ç•Œåœ¨5ã€‚

ä¸ºäº†ä¿è¯ä¸€æ ·å¤§çš„æ•°ä¼šè¢«é”™å¼€ï¼Œæˆ‘ä»¬å¯ä»¥å°†å‰éƒ¨åˆ†å€’åºå¡«å…¥ï¼ŒåŒæ—¶ä¸ºäº†ä¿è¯ä¸€å®šæ¯”å®ƒå¤§ï¼Œåéƒ¨åˆ†ä¹Ÿè¦å€’åºå¡«å…¥ã€‚

è§£ç­”:

```python
class Solution(object):
    def wiggleSort(self, nums):
        nums.sort()
        nums[::2], nums[1::2] = nums[:(len(nums)+1)//2][::-1], nums[(len(nums)+1)//2:][::-1]
        return nums
        
```

## æ ‘ä¸Šå€å¢ç®—æ³•ï¼ˆä»¥åŠæœ€è¿‘å…¬å…±ç¥–å…ˆï¼‰

### [1483. æ ‘èŠ‚ç‚¹çš„ç¬¬ K ä¸ªç¥–å…ˆ](https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/)

ç»™ä½ ä¸€æ£µæ ‘ï¼Œæ ‘ä¸Šæœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼ŒæŒ‰ä» `0` åˆ° `n-1` ç¼–å·ã€‚æ ‘ä»¥çˆ¶èŠ‚ç‚¹æ•°ç»„çš„å½¢å¼ç»™å‡ºï¼Œå…¶ä¸­ `parent[i]` æ˜¯èŠ‚ç‚¹ `i` çš„çˆ¶èŠ‚ç‚¹ã€‚æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯ç¼–å·ä¸º `0` çš„èŠ‚ç‚¹ã€‚

æ ‘èŠ‚ç‚¹çš„ç¬¬ *`k`* ä¸ªç¥–å…ˆèŠ‚ç‚¹æ˜¯ä»è¯¥èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„ä¸Šçš„ç¬¬ `k` ä¸ªèŠ‚ç‚¹ã€‚

å®ç° `TreeAncestor` ç±»ï¼š

- `TreeAncestorï¼ˆint nï¼Œ int[] parentï¼‰` å¯¹æ ‘å’Œçˆ¶æ•°ç»„ä¸­çš„èŠ‚ç‚¹æ•°åˆå§‹åŒ–å¯¹è±¡ã€‚
- `getKthAncestor``(int node, int k)` è¿”å›èŠ‚ç‚¹ `node` çš„ç¬¬ `k` ä¸ªç¥–å…ˆèŠ‚ç‚¹ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ç¥–å…ˆèŠ‚ç‚¹ï¼Œè¿”å› `-1` 

ä¸€ã€æ€è€ƒ

æœ€æš´åŠ›çš„åšæ³•æ˜¯ï¼Œä» node å‡ºå‘ï¼Œä¸€æ­¥ä¸€æ­¥åœ°å¾€ä¸Šè·³ï¼Œå³

nodeâ†’parent[node]â†’parent[parent[node]]â†’â‹¯

éœ€è¦è·³ k æ¬¡æ‰èƒ½åˆ°è¾¾ node çš„ç¬¬ k ä¸ªç¥–å…ˆèŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(k)ã€‚

å¦‚ä½•ä¼˜åŒ–è¿™ä¸ªæš´åŠ›ç®—æ³•å‘¢ï¼Ÿ

ä¸€ä¸ªåˆæ­¥çš„æƒ³æ³•æ˜¯ï¼Œé¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„ã€Œçˆ·çˆ·èŠ‚ç‚¹ã€ï¼Œå³çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä¸¤æ­¥ä¸¤æ­¥åœ°å¾€ä¸Šè·³ï¼Œä»è€Œå‡å°‘ä¸€åŠçš„è·³è·ƒæ¬¡æ•°ï¼ˆå¾ªç¯æ¬¡æ•°ï¼‰ã€‚

è¿›ä¸€æ­¥åœ°ï¼Œå†é¢„å¤„ç†å‡ºçˆ·çˆ·èŠ‚ç‚¹çš„çˆ·çˆ·èŠ‚ç‚¹ï¼Œå°±å¯ä»¥å››æ­¥å››æ­¥åœ°å¾€ä¸Šè·³ã€‚

è¯·ä½ æ€è€ƒï¼šä¸€èˆ¬åœ°ï¼Œè¦é¢„å¤„ç†å‡ºå“ªäº›èŠ‚ç‚¹å‘¢ï¼Ÿå¦‚ä½•åˆ©ç”¨è¿™äº›é¢„å¤„ç†å‡ºçš„èŠ‚ç‚¹ï¼Œå¿«é€Ÿåœ°æ‰¾åˆ°ç¬¬ k ä¸ªç¥–å…ˆèŠ‚ç‚¹ï¼Ÿ

äºŒã€è§£æƒ‘

é¢„å¤„ç†å‡º**æ¯ä¸ªèŠ‚ç‚¹**çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹ï¼Œå³ç¬¬ $1,2,4,8,â‹¯$ ä¸ªç¥–å…ˆèŠ‚ç‚¹ï¼ˆå…¶ä¸­ x çš„ç¬¬ 1 ä¸ªç¥–å…ˆèŠ‚ç‚¹å°±æ˜¯ `parent[x]`ï¼‰ã€‚ç”±äºä»»æ„ k å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä¸åŒçš„ 2 çš„å¹‚ï¼ˆä¾‹å¦‚ 13=8+4+1ï¼‰ï¼Œæ‰€ä»¥åªéœ€è¦é¢„å¤„ç†å‡ºè¿™äº› $2^i$ ç¥–å…ˆèŠ‚ç‚¹ï¼Œå°±å¯ä»¥å¿«é€Ÿåœ°åˆ°è¾¾**ä»»æ„**ç¬¬ k ä¸ªç¥–å…ˆèŠ‚ç‚¹ã€‚

ä¾‹å¦‚ $k=13=8+4+1=1101(2)$ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå¾€ä¸Šè·³ 8 æ­¥ï¼Œå†å¾€ä¸Šè·³ 4 æ­¥å’Œ 1 æ­¥ï¼›ä¹Ÿå¯ä»¥å…ˆå¾€ä¸Šè·³ 1 æ­¥ï¼Œå†å¾€ä¸Šè·³ 4 æ­¥å’Œ 8 æ­¥ã€‚æ— è®ºå¦‚ä½•è·³ï¼Œéƒ½åªéœ€è¦è·³ 3 æ¬¡å°±èƒ½åˆ°è¾¾ç¬¬ 13 ä¸ªç¥–å…ˆèŠ‚ç‚¹ã€‚

æ®æ­¤ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„ç®—æ³•ã€‚

-ä¸‰ã€ç®—æ³•

åœ¨æ„é€ å‡½æ•° TreeAncestor ä¸­ï¼Œé¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹ x çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹ï¼Œè®°ä½œ `pa[x][i]`ï¼ˆè‹¥ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™ `pa[x][i]=âˆ’1`ï¼‰ã€‚è®¡ç®—æ–¹å¼å¦‚ä¸‹ï¼š

- å…ˆæšä¸¾ iï¼Œå†æšä¸¾ xã€‚ç›¸å½“äºå…ˆç®—å‡ºæ‰€æœ‰çˆ·çˆ·èŠ‚ç‚¹ï¼Œå†ç®—å‡ºæ‰€æœ‰çˆ·çˆ·èŠ‚ç‚¹çš„çˆ·çˆ·èŠ‚ç‚¹ï¼Œä¾æ­¤ç±»æ¨ã€‚
- `pa[x][0]=parent[x]`ï¼Œå³çˆ¶èŠ‚ç‚¹ã€‚
- `pa[x][1]=pa[pa[x][0]][0]`ï¼Œå³çˆ·çˆ·èŠ‚ç‚¹ã€‚
- ä¾æ­¤ç±»æ¨ï¼Œ``pa[x][i+1]=pa[pa[x][i]][i]`ï¼Œè¡¨ç¤º x çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹å°±æ˜¯ x çš„ç¬¬ $2^i$+1 ä¸ªç¥–å…ˆèŠ‚ç‚¹ã€‚ç‰¹åˆ«åœ°ï¼Œå¦‚æœ `pa[x][i]=âˆ’1` åˆ™ `pa[x][i+1]=âˆ’1`ã€‚
- è¿™é‡Œ i+1 è‡³å¤šä¸º `âŒŠlog2nâŒ‹`ã€‚ä¾‹å¦‚ n=13 æ—¶ï¼Œ`âŒŠlog213âŒ‹=3`ï¼Œè‡³å¤šéœ€è¦é¢„å¤„ç†åˆ°ç¬¬ 23 ä¸ªç¥–å…ˆèŠ‚ç‚¹ã€‚ï¼ˆå½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥å…ˆæŠŠæ ‘é«˜ï¼Œæˆ–è€…æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦æ±‚å‡ºæ¥ï¼Œå†æ®æ­¤åšç²¾ç»†åœ°è®¡ç®—ã€‚ï¼‰

å¯¹äº getKthAncestorï¼Œéœ€è¦æ‰¾åˆ° k çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æ‰€æœ‰ 1ï¼ˆç›¸å½“äºæŠŠ k åˆ†è§£ä¸ºè‹¥å¹² $2^i$ï¼‰ã€‚å¯ä»¥ä»å°åˆ°å¤§æšä¸¾ iï¼Œå¦‚æœ k å³ç§» i ä½åçš„æœ€ä½ä½ä¸º 1ï¼Œå°±è¯´æ˜ k çš„äºŒè¿›åˆ¶ä»ä½åˆ°é«˜ç¬¬ i ä½æ˜¯ 1ï¼Œé‚£ä¹ˆå¾€ä¸Šè·³ $2^i$ æ­¥ï¼Œå°† node æ›´æ–°ä¸º `pa[node][i]`ã€‚å¦‚æœ node=âˆ’1 åˆ™è¯´æ˜ç¬¬ k ä¸ªç¥–å…ˆèŠ‚ç‚¹ä¸å­˜åœ¨ã€‚

```python
from typing import List

class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        m = n.bit_length() - 1
        pa = [[p] + [-1] * m for p in parent] # listç›´æ¥ç›¸åŠ å°±æ˜¯æ‹¼æ¥,ä¹Ÿå¯ä»¥ç”¨extendåŠ å¦ä¸€ä¸ªlist,æˆ–è€…appendåŠ å•ä¸ªå…ƒç´ 
        for j in range(m): # 
            for x in range(n): # j, xçš„é¡ºåºä¸èƒ½é”™
                if(p := pa[x][j]) != -1:
                    pa[x][j+1] = pa[p][j]
        self.pa = pa
        

    def getKthAncestor(self, node: int, k: int) -> int:
        for i in range(k.bit_length()):
            if (k >> i) & 1:
                node = self.pa[node][i]
                if node == -1:
                    return -1
        return node
```

å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šé¢„å¤„ç† $O(n \log n)$ï¼Œå›ç­”æ¯ä¸ªè¯¢é—® $O(\log k)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šé¢„å¤„ç†éœ€è¦ $O(n \log n)$ çš„ç©ºé—´ã€‚

> æ³¨ï¼šåˆ©ç”¨é•¿é“¾å‰–åˆ†ï¼Œå¯ä»¥åšåˆ°é¢„å¤„ç† $O(n \log n)$ï¼Œå›ç­”æ¯ä¸ªè¯¢é—® $O(1)$ çš„æ—¶é—´å¤æ‚åº¦ã€‚

### LCAæ¨¡æ¿

å¦‚ä½•è®¡ç®—æ ‘ä¸Šä»»æ„ä¸¤ç‚¹ x å’Œ y çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ lca å‘¢ï¼Ÿ

è®¾èŠ‚ç‚¹ i çš„æ·±åº¦ä¸º `depth[i]`ï¼Œè¿™å¯ä»¥é€šè¿‡ä¸€æ¬¡ DFS é¢„å¤„ç†å‡ºæ¥ã€‚

å‡è®¾ $depth[x] \leq depth[y]$ï¼ˆå¦åˆ™äº¤æ¢ä¸¤ç‚¹ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥å…ˆæŠŠæ›´é ä¸‹çš„ y æ›´æ–°ä¸º y çš„ç¬¬ $depth[y] - depth[x]$ ä¸ªç¥–å…ˆèŠ‚ç‚¹ï¼Œè¿™æ · x å’Œ y å°±å¤„åœ¨åŒä¸€æ·±åº¦äº†ã€‚

å¦‚æœæ­¤æ—¶ x = yï¼Œé‚£ä¹ˆ x å°±æ˜¯ lcaã€‚å¦åˆ™è¯´æ˜ lca åœ¨æ›´ä¸Šé¢ï¼Œé‚£ä¹ˆå°±æŠŠ x å’Œ y ä¸€èµ·å¾€ä¸Šè·³ã€‚

ç”±äºä¸çŸ¥é“ lca çš„å…·ä½“ä½ç½®ï¼Œåªèƒ½ä¸æ–­å°è¯•ï¼Œå…ˆå°è¯•å¤§æ­¥è·³ï¼Œå†å°è¯•å°æ­¥è·³ã€‚è®¾ $i = \lfloor \log_2 n \rfloor$ï¼Œå¾ªç¯ç›´åˆ° i < 0ã€‚æ¯æ¬¡å¾ªç¯ï¼š

- å¦‚æœ x çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œå³ `pa[x][i] = -1`ï¼Œè¯´æ˜æ­¥å­è¿ˆå¤§äº†ï¼Œå°† i å‡ 1ï¼Œç»§ç»­å¾ªç¯ã€‚
- å¦‚æœ x çš„ç¬¬ $2^i$ ä¸ªç¥–å…ˆèŠ‚ç‚¹å­˜åœ¨ï¼Œä¸” `pa[x][i] != pa[y][i]`ï¼Œè¯´æ˜ lca åœ¨ `pa[x][i]` çš„ä¸Šé¢ï¼Œé‚£ä¹ˆæ›´æ–° `x = pa[x][i]`ï¼Œæ›´æ–° `y = pa[y][i]`ï¼Œå°† i å‡ 1ï¼Œç»§ç»­å¾ªç¯ã€‚
- å¦åˆ™ï¼Œè‹¥ `pa[x][i] = pa[y][i]`ï¼Œé‚£ä¹ˆ lca å¯èƒ½åœ¨ `pa[x][i]` ä¸‹é¢ï¼Œç”±äºæ— æ³•å‘ä¸‹è·³ï¼Œåªèƒ½å°† i å‡ 1ï¼Œç»§ç»­å¾ªç¯ã€‚

ä¸Šè¿°åšæ³•èƒ½è·³å°±å°½é‡è·³ï¼Œä¸ä¼šé”™è¿‡ä»»ä½•å¯ä»¥ä¸Šè·³çš„æœºä¼šã€‚æ‰€ä»¥å¾ªç¯ç»“æŸæ—¶ï¼Œx ä¸ lca åªæœ‰ä¸€æ­¥ä¹‹é¥ï¼Œå³ `lca = pa[x][0]`ã€‚

> æ³¨ï¼šä½ ä¹Ÿå¯ä»¥ç”¨äºŒåˆ†æ¥ç†è§£ä¸Šè¿°ç®—æ³•ã€‚åœ¨ x åˆ°æ ¹èŠ‚ç‚¹çš„è¿™æ¡è·¯å¾„ä¸ŠçŒœä¸€ä¸ªç‚¹ z å½“ä½œ lcaï¼Œä¸” x ä¸ z ç›¸è· $2^i$ æ­¥ã€‚é‚£ä¹ˆæŠŠ x å’Œ y åŒæ—¶å‘ä¸Šè·³ $2^i$ æ­¥ï¼Œå¦‚æœ $x \neq y$ï¼Œå°±è¯´æ˜ lca åœ¨ z çš„ä¸Šé¢ï¼Œå¦åˆ™ lca è¦ä¹ˆæ˜¯ zï¼Œè¦ä¹ˆåœ¨ z çš„ä¸‹é¢ã€‚è¿™æ ·ä¸€ç§äºŒæ®µæ€§æ—¢è¯´æ˜äº†äºŒåˆ†çš„æ­£ç¡®æ€§ï¼Œåˆè¯´æ˜äº†æ¯æ¬¡ä¸Šè·³ä¹‹åï¼Œæ­¥é•¿ä¸€å®šè¦å‡åŠï¼ˆç±»æ¯”äºŒåˆ†æŸ¥æ‰¾ï¼ŒæŠŠæœç´¢çš„åŒºé—´é•¿åº¦å‡åŠï¼‰ã€‚

è€ƒè™‘åˆ°é€šå¸¸é¢˜ç›®æ˜¯ç”¨ edges çš„æ–¹å¼è¾“å…¥çš„ï¼Œæ‰€ä»¥ä¸‹é¢çš„æ¨¡æ¿å…ˆç”¨ edges å»ºå›¾ï¼Œå†ç”¨ DFS é¢„å¤„ç†ã€‚

```python
from typing import List

class TreeAncestor:
    def __init__(self, edges: List[List[int]]):
        n = len(edges) + 1 
        m = n.bit_length()
        g = [[] for _ in range(n)] # é‚»æ¥è¡¨
        for x, y in edges:  # èŠ‚ç‚¹ç¼–å·ä» 0 å¼€å§‹
            g[x].append(y)
            g[y].append(x)

        depth = [0] * n
        pa = [[-1] * m for _ in range(n)]
        def dfs(x: int, fa: int) -> None:
            pa[x][0] = fa
            for y in g[x]:
                if y != fa: # ä¸æ˜¯çˆ¶èŠ‚ç‚¹,é‚£å°±æ˜¯å­èŠ‚ç‚¹
                    depth[y] = depth[x] + 1
                    dfs(y, x)
        dfs(0, -1)

        for i in range(m - 1):
            for x in range(n):
                if (p := pa[x][i]) != -1:
                    pa[x][i + 1] = pa[p][i] #ç”Ÿæˆ2^içˆ¶èŠ‚ç‚¹æ•°ç»„
        self.depth = depth
        self.pa = pa

    def get_kth_ancestor(self, node: int, k: int) -> int:
        for i in range(k.bit_length()):
            if k >> i & 1:  # k äºŒè¿›åˆ¶ä»ä½åˆ°é«˜ç¬¬ i ä½æ˜¯ 1
                node = self.pa[node][i]
        return node

    # è¿”å› x å’Œ y çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆèŠ‚ç‚¹ç¼–å·ä» 0 å¼€å§‹ï¼‰
    def get_lca(self, x: int, y: int) -> int:
        if self.depth[x] > self.depth[y]:
            x, y = y, x

        y = self.get_kth_ancestor(y, self.depth[y] - self.depth[x]) # ä½¿ y å’Œ x åœ¨åŒä¸€æ·±åº¦

        if y == x:
            return x

        for i in range(len(self.pa[x]) - 1, -1, -1): # å…ˆè·³å¤§æ­¥ï¼Œå†è·³å°æ­¥
            px, py = self.pa[x][i], self.pa[y][i]
            if px != py:
                x, y = px, py  # åŒæ—¶å¾€ä¸Šè·³ 2**i æ­¥
        return self.pa[x][0] # æœ€åä¸€è·³å¿…å®šæ˜¯å…¬å…±ç¥–å…ˆ
```

å¤æ‚åº¦åˆ†æ

- æ—¶é—´å¤æ‚åº¦ï¼šé¢„å¤„ç† $O(n \log n)$ï¼Œå›ç­”æ¯ä¸ªè¯¢é—® $O(\log n)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šé¢„å¤„ç†éœ€è¦ $O(n \log n)$ çš„ç©ºé—´ã€‚

## æ ‘ä¸ŠèƒŒåŒ… + çŠ¶æ€æœº DP

### 0-1èƒŒåŒ…

capacity:èƒŒåŒ…å®¹é‡

w[i]:ç¬¬iä¸ªç‰©å“çš„ä½“ç§¯

v[i]:ç¬¬iä¸ªç‰©å“çš„ä»·å€¼

è¿”å›ï¼šæ¯ä¸ªç‰©å“è‡³å¤šé€‰ä¸€æ¬¡,æ‰€é€‰ç‰©å“ä½“ç§¯å’Œä¸è¶…è¿‡capacityçš„å‰æä¸‹ï¼Œæ‰€èƒ½å¾—åˆ°çš„æœ€å¤§ä»·å€¼å’Œ

```python
def zero_one_knapsack(capacity: List[int], w: List[int], v: List[int]) -> int: # 0-1 knapsack
    n = len(w)

    def dfs(i, c):
        if i < 0:
            return 0
        if c < w[i]:
            return dfs(i - 1, c)
        return max(dfs(i - 1, c), v[i] + dfs(i - 1, c - w[i]))
    return dfs(n - 1, capacity)
```

0-1èƒŒåŒ…**å¸¸è§å˜å½¢**:

- è‡³å¤šè£…capacity,æ±‚æ–¹æ¡ˆæ•°/æœ€å¤§ä»·å€¼å’Œ
- æ°å¥½è£…capacity,æ±‚æ–¹æ¡ˆæ•°/æœ€å¤§/æœ€å°ä»·å€¼å’Œ
- è‡³å°‘è£…capacity,æ±‚æ–¹æ¡ˆæ•°/æœ€å°ä»·å€¼å’Œ

#### [494. ç›®æ ‡å’Œ](https://leetcode.cn/problems/target-sum/)

ç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `target` ã€‚

å‘æ•°ç»„ä¸­çš„æ¯ä¸ªæ•´æ•°å‰æ·»åŠ  `'+'` æˆ– `'-'` ï¼Œç„¶åä¸²è”èµ·æ‰€æœ‰æ•´æ•°ï¼Œå¯ä»¥æ„é€ ä¸€ä¸ª **è¡¨è¾¾å¼** ï¼š

- ä¾‹å¦‚ï¼Œ`nums = [2, 1]` ï¼Œå¯ä»¥åœ¨ `2` ä¹‹å‰æ·»åŠ  `'+'` ï¼Œåœ¨ `1` ä¹‹å‰æ·»åŠ  `'-'` ï¼Œç„¶åä¸²è”èµ·æ¥å¾—åˆ°è¡¨è¾¾å¼ `"+2-1"` 

è¿”å›å¯ä»¥é€šè¿‡ä¸Šè¿°æ–¹æ³•æ„é€ çš„ã€è¿ç®—ç»“æœç­‰äº `target` çš„ä¸åŒ **è¡¨è¾¾å¼** çš„æ•°ç›®ã€‚

è§£ç­”:

æœ¬é¢˜(æ°å¥½è£…capacity):

```python
from typing import List
from functools import cache
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        n = len(nums)
        target += sum(nums)
        if target < 0 or target % 2:
            return 0
        capacity = target // 2

        @cache
        def dfs(i, c):
            if i < 0:
                return 0 if c != 0 else 1
            if c < nums[i]:
                return dfs(i - 1, c)
            return dfs(i - 1, c) + dfs(i - 1, c - nums[i])
        return dfs(n - 1, capacity)
```

æ—¶é—´ä¼˜åŒ–:

```python
from typing import List
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        n = len(nums)
        target += sum(nums)
        if target < 0 or target % 2:
            return 0
        capacity = target // 2

        f = [[0] * (capacity+1) for _ in range(n+1)] # dpæ•°ç»„,å°†é€’å½’æ”¹æˆå¾ªç¯
        f[0][0] = 1 #å°†è¾¹ç•Œæ¡ä»¶è½¬ä¸ºäº†åˆå§‹åŒ–çŠ¶æ€
        for i, x in enumerate(nums):
            for t in range(capacity+1):
                if t >= x:
                    f[i+1][t] = f[i][t] + f[i][t-x]
                else:
                    f[i+1][t] = f[i][t]
        return f[n][capacity]
```

è¿›ä¸€æ­¥ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦:

1. ç¼©å°åˆ°é€’å½’çš„ä¸¤ä¸ªæ•°ç»„,iå–æ¨¡2
2. åªç”¨ä¸€ç»´æ•°ç»„,è°ƒæ•´dp,ä½¿ç”¨å€’åº

### å®Œå…¨èƒŒåŒ…

å®Œå…¨èƒŒåŒ…ï¼šæœ‰nç§ç‰©å“ï¼Œç¬¬iç§ç‰©å“çš„ä½“ç§¯ä¸ºw[i]ï¼Œä»·å€¼ä¸ºv[i],æ¯ç§ç‰©å“æ— é™æ¬¡é‡å¤é€‰ï¼Œæ±‚ä½“ç§¯å’Œä¸è¶…è¿‡capacityæ—¶çš„æœ€å¤§ä»·å€¼å’Œ

```python
def unbounded_knapsack(capacity: List[int], w: List[int], v: List[int]) -> int:
    n = len(w)

    def dfs(i, c):
        if i < 0:
            return 0
        if c < w[i]:
            return dfs(i - 1, c)
        return max(dfs(i - 1, c), v[i] + dfs(i, c - w[i])) # å’Œ0-1èƒŒåŒ…å”¯ä¸€çš„åŒºåˆ«, è¿™é‡Œå¯ä»¥é‡å¤é€‰ç¬¬iä»¶ç‰©å“
    return dfs(n - 1, capacity)
```

**å¸¸è§å˜å½¢**:

- è‡³å¤šè£…capacity,æ±‚æ–¹æ¡ˆæ•°/æœ€å¤§ä»·å€¼å’Œ
- æ°å¥½è£…capacity,æ±‚æ–¹æ¡ˆæ•°/æœ€å¤§/æœ€å°ä»·å€¼å’Œ
- è‡³å°‘è£…capacity,æ±‚æ–¹æ¡ˆæ•°/æœ€å°ä»·å€¼å’Œ

#### [322. é›¶é’±å…‘æ¢](https://leetcode.cn/problems/coin-change/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `coins` ï¼Œè¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼›ä»¥åŠä¸€ä¸ªæ•´æ•° `amount` ï¼Œè¡¨ç¤ºæ€»é‡‘é¢ã€‚

è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„ **æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°** ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› `-1` ã€‚

ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚

è§£ç­”:

æœ¬é¢˜(æ°å¥½è£…capacity):

```python
from typing import List
from functools import cache
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)
        
        @cache
        def dfs(i, c):
            if i < 0:
                return inf if c != 0 else 0
            if c < coins[i]:
                return dfs(i - 1, c)
            return min(dfs(i-1, c), 1 + dfs(i, c - coins[i]))
        
        res = dfs(n-1, amount)
        return res if res < inf else -1
```

ç©ºé—´ä¼˜åŒ–ä¹Ÿæ˜¯ä¸¤ä¸ªæ•°ç»„,æˆ–è€…ä¸€ä¸ªæ•°ç»„(æ­¤æ—¶æ˜¯æ­£åº)

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)

        f = [inf] * (amount + 1)
        f[0] = 0

        for x in coins:
            for t in range(x, amount+1):
                f[t] = min(f[t], f[t-x]+1)
            
        return f[amount] if f[amount] < inf else -1
```



### æ€»ç»“

ä¸åŒçš„é¢˜ç›®ï¼Œæ‰€è¦çš„ç­”æ¡ˆä¸åŒï¼Œ æ¯”å¦‚ï¼šæ–¹æ¡ˆæ•°ï¼Œæœ€å¤§ã€å°å€¼ï¼Œæ•°å­—ä¸ªæ•°ï¼Œèƒ½å¦æ„æˆï¼Ÿ 

è¿™ä¹Ÿå°±æ„å‘³ç€ dp æ•°ç»„å€¼å¯ä»¥ä¸ºæ•°å€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ boolean ç±»å‹ 

å¦å¤–ï¼ŒåŒæ ·æ˜¯æ•°å€¼çš„æƒ…å†µä¸‹ï¼Œä¸åŒçš„è¦æ±‚ï¼Œä¹Ÿä¼šé€ æˆä¸åŒçš„åˆå§‹å€¼`f[0][0]`ï¼š 

- èƒ½å¦æ„æˆï¼š `f[0][0] = True` 0 å¯ä»¥æ„æˆ 0 
- æ–¹æ¡ˆæ•°ï¼š `f[0][0] = 1` 0 ç»„æˆ 0 åªæœ‰ä¸€ç§æ–¹æ¡ˆ 
- æ•°å­—ä¸ªæ•°ï¼š `f[0][0] = 0` 0 ç»„æˆ 0 æ²¡æœ‰ä½¿ç”¨æ•°å­— 
- æœ€å¤§ã€å°å€¼ï¼š é—®é¢˜ä¸€èˆ¬ä¼šå›å½’åˆ° æ–¹æ¡ˆæ•° æˆ– æ•°å­—ä¸ªæ•°é—®é¢˜ï¼Œ ä¸€èˆ¬ä¼šä½¿ç”¨åˆ° max/min å‡½æ•°çº¦æŸç­”æ¡ˆï¼Œè€Œä¸”ä¼šä½¿ç”¨ +-inf åˆå§‹åŒ–æ¥è¡¨ç¤ºæç«¯æƒ…å†µã€‚ æ¯”å¦‚ï¼šåŠ›æ‰£ 279 æ±‚æœ€å°æ•°é‡

ç”¨äºŒç»´æ•°ç»„çš„è¯ï¼Œéƒ½æ˜¯æ­£åºï¼›åœ¨åªç”¨ä¸€ä¸ªä¸€ç»´æ•°ç»„çš„æƒ…å†µä¸‹ï¼Œè¦æ³¨æ„è½¬ç§»æ¥æº 1. ä¸èƒ½è¢«è¦†ç›– 2. å¿…é¡»å·²ç»è®¡ç®—å‡ºæ¥ã€‚æŒ‰ç…§è¿™ä¸ªè¦æ±‚ï¼Œæ­£åºéå†ä¼šå¯¼è‡´ 0-1 èƒŒåŒ…çŠ¶æ€è¢«è¦†ç›–ï¼Œè€Œå®Œå…¨èƒŒåŒ…åˆ™æ˜¯æ­£ç¡®çš„ï¼ˆè½¬ç§»æ¥æºè¢«è®¡ç®—å‡ºæ¥ï¼Œä¸”ä¸å­˜åœ¨è¢«è¦†ç›–çš„é—®é¢˜ï¼‰ï¼›é€†åºéå†å¯¹äº 0-1 èƒŒåŒ…æ˜¯æ­£ç¡®çš„ï¼ˆè½¬ç§»æ¥æºæ˜¯ä¸Šä¸€è¡Œçš„ï¼Œæ—©å°±è¢«è®¡ç®—å‡ºæ¥äº†ä¸”æ²¡æœ‰è¢«è¦†ç›–ï¼‰ï¼Œè€Œå®Œå…¨èƒŒåŒ…åˆ™ä¸è¡Œï¼ˆè½¬ç§»æ¥æºæ²¡æœ‰è¢«è®¡ç®—å‡ºæ¥ï¼‰ã€‚
