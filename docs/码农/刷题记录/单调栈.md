# 单调栈

## 宝藏勘探

问题： 在一个从 0  到 n 的数轴上，每个位置有一个宝藏辐射值。两位勘探员正在勘探宝藏，勘探过的位置中的最大值和最小值之差代表整块数轴地的辐射值，能反映这块地方的宝藏可能性。两位勘探员分别从数轴的两侧相向而行，但是他们之间有矛盾，不愿意隔得太近，两位勘探员中间只剩 k 个单位长度时，就会停止前进。目前不知道两位勘探员谁先出发，只知道他们各自从两端相向而行向中间靠拢，中间相隔 k 个位置的时候停止勘探。问这块数轴地可能最小的宝藏辐射值是多少？

答案： 经典的单调队列问题，这题解法有很多种，比如优先队列+延迟删除（[力扣例题](https://leetcode.cn/problems/the-skyline-problem/description/)）、RMQ等等。由于这题一定是去掉中间的值，停止勘探区域移动过程中，可以将数组分为前部分和后部分，前部分可以边移动边更新前部分最大最小值，后部分则可以先按照前部分的计算方法倒着更新，将他们预处理然后更新答案即可。代码用单调队列写:

```java
    public static int minRadiationValue(int[] radiation, int n, int k) {
        // 存储左侧最小辐射值的数组
        int[] lmin = new int[n + 2];
        // 存储右侧最小辐射值的数组
        int[] rmin = new int[n + 2];
        // 存储左侧最大辐射值的数组
        int[] lmax = new int[n + 2];
        // 存储右侧最大辐射值的数组
        int[] rmax = new int[n + 2];
        // 存储最终结果，初始化为最大整数
        int result = Integer.MAX_VALUE;
        // 初始化左侧最小辐射值数组的第一个元素为最大整数
        lmin[0] = Integer.MAX_VALUE;
        // 初始化右侧最小辐射值数组的最后一个元素为最大整数
        rmin[n + 1] = Integer.MAX_VALUE;
        // 从左到右遍历，更新左侧最小和最大辐射值数组
        for (int i = 1; i <= n; i++) {
            lmin[i] = Math.min(lmin[i - 1], radiation[i]);
            lmax[i] = Math.max(lmax[i - 1], radiation[i]);
        }
        // 从右到左遍历，更新右侧最小和最大辐射值数组
        for (int i = n; i >= 1; i--) {
            rmin[i] = Math.min(rmin[i + 1], radiation[i]);
            rmax[i] = Math.max(rmax[i + 1], radiation[i]);
        }
        // 遍历可能的范围，计算最小的宝藏辐射值
        for (int i = 1; i <= (n-k); i++) {
            result = Math.min(result, Math.max(lmax[i - 1], rmax[i + k]) - Math.min(lmin[i - 1], rmin[i + k]));
        }
        return result;
    }

    public static void main(String[] args) {
        int[] radiation = {1, 3, 5, 2, 4, 7, 6};
        int n = radiation.length - 1;
        int k = 2;
        System.out.println("最小的宝藏辐射值是: " + minRadiationValue(radiation, n, k));
    }
```

