# 图论

## 图的基本概念

二维坐标中，两点可以连成线，多个点连成的线就构成了图。

当然图也可以就一个节点，甚至没有节点（空图）

### 图的种类

整体上一般分为 有向图 和 无向图。

加权有向图，就是图中边是有权值的，加权无向图也是同理

### 度

无向图中有几条边连接该节点，该节点就有几度。在有向图中，每个节点有出度和入度。出度：从该节点出发的边的个数。入度：指向该节点边的个数。

### 连通性

在图中表示节点的连通情况，我们称之为连通性。

### 连通图

在无向图中，任何两个节点都是可以到达的，我们称之为连通图，如果有节点不能到达其他节点，则为非连通图

### 强连通图

在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图。强连通图是在有向图中**任何两个节点是可以相互到达**

### 连通分量

在无向图中的**极大连通子图**称之为该图的一个连通分量。

### 强连通分量

在有向图中极大强连通子图称之为该图的强连通分量。

## 图的构造

一般使用邻接表、邻接矩阵或者用类来表示。主要是朴素存储、邻接表和邻接矩阵。

### 邻接矩阵

邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。

例如： `grid[2]][5] = 6`，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。如果想表示无向图，即：`grid[2][5] = 6`，`grid[5][2] = 6`，表示节点2 与 节点5 相互连通，权值为6。

在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。

邻接矩阵的优点：

- 表达方式简单，易于理解
- 检查任意两个顶点间是否存在边的操作非常快
- 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。

缺点：

- 遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费

### 邻接表

邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。

邻接表的构造如图：

![20241208_120929_473_copy](./images/20241208_120929_473_copy.png)

这里表达的图是：

- 节点1 指向 节点3 和 节点5
- 节点2 指向 节点4、节点3、节点5
- 节点3 指向 节点4
- 节点4指向节点1

邻接表的优点：

- 对于稀疏图的存储，只需要存储边，空间利用率高
- 遍历节点连接情况相对容易

缺点：

- 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
- 实现相对复杂，不易理解

## 图的遍历方式

图的遍历方式基本是两大类：

- 深度优先搜索（dfs）
- 广度优先搜索（bfs）

## DFS基础知识

DFS关键就两点：

- 搜索方向，是认准一个方向搜，直到碰壁之后再换方向
- 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。

## 代码框架

正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。

```c++
void dfs(参数) {
    处理节点
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```

## 98. 所有可达路径

[卡码网题目链接（ACM模式）](https://kamacoder.com/problempage.php?pid=1170)

【题目描述】

给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。

【输入描述】

第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边

后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径

【输出描述】

输出所有的可达路径，路径中所有节点的后面跟一个空格，每条路径独占一行，存在多条路径，路径输出的顺序可任意。

如果不存在任何一条路径，则输出 -1。

<!-- tabs:start -->

#### **邻接矩阵**

```java
import java.util.*;

public class Main{
    static List<Integer> path = new ArrayList<>();
    static List<List<Integer>> result = new ArrayList<>();
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int N = in.nextInt(); // 节点
        int M = in.nextInt(); // 边
        int[][] graph = new int[N+1][N+1];
        for(int i = 0; i < M; i++){
            int s = in.nextInt();
            int t = in.nextInt();
            graph[s][t] = 1;
        }
        path.add(1);
        dfs(graph, 1, N);
        if(result.size() == 0) System.out.println(-1);
        else{
            for(List<Integer> p : result){
                for(int i = 0; i < p.size()-1; i++){
                    System.out.print(p.get(i) + " ");
                }
                System.out.println(p.get(p.size()-1));
            }
        }
        in.close();
    }
    private static void dfs(int[][] graph, int x, int n){
        if(x == n){
            result.add(new ArrayList<>(path));
            return;
        }
        for(int i = 1; i <= n; i++){
            if(graph[x][i] == 1){
                path.add(i);
                dfs(graph, i, n);
                path.remove(path.size()-1);
            }
        }
    }
}
```

#### **邻接表**

```java
import java.util.*;

public class Main{
    static List<Integer> path = new ArrayList<>();
    static List<List<Integer>> result = new ArrayList<>();
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int N = in.nextInt(); // 节点
        int M = in.nextInt(); // 边
        List<LinkedList<Integer>> graph = new ArrayList<>(N+1);
        for(int i = 0; i <= N; i++){
            graph.add(new LinkedList<>());
        }
        for(int i = 0; i < M; i++){
            int s = in.nextInt();
            int t = in.nextInt();
            graph.get(s).add(t);
        }
        path.add(1);
        dfs(graph, 1, N);
        if(result.size() == 0) System.out.println(-1);
        else{
            for(List<Integer> p : result){
                for(int i = 0; i < p.size()-1; i++){
                    System.out.print(p.get(i) + " ");
                }
                System.out.println(p.get(p.size()-1));
            }
        }
        in.close();
    }
    private static void dfs(List<LinkedList<Integer>> graph, int x, int n){
        if(x == n){
            result.add(new ArrayList<>(path));
            return;
        }
        for(int i : graph.get(x)){
            path.add(i);
            dfs(graph, i, n);
            path.remove(path.size()-1);
        }
    }
}
```

<!-- tabs:end -->

## BSF基础知识

广搜的搜索方式就适合于解决两个点之间的最短路径问题。

因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。

## 99. 岛屿数量

[卡码网题目链接（ACM模式）](https://kamacoder.com/problempage.php?pid=1171)

题目描述：

给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。

<!-- tabs:start -->

#### **DFS**

```java
import java.util.*;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int M = in.nextInt();
        int[][] arr = new int[N][M];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                arr[i][j] = in.nextInt();
            }
        }

        in.close();
        int count = 0;
        boolean[][] visited = new boolean[N][M];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(!visited[i][j] && arr[i][j] == 1){
                    count++;
                    visited[i][j] = true;
                    dfs(visited, i, j, arr);
                }
            }
        }

        System.out.println(count);
    }


    public static void dfs(boolean[][] visited, int x, int y, int[][] arr){
        for(int k = 0; k < 4; k++){
            int next_x = x + dir[k][0];
            int next_y = y + dir[k][1];
            if(next_x < 0 || next_x >= arr.length || next_y < 0 || next_y >= arr[0].length)
                continue;
            if(!visited[next_x][next_y] && arr[next_x][next_y] == 1){
                visited[next_x][next_y] = true;
                dfs(visited, next_x, next_y, arr);
            }

        }
    }
}

```



#### **BFS**

```java
import java.util.*;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int M = in.nextInt();
        int[][] arr = new int[N][M];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                arr[i][j] = in.nextInt();
            }
        }

        in.close();
        int count = 0;
        boolean[][] visited = new boolean[N][M];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(!visited[i][j] && arr[i][j] == 1){
                    count++;
                    bfs(visited, i, j, arr);
                }
            }
        }

        System.out.println(count);
    }


    public static void bfs(boolean[][] visited, int x, int y, int[][] arr){
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{x,y});
        visited[x][y] = true;


        while(!queue.isEmpty()){
            int cur_x = queue.peek()[0];
            int cur_y = queue.poll()[1];
            for(int k = 0; k < 4; k++){
                int next_x = cur_x + dir[k][0];
                int next_y = cur_y + dir[k][1];
                if(next_x < 0 || next_x >= arr.length || next_y < 0 || next_y >= arr[0].length)
                    continue;
                if(!visited[next_x][next_y] && arr[next_x][next_y] == 1){
                    queue.add(new int[]{next_x,next_y});
                    visited[next_x][next_y] = true;
                }
            }
        }
    }
}

```



<!-- tabs:end -->

## 01. 孤岛的总面积

[卡码网：101. 孤岛的总面积](https://kamacoder.com/problempage.php?pid=1173)

题目描述

给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。

现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。

输入描述

第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。

输出描述

输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。

解答：

<!-- tabs:start -->

#### **DFS**

```java
import java.util.*;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static int count = 0;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int M = in.nextInt();
        int[][] arr = new int[N][M];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                arr[i][j] = in.nextInt();
            }
        }

        in.close();

        // 从左边界和右边界向中间遍历
        for(int i = 0; i < N; i++){
            if(arr[i][0] == 1) dfs(i, 0, arr);
            if(arr[i][M-1] == 1) dfs(i, M-1, arr);
        }

        // 从上边界和下边界向中间遍历
        for(int j = 0; j < M; j++){ // 遍历上侧和下侧边界
            if(arr[0][j] == 1) dfs(0, j, arr);
            if(arr[N-1][j] == 1) dfs(N-1, j, arr);
        }

        count = 0;
        
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(arr[i][j] == 1) dfs(i, j, arr);
            }
        }

        System.out.println(count);
    }
    


    public static void dfs(int x, int y, int[][] arr){
        arr[x][y] = 0;
        count++;

        for(int i = 0; i < 4; i++){
            int newX = x + dir[i][0];
            int newY = y + dir[i][1]; 

            if(newX < 0 || newX >= arr.length || newY < 0 || newY >= arr[0].length)
                continue;

            if(arr[newX][newY] == 1){
                dfs(newX, newY, arr);
            }
        }
    }
}

```



#### **BFS**

```java
import java.util.*;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static int count = 0;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int M = in.nextInt();
        int[][] arr = new int[N][M];
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                arr[i][j] = in.nextInt();
            }
        }

        in.close();
        for(int i = 0; i < N; i++){ // 遍历左侧和右侧边界
            if(arr[i][0] == 1) bfs(i, 0, arr);
            if(arr[i][M-1] == 1) bfs(i, M-1, arr);
        }

        for(int j = 0; j < M; j++){ // 遍历上侧和下侧边界
            if(arr[0][j] == 1) bfs(0, j, arr);
            if(arr[N-1][j] == 1) bfs(N-1, j, arr);
        }

        count = 0;
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(arr[i][j] == 1) bfs(i, j, arr);
            }
        }

        System.out.println(count);
    }


    public static void bfs(int x, int y, int[][] arr){
        Queue<int[]> queue = new LinkedList<>();
        count++;
        queue.add(new int[]{x,y});
        arr[x][y] = 0;


        while(!queue.isEmpty()){
            int cur_x = queue.peek()[0];
            int cur_y = queue.poll()[1];
            for(int k = 0; k < 4; k++){
                int next_x = cur_x + dir[k][0];
                int next_y = cur_y + dir[k][1];
                if(next_x < 0 || next_x >= arr.length || next_y < 0 || next_y >= arr[0].length)
                    continue;
                if(arr[next_x][next_y] == 1){
                    count++;
                    queue.add(new int[]{next_x,next_y});
                    arr[next_x][next_y] = 0;
                }
            }
        }
    }
}

```



<!-- tabs:end -->



## 102. 沉没孤岛

[卡码网题目链接（ACM模式）](https://kamacoder.com/problempage.php?pid=1174)

题目描述：

给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。

现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。

输入描述：

第一行包含两个整数 N, M，表示矩阵的行数和列数。

之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。

解答：

#### DFS

```java
import java.util.Scanner;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[][] grid = new int[N][M];
        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                grid[i][j] = scanner.nextInt();
            }
        } 

        
        for (int i = 0; i < N; i++){
            if(grid[i][0] == 1) dfs(grid, i, 0);
            if(grid[i][M-1] == 1) dfs(grid, i, M-1);
        }
        
        for (int j = 0; j < M; j++){
            if(grid[0][j] == 1) dfs(grid, 0, j);
            if(grid[N-1][j] == 1) dfs(grid, N-1, j);
        }

        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                if(grid[i][j] == 1) grid[i][j] = 0;
                else if(grid[i][j] == 2) grid[i][j] = 1;
            }
        }

        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                System.out.print(grid[i][j] + " ");
            }
            System.out.println();
        }

        scanner.close();

    }
    
    private static void dfs(int[][] grid, int x, int y){

        grid[x][y] = 2;
        
        for(int i = 0; i < 4; i++){
            int next_x = x + dir[i][0];
            int next_y = y + dir[i][1];
            if(next_x >= 0 && next_x < grid.length && next_y >= 0 && next_y < grid[0].length && grid[next_x][next_y] == 1){
                dfs(grid, next_x, next_y);
            }
        }
    }
}
```

## 103. 水流问题

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1175)

题目描述：

现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。

矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。

解答：

```java
//DFS
import java.util.Scanner;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[][] grid = new int[N][M];
        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                grid[i][j] = scanner.nextInt();
            }
        }
        boolean[][] visited_second = new boolean[N][M];
        boolean[][] visited_first = new boolean[N][M];

        
        for (int i = 0; i < N; i++){
            dfs(grid, i, 0, visited_first, Integer.MIN_VALUE);
            dfs(grid, i, M-1, visited_second, Integer.MIN_VALUE);
        }
        
        for(int j = 0; j < M; j++){
            dfs(grid, N-1, j, visited_second, Integer.MIN_VALUE);
            dfs(grid, 0, j, visited_first, Integer.MIN_VALUE);
        }

        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                if(visited_second[i][j] && visited_first[i][j]){
                    System.out.println(i + " " + j);
                }
            }
        }

        scanner.close();

    }
    
    private static void dfs(int[][] grid, int x, int y, boolean[][] visited, int preH){
        if(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || visited[x][y]) return;

        if(grid[x][y] < preH) return;

        visited[x][y] = true;
        
        for(int i = 0; i < 4; i++){
            int next_x = x + dir[i][0];
            int next_y = y + dir[i][1];
            dfs(grid, next_x, next_y, visited, grid[x][y]);
        }
    }
}
```



## 104.建造最大岛屿

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1176)

题目描述：

给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。

岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。

解答：

```java
//DFS
import java.util.Scanner;

public class Main{
    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};
    public static int res = 0;
    public static int cnt = 0;
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        int[][] grid = new int[N][M];
        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                grid[i][j] = scanner.nextInt();
            }
        }
        
        
        for (int i = 0; i < N; i++){
            for (int j = 0; j < M; j++){
                if(grid[i][j] == 0){
                    boolean[][] visited = new boolean[N][M];
                    grid[i][j] = 1;
                    dfs(grid, i, j, visited);
                    if(cnt > res) res = cnt;
                    cnt = 0;
                    grid[i][j] = 0;
                }
            }
        }
        
        System.out.println(res == 0 ? N*M : res);

        scanner.close();

    }
    
    private static void dfs(int[][] grid, int x, int y, boolean[][] visited){
        if(grid[x][y] == 0 || visited[x][y]) return;

        visited[x][y] = true;
        cnt++;
        
        for(int i = 0; i < 4; i++){
            int next_x = x + dir[i][0];
            int next_y = y + dir[i][1];
            if(next_x < 0 || next_x >= grid.length || next_y < 0 || next_y >= grid[0].length) continue;

            dfs(grid, next_x, next_y, visited);
        }
    }
}
```

## 110. 字符串接龙

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1183)

题目描述

字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：

1. 序列中第一个字符串是 beginStr。
2. 序列中最后一个字符串是 endStr。
3. 每次转换只能改变一个字符。
4. 转换过程中的中间字符串必须是字典 strList 中的字符串。

给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。

解答：

```java
//DFS
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.nextLine();
        String beginStr = scanner.next();
        String endStr = scanner.next();
        scanner.nextLine();
        
        List<String> Str = new ArrayList<>();
        Str.add(beginStr);
        Str.add(endStr);
        for(int i = 0; i < n; i++){
            Str.add(scanner.nextLine());
        }
        int cnt = dfs(Str, beginStr, endStr);

        System.out.println(cnt);

        scanner.close();

    }

    private static int dfs(List<String> Str, String beginStr, String endStr){
        int len = 1;
        Set<String> visited = new HashSet<>();
        Set<String> set = new HashSet<>(Str);
        Queue<String> queue = new LinkedList<>();
        visited.add(beginStr);
        queue.add(beginStr);
        queue.add(null);
        while(!queue.isEmpty()){
            String curStr = queue.remove();
            
            if(curStr == null){
                if(!queue.isEmpty()){
                    len++;
                    queue.add(null);
                }
                continue;
            }

            char[] ss = curStr.toCharArray();
            for(int i = 0; i < ss.length; i++){
            
                char old = ss[i];
                for(char j = 'a'; j <= 'z'; j++){
                    ss[i] = j;
                    String newStr = new String(ss);
                    if(set.contains(newStr) && !visited.contains(newStr)){
                        queue.add(newStr);
                        visited.add(newStr);
                        if(newStr.equals(endStr)){
                            return len+1;
                        }
                    }
                }
                ss[i] = old;
            }
        }
        return 0;
    }
    
}
```

## 105.有向图的完全可达性

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1177)

【题目描述】

给定一个有向图，包含 N 个节点，节点编号分别为 1，2，...，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。

解答：

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        List<List<Integer>> dir = new ArrayList<>();
        int points = scanner.nextInt();
        int edges = scanner.nextInt();
        for(int i = 0; i < points; i++){
            dir.add(new ArrayList<>());
        }
        for(int i = 0; i < edges; i++){
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            dir.get(a-1).add(b-1);
        }
        boolean[] visited = new boolean[points];
        // dfs(dir, visited, 0);
        bfs(dir, visited, 0);
        for(int i = 0; i < visited.length; i++){
            if(!visited[i]){
                System.out.println(-1);
                return;
            }
        }
        System.out.println(1);

        scanner.close();
    }

    private static void dfs(List<List<Integer>> dir, boolean[] visited, int start){
        if(visited[start]) return;
        visited[start] = true;
        for(int i : dir.get(start)){
            dfs(dir, visited, i);
        }

    }

    private static void bfs(List<List<Integer>> dir, boolean[] visited, int start){
        Deque<Integer> dequeue = new LinkedList<>();
        dequeue.offer(start);
        visited[start] = true;
        while(!dequeue.isEmpty()){
            int cur = dequeue.pollLast();
            for(int i : dir.get(cur)){
                if(!visited[i]){
                    dequeue.offer(i);
                    visited[i] = true;
                }
            }
        }
    }
    
}
```

## 106. 岛屿的周长

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1178)

题目描述

给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。

你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。

解答：

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int M = scanner.nextInt();
        int N = scanner.nextInt();
        int[][] grid = new int[M][N];
        for(int i = 0; i < M; i++){
            for(int j = 0; j < N; j++){
                grid[i][j] = scanner.nextInt();
            }
        }
        int[][] dir = {{-1,0},{0,1},{1,0},{0,-1}};
        int count = 0;
        for(int i = 0; i < M; i++){
            for(int j = 0; j < N; j++){
                for(int k = 0; k < 4; k++){
                    if(grid[i][j] == 1){
                        int next_x = i + dir[k][0];
                        int next_y = j + dir[k][1];
                        if(next_x < 0 || next_x >= M || next_y < 0 || next_y >= N || grid[next_x][next_y] == 0){
                            count++;
                        }
                    }

                }
            }
        }

        System.out.println(count);
        scanner.close();
    }
}

```

## 并查集理论基础

并查集常用来解决连通性问题，也就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。

并查集主要有两个功能：

- 将两个元素添加到一个集合中
- 判断两个元素在不在同一个集合

### 原理

- 如何将两个元素添加到同一个集合中？

  可以用有向连通图,只需要用一个一维数组来表示，即：father[A] = B，father[B] = C，此时A和B有同一个根C

#### 路径压缩

在实现 find 函数的过程中，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。

搜索过程像是一个多叉树中从叶子到根节点的过程，如图：

![20230602102619](./images/20230602102619.png)

如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次。

我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：

![20230602103040](./images/20230602103040.png)

除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，如果我们想达到这样的效果，就需要 **路径压缩**，将非根节点的所有节点直接指向根节点,只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。

##### 代码模板

```c++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

#### 按秩（rank）合并

rank表示树的高度，即树中结点层次的最大值。

例如两个集合（多叉树）需要合并，如图所示：

![20250227_165915_203_copy](./images/20250227_165915_203_copy.png)

树1 rank 为2，树2 rank 为 3，在 join函数中，一定是 rank 小的树合入到 rank大的树，这样可以保证最后合成的树 rank 最小，降低在树上查询的路径长度。

![image-20250227170055899](./images/image-20250227170055899.png)

按秩合并的代码如下：

```c++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构
vector<int> rank = vector<int> (n, 1); // 初始每棵树的高度都为1

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
        rank[i] = 1; // 也可以不写
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : find(father[u]);// 注意这里不做路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根

    if (rank[u] <= rank[v]) father[u] = v; // rank小的树合入到rank大的树
    else father[v] = u;

    if (rank[u] == rank[v] && u != v) rank[v]++; // 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] <= rank[v]) father[u] = v; 注意是 <=
}
```

按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的，**直接使用路径压缩的并查集模板就好**。

### 复杂度分析

对路径压缩版并查集来做分析。

- 空间复杂度： O(n) ，申请一个father数组。

- 时间复杂度：如果想精确表达出来需要繁琐的数学证明，这里做一个简单的分析思路。

  路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)，在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。

## 107. 寻找存在的路径

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1179)

题目描述

给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。

你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。

解答：

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int points = scanner.nextInt();
        int edges = scanner.nextInt();
        Disjoint disjoint = new Disjoint(points+1);
        for(int i = 0; i < edges; i++){
            disjoint.join(scanner.nextInt(), scanner.nextInt());
        
        }

        if(disjoint.isSame(scanner.nextInt(), scanner.nextInt())){
            System.out.println(1);
        }
        else{
            System.out.println(0);
        }

        scanner.close();
    }
}

class Disjoint{
    private int[] father;

    public Disjoint(int n){
        father = new int[n];
        for(int i = 0; i < n; i++){
            father[i] = i;
        }
    }

    public int find(int x){
        return father[x] == x ? x : find(father[x]);
    }

    public void join(int x, int y){ // x -> y
        int fx = find(x);
        int fy = find(y);
        father[fx] = fy;
    }

    public boolean isSame(int x, int y){
        return find(x) == find(y);
    }
}

```

## 108. 冗余连接

[卡码网题目链接（ACM模式）(opens new window)](https://kamacoder.com/problempage.php?pid=1181)

题目描述

有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图（其实就是一个线形图），如图：

![20240905163122](./images/20240905163122.png)

现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图，如图

![20240905164721](./images/20240905164721.png)

先请你找出冗余边，删除后，使该图可以重新变成一棵树。

解答：

```java
```



未完待续~~~

