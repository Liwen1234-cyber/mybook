<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-码农/刷题记录/二叉树" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">二叉树 | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.middiy.top/码农/刷题记录/二叉树/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="二叉树 | Coisini"><meta data-rh="true" name="description" content="基础知识"><meta data-rh="true" property="og:description" content="基础知识"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.middiy.top/码农/刷题记录/二叉树/"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/二叉树/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/二叉树/" hreflang="x-default"><meta name="google-site-verification" content="1FUPX6Qo4y3ecU623ShEurhgnjhSTjK49rRMhEDlzFA">
<link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.53ea8373.css">
<script src="/assets/js/runtime~main.94f1205a.js" defer="defer"></script>
<script src="/assets/js/main.1f310fcb.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/分享/">Sharing</a><button aria-label="Expand sidebar category &#x27;Sharing&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/读书笔记/">读书笔记</a><button aria-label="Expand sidebar category &#x27;读书笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/技巧/">技巧</a><button aria-label="Expand sidebar category &#x27;技巧&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/数学/">数学</a><button aria-label="Expand sidebar category &#x27;数学&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/思考/">思考</a><button aria-label="Expand sidebar category &#x27;思考&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/学习/">学习</a><button aria-label="Expand sidebar category &#x27;学习&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/码农/"> 码农</a><button aria-label="Collapse sidebar category &#x27;码农&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/基础知识/">基础知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/面试题/">面试题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/java笔记/">java 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/数组/">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/链表/">链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/哈希表/">哈希表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/字符串/">字符串</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/双指针/">双指针总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/栈与队列/">栈与队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/码农/刷题记录/二叉树/">二叉树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/回溯/">回溯</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/贪心算法/">贪心算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/动态规划/">动态规划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/单调栈/">单调栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/图论/">图论</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/高级数据结构/">高级数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/其他/">其他</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/转码/">转码经验</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/How_browsers_work/">How browsers work</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/毛选/">毛选</a><button aria-label="Expand sidebar category &#x27;毛选&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/码农/"><span itemprop="name">码农</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">二叉树</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>二叉树</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础知识">基础知识<a href="#基础知识" class="hash-link" aria-label="Direct link to 基础知识" title="Direct link to 基础知识">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树的种类">二叉树的种类<a href="#二叉树的种类" class="hash-link" aria-label="Direct link to 二叉树的种类" title="Direct link to 二叉树的种类">​</a></h3>
<p>在我们解题过程中二  叉树有两种主要的形式：满二叉树和完全二叉树</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="满二叉树">满二叉树<a href="#满二叉树" class="hash-link" aria-label="Direct link to 满二叉树" title="Direct link to 满二叉树">​</a></h4>
<p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p>这棵二叉树为满二叉树，也可以说深度为k，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个节点的二叉树。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="完全二叉树">完全二叉树<a href="#完全二叉树" class="hash-link" aria-label="Direct link to 完全二叉树" title="Direct link to 完全二叉树">​</a></h4>
<p>完全二叉树的定义：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">1-2^{(h-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 个节点。</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20200920221638903-0fbe84ba1c5aaf8875d0a7a667ce8a00.png" width="1426" height="670" class="img_ev3q"></p>
<p><strong>优先级队列其实是一个堆</strong>，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="二叉搜索树">二叉搜索树<a href="#二叉搜索树" class="hash-link" aria-label="Direct link to 二叉搜索树" title="Direct link to 二叉搜索树">​</a></h4>
<p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p>下面这两棵树都是搜索树:</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20200806190304693-37675117f4f6bb0f01f063b55540fa90.png" width="786" height="276" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="平衡二叉搜索树">平衡二叉搜索树<a href="#平衡二叉搜索树" class="hash-link" aria-label="Direct link to 平衡二叉搜索树" title="Direct link to 平衡二叉搜索树">​</a></h4>
<p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>如图：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20200806190511967-0f5aa5d9e9971a1240b36aff425d89fc.png" width="1410" height="384" class="img_ev3q"></p>
<p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p>
<p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mord mathnormal">n</span></span></span></span>，而unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树的存储方式">二叉树的存储方式<a href="#二叉树的存储方式" class="hash-link" aria-label="Direct link to 二叉树的存储方式" title="Direct link to 二叉树的存储方式">​</a></h3>
<p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p>
<p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p>
<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>
<p>链式存储如图：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/2020092019554618-5f96dbb8ed937dcba95955623f54a412.png" width="1352" height="864" class="img_ev3q"></p>
<p>顺序存储（用数组来存储二叉树）的方式如图：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20200920200429452-8843273ac6225b830fdb836bf1e37580.png" width="954" height="842" class="img_ev3q"></p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p>如果父节点的数组下标是 i，那么它的左孩子就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i * 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>，右孩子就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∗</mo><mn>2</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i * 2 + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span>。</p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树的遍历方式">二叉树的遍历方式<a href="#二叉树的遍历方式" class="hash-link" aria-label="Direct link to 二叉树的遍历方式" title="Direct link to 二叉树的遍历方式">​</a></h3>
<p>主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历：一层一层的去遍历。</li>
</ol>
<p>这两种遍历是<strong>图论</strong>中最基本的两种遍历方式。</p>
<p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p>
<ul>
<li>深度优先遍历
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递 归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是<strong>中间节点的遍历顺序</strong>。</p>
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20200806191109896-be09dce90c3db995b4c63f5f69f0144b.png" width="1352" height="490" class="img_ev3q"></p>
<p>深度优先和广度优先的遍历方式：</p>
<ul>
<li>二叉树相关题目中，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。<strong>之前说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</li>
<li>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树的定义">二叉树的定义<a href="#二叉树的定义" class="hash-link" aria-label="Direct link to 二叉树的定义" title="Direct link to 二叉树的定义">​</a></h3>
<p>链式存储的二叉树节点的定义方式。</p>
<p>C++代码如下：</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">struct</span><span class="token plain"> </span><span class="token class-name" style="color:hsl(35, 99%, 36%)">TreeNode</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> val</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode </span><span class="token operator" style="color:hsl(221, 87%, 60%)">*</span><span class="token plain">left</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode </span><span class="token operator" style="color:hsl(221, 87%, 60%)">*</span><span class="token plain">right</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function" style="color:hsl(221, 87%, 60%)">TreeNode</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">:</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">val</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">left</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token constant" style="color:hsl(35, 99%, 36%)">NULL</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">right</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token constant" style="color:hsl(35, 99%, 36%)">NULL</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>java 代码：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class TreeNode {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode() {}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode(int val) { this.val = val; }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode(int val, TreeNode left, TreeNode right) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.left = left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.right = right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>二叉树的定义和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树的递归遍历">二叉树的递归遍历<a href="#二叉树的递归遍历" class="hash-link" aria-label="Direct link to 二叉树的递归遍历" title="Direct link to 二叉树的递归遍历">​</a></h2>
<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">144. 二叉树的前序遍历</a></p>
<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">94. 二叉树的中序遍历</a></p>
<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener noreferrer">145. 二叉树的后序遍历</a></p>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序、中序和后序</strong> 遍历。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//前序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        preorder(root, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void preorder(TreeNode root, List&lt;Integer&gt; result) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        result.add(root.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        preorder(root.left, result);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        preorder(root.right, result);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//中序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        inorder(root, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void inorder(TreeNode root, List&lt;Integer&gt; result){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        inorder(root.left, result);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        result.add(root.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        inorder(root.right, result);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//后序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        postorder(root, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void postorder(TreeNode root, List&lt;Integer&gt; result){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        postorder(root.left, result);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        postorder(root.right, result);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        result.add(root.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树的迭代遍历">二叉树的迭代遍历<a href="#二叉树的迭代遍历" class="hash-link" aria-label="Direct link to 二叉树的迭代遍历" title="Direct link to 二叉树的迭代遍历">​</a></h2>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代前序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode temp = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.right != null) deque.addFirst(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.left != null) deque.addFirst(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(temp.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代后序循环遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode temp = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.left != null) deque.addFirst(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.right != null) deque.addFirst(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(temp.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Collections.reverse(res);//翻转</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代中序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode temp = deque.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(temp.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.addFirst(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp = temp.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(deque.peek().right == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res.add(deque.poll().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek() == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(deque.peek().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.addFirst(deque.poll().right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="统一迭代法">统一迭代法<a href="#统一迭代法" class="hash-link" aria-label="Direct link to 统一迭代法" title="Direct link to 统一迭代法">​</a></h2>
<p>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//前序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode node = deque.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(deque.poll().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.addFirst(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.addFirst(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//中序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode node = deque.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(node.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.addFirst(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.addFirst(node);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.addFirst(null);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(node.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.addFirst(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek() != null) res.add(deque.poll().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//后序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode node = deque.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.addFirst(null);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(node.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.addFirst(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(node.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.addFirst(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }                </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek() != null) res.add(deque.poll().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="二叉树层序遍历">二叉树层序遍历<a href="#二叉树层序遍历" class="hash-link" aria-label="Direct link to 二叉树层序遍历" title="Direct link to 二叉树层序遍历">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="102二叉树的层序遍历">102.二叉树的层序遍历<a href="#102二叉树的层序遍历" class="hash-link" aria-label="Direct link to 102.二叉树的层序遍历" title="Direct link to 102.二叉树的层序遍历">​</a></h3>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode(root, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // checknode1(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return resList;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    //BFS 递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void checknode(TreeNode node, int deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deep++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(resList.size() &lt; deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.add(temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        resList.get(deep-1).add(node.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode(node.left, deep);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode(node.right, deep);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    //BFS 迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void checknode1(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(node);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().left != null) deque.offer(deque.peek().left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().right != null) deque.offer(deque.peek().right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp.add(deque.poll().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.add(temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="107二叉树的层次遍历-ii">107.二叉树的层次遍历 II<a href="#107二叉树的层次遍历-ii" class="hash-link" aria-label="Direct link to 107.二叉树的层次遍历 II" title="Direct link to 107.二叉树的层次遍历 II">​</a></h3>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // checknode(root, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // for(int i = resList.size()-1; i &gt;= 0; i--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //     res.add(resList.get(i));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode1(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return resList;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    //递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void checknode(TreeNode node, int deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deep++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(resList.size() &lt; deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.add(temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        resList.get(deep-1).add(node.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode(node.left, deep);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode(node.right, deep);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    //迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void checknode1(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(node);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().left != null) deque.offer(deque.peek().left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().right != null) deque.offer(deque.peek().right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp.add(deque.poll().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.addFirst(temp);//新遍历到的层插到头部, 这样就满足按照层次反序的要求</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>199.二叉树的右视图</p>
<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; rightSideView(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int deep = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(deque.peekLast().val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().left != null) deque.offer(deque.peek().left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().right != null) deque.offer(deque.peek().right); </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();               </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="637二叉树的层平均值">637.二叉树的层平均值<a href="#637二叉树的层平均值" class="hash-link" aria-label="Direct link to 637.二叉树的层平均值" title="Direct link to 637.二叉树的层平均值">​</a></h3>
<p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Double&gt; averageOfLevels(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Double&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int deep = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        double sum = (double)root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(sum/len);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(deque.peek().left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    sum += deque.peek().left.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(deque.peek().right); </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    sum += deque.peek().right.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="429n叉树的层序遍历">429.N叉树的层序遍历<a href="#429n叉树的层序遍历" class="hash-link" aria-label="Direct link to 429.N叉树的层序遍历" title="Direct link to 429.N叉树的层序遍历">​</a></h3>
<p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        checknode(root, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // checknode1(root);//迭代的写法类似</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return resList;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    //BFS 递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void checknode(Node node, int deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deep++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(resList.size() &lt; deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.add(temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        resList.get(deep-1).add(node.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Node a : node.children){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            checknode(a, deep);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="515在每个树行中找最大值">515.在每个树行中找最大值<a href="#515在每个树行中找最大值" class="hash-link" aria-label="Direct link to 515.在每个树行中找最大值" title="Direct link to 515.在每个树行中找最大值">​</a></h3>
<p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>您需要在二叉树的每一行中找到最大的值。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; largestValues(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max_num = root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(max_num);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            max_num = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(deque.peek().left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    max_num = max_num &gt; deque.peek().left.val ? max_num : deque.peek().left.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek().right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(deque.peek().right); </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    max_num = max_num &gt; deque.peek().right.val ? max_num : deque.peek().right.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="116填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针<a href="#116填充每个节点的下一个右侧节点指针" class="hash-link" aria-label="Direct link to 116.填充每个节点的下一个右侧节点指针" title="Direct link to 116.填充每个节点的下一个右侧节点指针">​</a></h3>
<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Node connect(Node root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Node cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur.left != null) deque.offer(cur.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur.right != null) deque.offer(cur.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                Node next = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next.left != null) deque.offer(next.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next.right != null) deque.offer(next.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cur.next = next;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cur = next;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            cur.next = null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="117填充每个节点的下一个右侧节点指针ii">117.填充每个节点的下一个右侧节点指针II<a href="#117填充每个节点的下一个右侧节点指针ii" class="hash-link" aria-label="Direct link to 117.填充每个节点的下一个右侧节点指针II" title="Direct link to 117.填充每个节点的下一个右侧节点指针II">​</a></h3>
<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>解答和上一题一样</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="104二叉树的  最大深度">104.二叉树的最大深度<a href="#104二叉树的最大深度" class="hash-link" aria-label="Direct link to 104.二叉树的最大深度" title="Direct link to 104.二叉树的最大深度">​</a></h3>
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>中前后是求高度的逻辑，前后中是求深度的逻辑</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(maxDepth(root.left), maxDepth(root.right)); + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归法(求深度法)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        ans(root, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void ans(TreeNode node, int temp){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        temp++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(res &lt; temp) res = temp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        ans(node.left, temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        ans(node.right, temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//深度回溯</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        ans(root, 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void ans(TreeNode node, int temp){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res = res &gt; temp ? res : temp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left == null &amp;&amp; node.right == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left != null) ans(node.left, temp+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.right != null) ans(node.right, temp+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode temp = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.left != null) deque.offer(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.right != null) deque.offer(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="111二叉树的最小深度">111.二叉树的最小深度<a href="#111二叉树的最小深度" class="hash-link" aria-label="Direct link to 111.二叉树的最小深度" title="Direct link to 111.二叉树的最小深度">​</a></h3>
<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int minDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.left == null &amp;&amp; root.right == null) return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.left != null &amp;&amp; root.right != null) return 1 + Math.min(minDepth(root.left),minDepth(root.right));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(root.left == null) return 1 + minDepth(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else return 1 + minDepth(root.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int minDepth(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                len--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode temp = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.left != null) deque.offer(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.right != null) deque.offer(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.left != null || temp.right != null){}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="226翻转二叉树">226.翻转二叉树<a href="#226翻转二叉树" class="hash-link" aria-label="Direct link to 226.翻转二叉树" title="Direct link to 226.翻转二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>翻转一棵二叉树。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">/**</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     * 前后序遍历都可以</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     */</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode invertTree(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        invertTree(root.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        invertTree(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        swapChildren(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void swapChildren(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode tmp = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = tmp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode invertTree(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.push(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len = deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(len-- &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode temp = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                swapChildren(temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.left != null) deque.offer(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.right != null) deque.offer(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void swapChildren(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode tmp = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = tmp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="101-对称二叉树">101. 对称二叉树<a href="#101-对称二叉树" class="hash-link" aria-label="Direct link to 101. 对称二叉树" title="Direct link to 101. 对称二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSymmetric(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return checknode(root.left, root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean checknode(TreeNode node1, TreeNode node2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node1 != null &amp;&amp; node2 != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return node1.val == node2.val &amp;&amp; checknode(node1.left, node2.right) &amp;&amp; checknode(node1.right, node2.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(node1 == null &amp;&amp; node2 == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSymmetric(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean res = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.addFirst(root.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode leftnode = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode rightnode = deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(leftnode == null &amp;&amp; rightnode == null) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(leftnode == null || rightnode == null || leftnode.val != rightnode.val) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.addFirst(leftnode.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.addLast(rightnode.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.addFirst(leftnode.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.addLast(rightnode.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类似题目">类似题目<a href="#类似题目" class="hash-link" aria-label="Direct link to 类似题目" title="Direct link to 类似题目">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="100相同的树"><a href="https://leetcode.cn/problems/same-tree/" target="_blank" rel="noopener noreferrer">100.相同的树</a><a href="#100相同的树" class="hash-link" aria-label="Direct link to 100相同的树" title="Direct link to 100相同的树">​</a></h4>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值  ，则认为它们是相同的。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSameTree(TreeNode p, TreeNode q) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return checknode(p, q);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean checknode(TreeNode node1, TreeNode node2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node1 != null &amp;&amp; node2 != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return node1.val == node2.val &amp;&amp; checknode(node1.left, node2.left) &amp;&amp; checknode(node1.right, node2.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(node1 == null &amp;&amp; node2 == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="572另一个树的子树"><a href="https://leetcode.cn/problems/subtree-of-another-tree/" target="_blank" rel="noopener noreferrer">572.另一个树的子树</a><a href="#572另一个树的子树" class="hash-link" aria-label="Direct link to 572另一个树的子树" title="Direct link to 572另一个树的子树">​</a></h4>
<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//dfs递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSubtree(TreeNode root, TreeNode subRoot) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dfs(root, subRoot);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean dfs(TreeNode node1, TreeNode node2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node1 == null || node2 == null) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return checknode(node1, node2) || dfs(node1.left, node2) || dfs(node1.right, node2);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean checknode(TreeNode node1, TreeNode node2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node1 != null &amp;&amp; node2 != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return node1.val == node2.val &amp;&amp; checknode(node1.left, node2.left) &amp;&amp; checknode(node1.right, node2.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(node1 == null &amp;&amp; node2 == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="222完全二叉树的节点个数">222.完全二叉树的节点个数<a href="#222完全二叉树的节点个数" class="hash-link" aria-label="Direct link to 222.完全二叉树的节点个数" title="Direct link to 222.完全二叉树的节点个数">​</a></h2>
<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int countNodes(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return countNodes(root.left) + countNodes(root.right) + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//满二叉树</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     * 针对完全二叉树的解法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     *</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     * 满二叉树的结点数为：2^depth - 1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     */</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int countNodes(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode left = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode right = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while (left != null) {  // 求左子树深度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            left = left.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            leftDepth++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while (right != null) { // 求右子树深度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            right = right.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            rightDepth++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (leftDepth == rightDepth) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return (2 &lt;&lt; leftDepth) - 1; // 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return countNodes(root.left) + countNodes(root.right) + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="110平衡二叉树">110.平衡二叉树<a href="#110平衡二叉树" class="hash-link" aria-label="Direct link to 110.平衡二叉树" title="Direct link to 110.平衡二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isBalanced(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return compare(root.left, root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean compare(TreeNode node1, TreeNode node2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node1 == null &amp;&amp; node2 == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(Math.abs(getHight(node1) - getHight(node2)) &gt; 1) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node1 == null || node2 == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return compare(node1.left, node1.right) &amp;&amp; compare(node2.left, node2.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int getHight(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(getHight(node.left), getHight(node.right)) + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归2</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isBalanced(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return getHight(root) != -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int getHight(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int lefthight = getHight(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(lefthight == -1) return -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int righthight = getHight(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(righthight == -1) return -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(Math.abs(righthight - lefthight) &gt; 1) return -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(lefthight, righthight) + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="257-二叉树的所有路径">257. 二叉树的所有路径<a href="#257-二叉树的所有路径" class="hash-link" aria-label="Direct link to 257. 二叉树的所有路径" title="Direct link to 257. 二叉树的所有路径">​</a></h2>
<p><a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; binaryTreePaths(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;String&gt; res = new ArrayList&lt;&gt;();        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; paths = new  ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traversal(root, paths, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void traversal(TreeNode node, List&lt;Integer&gt; paths, List&lt;String&gt; res){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        paths.add(node.val);//前序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left == null &amp;&amp; node.right == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            StringBuilder sb = new StringBuilder();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 0; i &lt; paths.size() - 1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                sb.append(paths.get(i)).append(&quot;-&gt;&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            sb.append(paths.get(paths.size() - 1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(sb.toString());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            traversal(node.left, paths, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            paths.remove(paths.size() - 1);//回溯</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            traversal(node.right, paths, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            paths.remove(paths.size() - 1);//回溯</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归2</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; binaryTreePaths(TreeNode root) {          </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deal(root, &quot;&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void deal(TreeNode node, String s){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int num = node.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        String temp = new String();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left == null &amp;&amp; node.right == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add((new StringBuilder(s).append(num)).toString());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp = (new StringBuilder(s).append(num).append(&quot;-&gt;&quot;)).toString();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deal(node.left, temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp = (new StringBuilder(s).append(num).append(&quot;-&gt;&quot;)).toString();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deal(node.right, temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归3</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; binaryTreePaths(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //到达叶子节点，把路径加入到集合中</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root.left == null &amp;&amp; root.right == null) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(root.val + &quot;&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //遍历左子节点的路径</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (String path : binaryTreePaths(root.left)) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(root.val + &quot;-&gt;&quot; + path);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //遍历右子节点的路径</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (String path : binaryTreePaths(root.right)) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(root.val + &quot;-&gt;&quot; + path);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> //迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; binaryTreePaths(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Stack&lt;Object&gt; stack = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        stack.push(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        stack.push(root.val + &quot;&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!stack.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            String paths = (String) stack.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode node = (TreeNode) stack.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node.left == null &amp;&amp; node.right == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res.add(paths);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                stack.push(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                stack.push(paths + &quot;-&gt;&quot; + node.left.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(node.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                stack.push(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                stack.push(paths + &quot;-&gt;&quot; + node.right.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="404左叶子之和">404.左叶子之和<a href="#404左叶子之和" class="hash-link" aria-label="Direct link to 404.左叶子之和" title="Direct link to 404.左叶子之和">​</a></h2>
<p><a href="https://leetcode.cn/problems/sum-of-left-leaves/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int sumOfLeftLeaves(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) res += root.left.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int sumOfLeftLeaves(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode temp = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.offer(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.left.left == null &amp;&amp; temp.left.right == null) res += temp.left.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.right != null) deque.offer(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="513找树左下角的值">513.找树左下角的值<a href="#513找树左下角的值" class="hash-link" aria-label="Direct link to 513.找树左下角的值" title="Direct link to 513.找树左下角的值">​</a></h2>
<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树， 在树的最后一行找到最左边的值。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int Deep = -1, Value = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findBottomLeftValue(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        findLeftValue(root, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Value;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void findLeftValue(TreeNode node, int depth){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left == null &amp;&amp; node.left == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(depth &gt; Deep){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                Deep = depth;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                Value = node.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left != null) findLeftValue(node.left, depth + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.right != null) findLeftValue(node.right, depth + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findBottomLeftValue(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int len =deque.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res = deque.peek().val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(;len &gt; 0; len--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode temp = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.left != null) deque.offer(temp.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(temp.right != null) deque.offer(temp.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="112-路径总和">112. 路径总和<a href="#112-路径总和" class="hash-link" aria-label="Direct link to 112. 路径总和" title="Direct link to 112. 路径总和">​</a></h2>
<p><a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean hasPathSum(TreeNode root, int targetSum) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int temp = root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.left == null &amp;&amp; root.right == null) return temp == targetSum;        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return hasPathSum(root.left, targetSum - temp) || hasPathSum(root.right, targetSum - temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类似题">类似题<a href="#类似题" class="hash-link" aria-label="Direct link to 类似题" title="Direct link to 类似题">​</a></h3>
<ol start="113">
<li>路径总和ii</li>
</ol>
<p><a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traserval(root, targetSum);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void traserval(TreeNode node, int count){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        path.offer(node.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        count -= node.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.left ==null &amp;&amp; node.right == null &amp;&amp; count == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new LinkedList&lt;&gt;(path));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traserval(node.left, count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traserval(node.right,count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        path.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="106从中序与后序遍历序列构造二叉树">106.从中序与后序遍历序列构造二叉树<a href="#106从中序与后序遍历序列构造二叉树" class="hash-link" aria-label="Direct link to 106.从中序与后序遍历序列构造二叉树" title="Direct link to 106.从中序与后序遍历序列构造二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode buildTree(int[] inorder, int[] postorder) {        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; inorder.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            map.put(inorder[i], i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return findNode(inorder, 0, inorder.length, postorder, 0, postorder.length);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder,int postBegin, int postEnd){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(inBegin &gt;= inEnd || postBegin &gt;= postEnd){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int rootIndex = map.get(postorder[postEnd - 1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode root = new TreeNode(inorder[rootIndex]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int lenOfLeft = rootIndex - inBegin;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类似题-1">类似题<a href="#类似题-1" class="hash-link" aria-label="Direct link to 类似题" title="Direct link to 类似题">​</a></h3>
<p>105.从前序与中序遍历序列构造二叉树</p>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode buildTree(int[] preorder, int[] inorder) {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; inorder.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            map.put(inorder[i], i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return findNode(inorder, 0, inorder.length, preorder, 0, preorder.length);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] preorder,int preBegin, int preEnd){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(inBegin &gt;= inEnd || preBegin &gt;= preEnd){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int rootIndex = map.get(preorder[preBegin]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode root = new TreeNode(inorder[rootIndex]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int lenOfLeft = rootIndex - inBegin;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = findNode(inorder, inBegin, rootIndex, preorder, preBegin + 1, preBegin + lenOfLeft + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = findNode(inorder, rootIndex + 1, inEnd, preorder, preBegin + lenOfLeft + 1, preEnd);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="654最大二叉树">654.最大二叉树<a href="#654最大二叉树" class="hash-link" aria-label="Direct link to 654.最大二叉树" title="Direct link to 654.最大二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目地址</a></p>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode constructMaximumBinaryTree(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return construct(nums, 0, nums.length);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private TreeNode construct(int[] nums, int left, int right){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(right &lt;= left) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max_num = left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = left+1; i &lt; right; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[max_num] &lt; nums[i]) max_num = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode node = new TreeNode(nums[max_num]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        node.left = construct(nums, left, max_num);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        node.right = construct(nums, max_num+1, right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode constructMaximumBinaryTree(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null &amp;&amp; nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : nums){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode cur = new TreeNode(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(!deque.isEmpty() &amp;&amp; deque.peek().val &lt; i){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode node = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cur.left = node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    TreeNode top = deque.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(top.val &gt; i) cur.left = node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!deque.isEmpty()) deque.peek().right = cur;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.push(cur);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(deque.size() &gt; 1) deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="617合并二叉树">617.合并二叉树<a href="#617合并二叉树" class="hash-link" aria-label="Direct link to 617.合并二叉树" title="Direct link to 617.合并二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root1 == null) return root2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root2 == null) return root1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode root = new TreeNode(root1.val + root2.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = mergeTrees(root1.left, root2.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = mergeTrees(root1.right, root2.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="700二叉搜索树中的搜索">700.二叉搜索树中的搜索<a href="#700二叉搜索树中的搜索" class="hash-link" aria-label="Direct link to 700.二叉搜索树中的搜索" title="Direct link to 700.二叉搜索树中的搜索">​</a></h2>
<p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目地址</a></p>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode searchBST(TreeNode root, int val) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null || root.val == val) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode node = searchBST(root.left, val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node != null) return node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return searchBST(root.right, val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//利用BST的性质优化</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode searchBST(TreeNode root, int val) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null || root.val == val) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.val &gt; val) return searchBST(root.left, val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else return searchBST(root.right, val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="98验证二叉搜索树">98.验证二叉搜索树<a href="#98验证二叉搜索树" class="hash-link" aria-label="Direct link to 98.验证二叉搜索树" title="Direct link to 98.验证二叉搜索树">​</a></h2>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isValidBST(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return checkNode(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean checkNode(TreeNode node, long left, long right){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node.val &gt;= right || node.val &lt;= left) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return checkNode(node.left, left, node.val) &amp;&amp; checkNode(node.right, node.val, right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="530二叉搜索树的最小绝对差">530.二叉搜索树的最小绝对差<a href="#530二叉搜索树的最小绝对差" class="hash-link" aria-label="Direct link to 530.二叉搜索树的最小绝对差" title="Direct link to 530.二叉搜索树的最小绝对差">​</a></h2>
<p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//中序递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int res = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private TreeNode pre;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int getMinimumDifference(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traversal(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void traversal(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traversal(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(pre != null) res = Math.min(res, node.val - pre.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        pre = node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        traversal(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//中序迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int getMinimumDifference(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode pre = null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.push(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode cur = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(cur.right != null) deque.push(cur.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(cur);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(null);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(cur.left != null) deque.push(cur.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode temp = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(pre != null) res = Math.min(res, temp.val - pre.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                pre = temp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="501二叉搜索树中的众数">501.二叉搜索树中的众数<a href="#501二叉搜索树中的众数" class="hash-link" aria-label="Direct link to 501.二叉搜索树中的众数" title="Direct link to 501.二叉搜索树中的众数">​</a></h2>
<p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] findMode(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return list.stream().mapToInt(Integer::intValue).toArray();;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        searchBST(root, map);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; maplist = map.entrySet().stream()</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            .sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            .collect(Collectors.toList());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        list.add(maplist.get(0).getKey());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; maplist.size(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(maplist.get(i).getValue() == maplist.get(i - 1).getValue()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                list.add(maplist.get(i).getKey());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return list.stream().mapToInt(Integer::intValue).toArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void searchBST(TreeNode node, Map&lt;Integer, Integer&gt; map){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode cur = node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        map.put(cur.val, map.getOrDefault(cur.val, 0) + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        searchBST(cur.left, map);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        searchBST(cur.right, map);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//优化</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int count;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int max_count;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    TreeNode pre;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; resList = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] findMode(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        max_count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        findMode1(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[resList.size()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; resList.size(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res[i] = resList.get(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void findMode1(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        findMode1(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(pre == null || node.val == pre.val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            count = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(count &gt; max_count){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.clear();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            max_count = count;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.add(node.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(count == max_count) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            resList.add(node.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        pre = node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        findMode1(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先<a href="#236-二叉树的最近公共祖先" class="hash-link" aria-label="Direct link to 236. 二叉树的最近公共祖先" title="Direct link to 236. 二叉树的最近公共祖先">​</a></h2>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归，终止条件是找到p或者q</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null || root == q || root == p) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode res = root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(left == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(right == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//迭代</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null || root == q || root == p) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode cur = root, pre = null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(cur != null || !deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(cur != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(cur);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cur = cur.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }// 子树的最左边的节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            cur = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur.right == null || cur.right == pre){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(cur == p || cur == q){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if((cur.left != null &amp;&amp; cur.left.val == max) || (cur.right != null &amp;&amp; cur.right.val == max)) return cur;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cur.val = max;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                // p/q是 左/右 , 返回中</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(cur.left != null &amp;&amp; cur.left.val == max &amp;&amp; cur.right != null &amp;&amp; cur.right.val == max) return cur;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                // MAX_VALUE 往上传递</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if((cur.left != null &amp;&amp; cur.left.val == max) || (cur.right != null &amp;&amp; cur.right.val == max)) cur.val = max;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                pre = cur;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cur = null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else{//存在右二叉树没有遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(cur);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cur = cur.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先<a href="#235-二叉搜索树的最近公共祖先" class="hash-link" aria-label="Direct link to 235. 二叉搜索树的最近公共祖先" title="Direct link to 235. 二叉搜索树的最近公共祖先">​</a></h2>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null || root == q || root == p) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return lowestCommonAncestor(root.right, p, q);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return lowestCommonAncestor(root.left, p, q);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="701二叉搜索树中的插入操作">701.二叉搜索树中的插入操作<a href="#701二叉搜索树中的插入操作" class="hash-link" aria-label="Direct link to 701.二叉搜索树中的插入操作" title="Direct link to 701.二叉搜索树中的插入操作">​</a></h2>
<p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode insertIntoBST(TreeNode root, int val) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null || root.val == val) return new TreeNode(val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.val &gt; val) root.left = insertIntoBST(root.left, val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else root.right = insertIntoBST(root.right, val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="450删除二叉搜索树中的节点">450.删除二叉搜索树中的节点<a href="#450删除二叉搜索树中的节点" class="hash-link" aria-label="Direct link to 450.删除二叉搜索树中的节点" title="Direct link to 450.删除二叉搜索树中的节点">​</a></h2>
<p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode deleteNode(TreeNode root, int key) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.val == key){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            TreeNode left = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(root.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                TreeNode right = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                root = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                while(root.left != null) root = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                root.left = left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                left = right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.val &gt; key) root.left = deleteNode(root.left, key);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.val &lt; key) root.right = deleteNode(root.right, key);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="669-修剪二叉搜索树">669. 修剪二叉搜索树<a href="#669-修剪二叉搜索树" class="hash-link" aria-label="Direct link to 669. 修剪二叉搜索树" title="Direct link to 669. 修剪二叉搜索树">​</a></h2>
<p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode trimBST(TreeNode root, int low, int high) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = trimBST(root.left, low, high);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = trimBST(root.right, low, high);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root.val &lt; low) root = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(root.val &gt; high) root = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="108将有序数组转换为二叉搜索树">108.将有序数组转换为二叉搜索树<a href="#108将有序数组转换为二叉搜索树" class="hash-link" aria-label="Direct link to 108.将有序数组转换为二叉搜索树" title="Direct link to 108.将有序数组转换为二叉搜索树">​</a></h2>
<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode sortedArrayToBST(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode root = traversal(nums, 0, nums.length-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private TreeNode traversal(int[] nums, int left, int right){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(left &gt; right) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int mid1 = (right + left) / 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode node = new TreeNode(nums[mid1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        node.left = traversal(nums, left, mid1-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        node.right = traversal(nums, mid1+1, right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return node;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="538把二叉搜索树转换为累加树">538.把二叉搜索树转换为累加树<a href="#538把二叉搜索树转换为累加树" class="hash-link" aria-label="Direct link to 538.把二叉搜索树转换为累加树" title="Direct link to 538.把二叉搜索树转换为累加树">​</a></h2>
<p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode convertBST(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.right = convertBST(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        TreeNode node = root.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(node.left != null) node = node.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            root.val += node.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        node = root.left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(node.right != null) node = node.right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            node.val += root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        root.left = convertBST(root.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//递归2</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public TreeNode convertBST(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        convertBST1(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return root;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void convertBST1(TreeNode node){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        convertBST1(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        node.val += sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        sum = node.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        convertBST1(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>二叉树分类：</p>
<ul>
<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>
<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li>
<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>
</ul>
<p>注意在普通二叉树的属性中，一般为后序，例如单纯求深度就用前序，<a href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html" target="_blank" rel="noopener noreferrer">二叉树：找所有路径 </a>也用了前序，这是为了方便让父节点指向子节点。</p>
<p>所以求普通二叉树的属性还是要具体问题具体分析。</p>
<p>二叉树专题汇聚为一张图：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/21412-d0cfea8662fd39d30226dc4b6de74236.png" width="1660" height="1050" class="img_ev3q"></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/码农/刷题记录/栈与队列/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">栈与队列</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/码农/刷题记录/回溯/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">回溯</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础知识" class="table-of-contents__link toc-highlight">基础知识</a><ul><li><a href="#二叉树的种类" class="table-of-contents__link toc-highlight">二叉树的种类</a></li><li><a href="#二叉树的存储方式" class="table-of-contents__link toc-highlight">二叉树的存储方式</a></li><li><a href="#二叉树的遍历方式" class="table-of-contents__link toc-highlight">二叉树的遍历方式</a></li><li><a href="#二叉树的定义" class="table-of-contents__link toc-highlight">二叉树的定义</a></li></ul></li><li><a href="#二叉树的递归遍历" class="table-of-contents__link toc-highlight">二叉树的递归遍历</a></li><li><a href="#二叉树的迭代遍历" class="table-of-contents__link toc-highlight">二叉树的迭代遍历</a></li><li><a href="#统一迭代法" class="table-of-contents__link toc-highlight">统一迭代法</a></li><li><a href="#二叉树层序遍历" class="table-of-contents__link toc-highlight">二叉树层序遍历</a><ul><li><a href="#102二叉树的层序遍历" class="table-of-contents__link toc-highlight">102.二叉树的层序遍历</a></li><li><a href="#107二叉树的层次遍历-ii" class="table-of-contents__link toc-highlight">107.二叉树的层次遍历 II</a></li><li><a href="#637二叉树的层平均值" class="table-of-contents__link toc-highlight">637.二叉树的层平均值</a></li><li><a href="#429n叉树的层序遍历" class="table-of-contents__link toc-highlight">429.N叉树的层序遍历</a></li><li><a href="#515在每个树行中找最大值" class="table-of-contents__link toc-highlight">515.在每个树行中找最大值</a></li><li><a href="#116填充每个节点的下一个右侧节点指针" class="table-of-contents__link toc-highlight">116.填充每个节点的下一个右侧节点指针</a></li><li><a href="#117填充每个节点的下一个右侧节点指针ii" class="table-of-contents__link toc-highlight">117.填充每个节点的下一个右侧节点指针II</a></li><li><a href="#104二叉树的最大深度" class="table-of-contents__link toc-highlight">104.二叉树的最大深度</a></li><li><a href="#111二叉树的最小深度" class="table-of-contents__link toc-highlight">111.二叉树的最小深度</a></li></ul></li><li><a href="#226翻转二叉树" class="table-of-contents__link toc-highlight">226.翻转二叉树</a></li><li><a href="#101-对称二叉树" class="table-of-contents__link toc-highlight">101. 对称二叉树</a><ul><li><a href="#类似题目" class="table-of-contents__link toc-highlight">类似题目</a></li></ul></li><li><a href="#222完全二叉树的节点个数" class="table-of-contents__link toc-highlight">222.完全二叉树的节点个数</a></li><li><a href="#110平衡二叉树" class="table-of-contents__link toc-highlight">110.平衡二叉树</a></li><li><a href="#257-二叉树的所有路径" class="table-of-contents__link toc-highlight">257. 二叉树的所有路径</a></li><li><a href="#404左叶子之和" class="table-of-contents__link toc-highlight">404.左叶子之和</a></li><li><a href="#513找树左下角的值" class="table-of-contents__link toc-highlight">513.找树左下角的值</a></li><li><a href="#112-路径总和" class="table-of-contents__link toc-highlight">112. 路径总和</a><ul><li><a href="#类似题" class="table-of-contents__link toc-highlight">类似题</a></li></ul></li><li><a href="#106从中序与后序遍历序列构造二叉树" class="table-of-contents__link toc-highlight">106.从中序与后序遍历序列构造二叉树</a><ul><li><a href="#类似题-1" class="table-of-contents__link toc-highlight">类似题</a></li></ul></li><li><a href="#654最大二叉树" class="table-of-contents__link toc-highlight">654.最大二叉树</a></li><li><a href="#617合并二叉树" class="table-of-contents__link toc-highlight">617.合并二叉树</a></li><li><a href="#700二叉搜索树中的搜索" class="table-of-contents__link toc-highlight">700.二叉搜索树中的搜索</a></li><li><a href="#98验证二叉搜索树" class="table-of-contents__link toc-highlight">98.验证二叉搜索树</a></li><li><a href="#530二叉搜索树的最小绝对差" class="table-of-contents__link toc-highlight">530.二叉搜索树的最小绝对差</a></li><li><a href="#501二叉搜索树中的众数" class="table-of-contents__link toc-highlight">501.二叉搜索树中的众数</a></li><li><a href="#236-二叉树的最近公共祖先" class="table-of-contents__link toc-highlight">236. 二叉树的最近公共祖先</a></li><li><a href="#235-二叉搜索树的最近公共祖先" class="table-of-contents__link toc-highlight">235. 二叉搜索树的最近公共祖先</a></li><li><a href="#701二叉搜索树中的插入操作" class="table-of-contents__link toc-highlight">701.二叉搜索树中的插入操作</a></li><li><a href="#450删除二叉搜索树中的节点" class="table-of-contents__link toc-highlight">450.删除二叉搜索树中的节点</a></li><li><a href="#669-修剪二叉搜索树" class="table-of-contents__link toc-highlight">669. 修剪二叉搜索树</a></li><li><a href="#108将有序数组转换为二叉搜索树" class="table-of-contents__link toc-highlight">108.将有序数组转换为二叉搜索树</a></li><li><a href="#538把二叉搜索树转换为累加树" class="table-of-contents__link toc-highlight">538.把二叉搜索树转换为累加树</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>