<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-码农/刷题记录/动态规划" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">动态规划 | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.middiy.top/码农/刷题记录/动态规划/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="动态规划 | Coisini"><meta data-rh="true" name="description" content="基础知识"><meta data-rh="true" property="og:description" content="基础知识"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.middiy.top/码农/刷题记录/动态规划/"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/动态规划/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/动态规划/" hreflang="x-default"><link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.53ea8373.css">
<script src="/assets/js/runtime~main.6ed6c215.js" defer="defer"></script>
<script src="/assets/js/main.9597ad90.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/分享/">Sharing</a><button aria-label="Expand sidebar category &#x27;Sharing&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/读书笔记/">读书笔记</a><button aria-label="Expand sidebar category &#x27;读书笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/技巧/">技巧</a><button aria-label="Expand sidebar category &#x27;技巧&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/数学/">数学</a><button aria-label="Expand sidebar category &#x27;数学&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/思考/">思考</a><button aria-label="Expand sidebar category &#x27;思考&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/学习/">学习</a><button aria-label="Expand sidebar category &#x27;学习&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/码农/"> 码农</a><button aria-label="Collapse sidebar category &#x27;码农&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/基础知识/">基础知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/面试题/">面试题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/数组/">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/链表/">链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/哈希表/">哈希表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/字符串/">字符串</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/双指针/">双指针总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/栈与队列/">栈与队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/二叉树/">二叉树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/回溯/">回溯</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/贪心算法/">贪心算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/码农/刷题记录/动态规划/">动态规划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/单调栈/">单调栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/图论/">图论</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/高级数据结构/">高级数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/其他/">其他</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/转码/">转码经验</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/毛选/">毛选</a><button aria-label="Expand sidebar category &#x27;毛选&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/码农/"><span itemprop="name">码农</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">动态规划</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>动态规划</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础知识">基础知识<a href="#基础知识" class="hash-link" aria-label="Direct link to 基础知识" title="Direct link to 基础知识">​</a></h2>
<p>题目分类：</p>
<!-- -->
<p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>
<p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的，</p>
<p>动态规划的三要素:</p>
<ol>
<li>最优子结构</li>
<li>状态转移方程((包含最优子结构))</li>
<li>边界</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="509-斐波那契数">509. 斐波那契数<a href="#509-斐  波那契数" class="hash-link" aria-label="Direct link to 509. 斐波那契数" title="Direct link to 509. 斐波那契数">​</a></h2>
<p><a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int fib(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(n == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(n &lt;= 2) return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 2; i &lt;= n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int temp = dp[0] + dp[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0] = dp[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[1] = temp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="70-爬楼梯">70. 爬楼梯<a href="#70-爬楼梯" class="hash-link" aria-label="Direct link to 70. 爬楼梯" title="Direct link to 70. 爬楼梯">​</a></h2>
<p><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int climbStairs(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 2; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = dp[i-1] + dp[i-2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="746-使用最小花费爬楼梯">746. 使用最小花费爬楼梯<a href="#746-使用最小花费爬楼梯" class="hash-link" aria-label="Direct link to 746. 使用最小花费爬楼梯" title="Direct link to 746. 使用最小花费爬楼梯">​</a></h2>
<p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p><strong>旧题目描述</strong>：</p>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int minCostClimbingStairs(int[] cost) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[cost.length+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 2; i &lt; dp.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[dp.length-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="62不同路径">62.不同路径<a href="#62不同路径" class="hash-link" aria-label="Direct link to 62.不同路径" title="Direct link to 62.不同路径">​</a></h2>
<p><a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="数理方法"><strong>数理方法</strong><a href="#数理方法" class="hash-link" aria-label="Direct link to 数理方法" title="Direct link to 数理方法">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int uniquePaths(int m, int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        long res = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int a = n, b = 1; b &lt; m; a++,b++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res = res*a/b;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return (int)res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="dp"><strong>dp</strong><a href="#dp" class="hash-link" aria-label="Direct link to dp" title="Direct link to dp">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int uniquePaths(int m, int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] f = new int[m][n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; m; ++i) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            f[i][0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int j = 0; j &lt; n; ++j) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            f[0][j] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 1; i &lt; m; ++i) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 1; j &lt; n; ++j) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                f[i][j] = f[i - 1][j] + f[i][j - 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return f[m - 1][n - 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="dp压缩"><strong>dp压缩</strong><a href="#dp压缩" class="hash-link" aria-label="Direct link to dp压缩" title="Direct link to dp压缩">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int uniquePaths(int m, int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 在二维dp数组中，当前值的计算只依赖正上方和正左方，因此可以压缩成一维数组。</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 初始化，第一行只能从正左方跳过来，所以只有一条路径。</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(dp, 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 1; i &lt; m; i ++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 第一列也只有一条路，不用迭代，所以从第二列开始</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] += dp[j - 1]; // dp[j] = dp[j] (正上方)+ dp[j - 1] (正左方)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n - 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="63-不同路径-ii">63. 不同路径 II<a href="#63-不同路径-ii" class="hash-link" aria-label="Direct link to 63. 不同路径 II" title="Direct link to 63. 不同路径 II">​</a></h2>
<p><a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="dp-1"><strong>dp</strong><a href="#dp-1" class="hash-link" aria-label="Direct link to dp-1" title="Direct link to dp-1">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int uniquePathsWithObstacles(int[][] obstacleGrid) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(obstacleGrid[0][0] == 1) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; dp.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(obstacleGrid[i][0] == 1) break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 1; j &lt; dp[0].length; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(obstacleGrid[0][j] == 1) break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0][j] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; dp.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt; dp[0].length; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[dp.length-1][dp[0].length-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="dp压缩-1"><strong>dp压缩</strong><a href="#dp压缩-1" class="hash-link" aria-label="Direct link to dp压缩-1" title="Direct link to dp压缩-1">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int uniquePathsWithObstacles(int[][] obstacleGrid) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(obstacleGrid[0][0] == 1) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int m = obstacleGrid.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n =obstacleGrid[0].length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n &amp;&amp; obstacleGrid[0][i] != 1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; m; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(obstacleGrid[i][j] == 1) dp[j] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else if(j &gt; 0) dp[j] += dp[j-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="343-整数拆分">343. 整数拆分<a href="#343-整数拆分" class="hash-link" aria-label="Direct link to 343. 整数拆分" title="Direct link to 343. 整数拆分">​</a></h2>
<p><a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="数学原理"><strong>数学原理</strong><a href="#数学原理" class="hash-link" aria-label="Direct link to 数学原理" title="Direct link to 数学原理">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int integerBreak(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(n == 2) return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(n == 3) return 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(n &gt; 4){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            n -= 3;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res *= 3;// 通过数学原理拆出更多的3乘积越大</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return n * res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="贪心"><strong>贪心</strong><a href="#贪心" class="hash-link" aria-label="Direct link to 贪心" title="Direct link to 贪心">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int integerBreak(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[2] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 2; i &lt; n+1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= i - j; j++){// 这里的 j 其实最大值为 i-j,再大只不过是重复而已</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="96不同的二叉搜索树">96.不同的二叉搜索树<a href="#96不同的二叉搜索树" class="hash-link" aria-label="Direct link to 96.不同的二叉搜索树" title="Direct link to 96.不同的二叉搜索树">​</a></h2>
<p><a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int numTrees(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int  i = 2; i &lt; dp.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt;= i-1; j++) dp[i] += (dp[j] * dp[i-j-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="01背包理论基础">🌟01背包理论基础<a href="#01背包理论基础" class="hash-link" aria-label="Direct link to 🌟01背包理论基础" title="Direct link to 🌟01背包理论基础">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1046" target="_blank" rel="noopener noreferrer">题目</a></p>
<ul>
<li>
<p>对于二维dp数组
先遍历物品还是先遍历背包重量都可以，但是<strong>先遍历物品</strong>更好理解。两个for循环都是正序遍历</p>
</li>
<li>
<p>对于一维动态dp数组
由于数组会被覆盖，<strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品i就会被重复加入多次！同时一定要先遍历物品，不然的话，背包j就会多次去遍历小背包（出现排列组合）。<strong>如果求组合数就是外层for循环遍历物  品，内层for遍历背包；如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20241202184146297" src="/assets/images/image-20241202184146297-2687fc39842b6221281a16d8a7863a7f.png" width="2648" height="5000" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="dp-2"><strong>dp</strong><a href="#dp-2" class="hash-link" aria-label="Direct link to dp-2" title="Direct link to dp-2">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main (String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int m = in.nextInt();//items</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = in.nextInt();//space</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] bag = new int[m][2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; m; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            bag[i][0] = in.nextInt();//cost</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; m; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            bag[i][1] = in.nextInt();//value</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[m][n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 初始化第一行</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = bag[0][0]; i &lt; n+1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0][i] = bag[0][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 1; j &lt; m; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 1; i &lt;= n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i &gt;= bag[j][0]) dp[j][i] = Math.max(dp[j-1][i - bag[j][0]]+bag[j][1], dp[j-1][i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else dp[j][i] = dp[j-1][i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(dp[m-1][n]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="动态数组"><strong>动态数组</strong><a href="#动态数组" class="hash-link" aria-label="Direct link to 动态数组" title="Direct link to 动态数组">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main (String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int m = in.nextInt();//items</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = in.nextInt();//space</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] bag = new int[m][2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; m; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            bag[i][0] = in.nextInt();//cost</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; m; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            bag[i][1] = in.nextInt();//value</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 创建一个动态规划数组 dp，初始值为 0</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 外层循环遍历每个类型的研究材料</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 0; j &lt; m; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = n; i &gt;= 1; i--){// 内层循环从 n 空间逐渐减少到当前研究材料所占空间</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                // 考虑当前研究材料选择和不选择的情况，选择最大值</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i &gt;= bag[j][0]) dp[i] = Math.max(dp[i-bag[j][0]]+bag[j][1], dp[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(dp[n]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="416-分割等和子集">416. 分割等和子集<a href="#416-分割等和子集" class="hash-link" aria-label="Direct link to 416. 分割等和子集" title="Direct link to 416. 分割等和子集">​</a></h2>
<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>题目难易：中等</p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean canPartition(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 1 || nums.length == 0) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = nums.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len; i++) sum += nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if((sum &amp; 1) == 1) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[sum/2+1];//背包的最大价值</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = sum/2; j &gt;= nums[i]; j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);//比较加不加这个数，cost=value表示dp最大value就是背包的空间</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(dp[sum/2] == sum/2) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[sum/2] == sum/2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1049最后一块石头的重量ii">1049.最后一块石头的重量II<a href="#1049最后一块石头的重量ii" class="hash-link" aria-label="Direct link to 1049.最后一块石头的重量II" title="Direct link to 1049.最后一块石头的重量II">​</a></h2>
<p><a href="https://leetcode.cn/problems/last-stone-weight-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>题目难度：中等</p>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果 x == y，那么两块石头都会被完全粉碎；</p>
<p>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int lastStoneWeightII(int[] stones) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(stones == null || stones.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = stones.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len; i++) sum += stones[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[sum/2+1];//背包的最大价值</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = sum/2; j &gt;= stones[i]; j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] = Math.max(dp[j], dp[j-stones[i]] + stones[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res = Math.min(res, Math.abs(sum-2*dp[sum/2]));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(res &lt; 2) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="494目标和">494.目标和<a href="#494目标和" class="hash-link" aria-label="Direct link to 494.目标和" title="Direct link to 494.目标和">​</a></h2>
<p><a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>难度：中等</p>
<p>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findTargetSumWays(int[] nums, int target) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = nums.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = target;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len; i++) sum += nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(sum &lt; 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if((sum &amp; 1) == 1) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[sum/2+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;//减到0增加组合数1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = sum/2; j &gt;= nums[i]; j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] += dp[j-nums[i]];//前i个数中，和为j的组合数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[sum/2];//满足条件的索引为sum/2</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="474一和零">474.一和零<a href="#474一和零" class="hash-link" aria-label="Direct link to 474.一和零" title="Direct link to 474.一和零">​</a></h2>
<p><a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//二维背包</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findMaxForm(String[] strs, int m, int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[m+1][n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; strs.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int[] nums = check(strs[i], m, n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = m; nums[0] &lt;= j; j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int k = n; nums[1] &lt;= k; k--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[j][k] = Math.max(dp[j][k], dp[j-nums[0]][k-nums[1]] + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[m][n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] check(String s, int m, int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] nums = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(char c : s.toCharArray()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(c == &#x27;0&#x27;) nums[0]++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else if(c == &#x27;1&#x27;) nums[1]++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[0] &gt; m || nums[1] &gt; n) return nums;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return nums;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="完全背包理论基础">完全背包理论基础<a href="#完全背包理论基础" class="hash-link" aria-label="Direct link to 完全背包理论基础" title="Direct link to 完全背包理论基础">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1052" target="_blank" rel="noopener noreferrer">题目</a></p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//对于纯完全背包问题，其for循环的先后循环是可以颠倒的</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int items = in.nextInt(), bags = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] v = new int[items];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] w = new int[items];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; items; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            w[i] = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            v[i] = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[bags+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; items; i++){//遍历物品</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = w[i]; j &lt;= bags; j++){//遍历背包</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(dp[bags]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//如果先遍历背包，则要保证背包大于物品的重量</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="518零钱兑换ii">518.零钱兑换II<a href="#518零钱兑换ii" class="hash-link" aria-label="Direct link to 518.零钱兑换II" title="Direct link to 518.零钱兑换II">​</a></h2>
<p><a href="https://leetcode.cn/problems/coin-change-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int change(int amount, int[] coins) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(amount == 0) return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[amount+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;//只有相等时才加1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; coins.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = coins[i]; j &lt;= amount; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] += dp[j-coins[i]];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[amount];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="377-组合总和-ⅳ">377. 组合总和 Ⅳ<a href="#377-组合总和-ⅳ" class="hash-link" aria-label="Direct link to 377. 组合总和 Ⅳ" title="Direct link to 377. 组合总和 Ⅳ">​</a></h2>
<p><a href="https://leetcode.cn/problems/combination-sum-iv/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int combinationSum4(int[] nums, int target) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(target == 0) return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[target+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;//只有相等时才加1</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 0; j &lt;= target; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums[i] &lt;= j) dp[j] += dp[j-nums[i]];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[target];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="70-爬楼梯进阶版">70. 爬楼梯（进阶版）<a href="#70-爬楼梯进阶版" class="hash-link" aria-label="Direct link to 70. 爬楼梯（进阶版）" title="Direct link to 70. 爬楼梯（进阶版）">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1067" target="_blank" rel="noopener noreferrer">卡码网：57. 爬楼梯</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>输入描述：输入共一行，包含两个正整数，分别表示n, m</p>
<p>输出描述：输出一个整数，表示爬到楼顶的方法数。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = in.nextInt();//peak</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int m = in.nextInt();//step</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= m &amp;&amp; j &lt;= i; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[i] += dp[i-j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(dp[n]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="322-零钱兑换">322. 零钱兑换<a href="#322-零钱兑换" class="hash-link" aria-label="Direct link to 322. 零  钱兑换" title="Direct link to 322. 零钱兑换">​</a></h2>
<p><a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int coinChange(int[] coins, int amount) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(amount == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[amount+1];//存储（最少硬币数+1）</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; coins.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = coins[i]; j &lt;= amount; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(dp[j-coins[i]] != 0) dp[j] = dp[j] == 0 ? dp[j-coins[i]]+1 : Math.min(dp[j], dp[j-coins[i]]+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[amount]-1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="279完全平方数">279.完全平方数<a href="#279完全平方数" class="hash-link" aria-label="Direct link to 279.完全平方数" title="Direct link to 279.完全平方数">​</a></h2>
<p><a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="初始为1"><strong>初始为1</strong><a href="#初始为1" class="hash-link" aria-label="Direct link to 初始为1" title="Direct link to 初始为1">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int numSquares(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] square = squarenums(n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : square){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = i; j &lt;= n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(dp[j-i] != 0) dp[j] = (dp[j] == 0) ? (dp[j-i]+1) : Math.min(dp[j], dp[j-i]+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n]-1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] squarenums(int num) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int count = (int) Math.sqrt(num);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] result = new int[count];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; count; i++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            result[i] = (i + 1) * (i + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="采用max_value"><strong>采用MAX_VALUE</strong><a href="#采用max_value" class="hash-link" aria-label="Direct link to 采用max_value" title="Direct link to 采用max_value">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int numSquares(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sqrt_num = (int)Math.sqrt(n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= n; i++) dp[i] = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= sqrt_num; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = i*i; j &lt;= n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j] = Math.min(dp[j], dp[j-i*i]+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="139单词拆分">139.单词拆分<a href="#139单词拆分" class="hash-link" aria-label="Direct link to 139.单词拆分" title="Direct link to 139.单词拆分">​</a></h2>
<p><a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener noreferrer"> 力扣题目链接</a></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。</p>
<p>你可以假设字典中没有重复的单词。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        HashSet&lt;String&gt; set = new HashSet&lt;&gt;(wordDict);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] dp = new boolean[s.length()+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= s.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; i &amp;&amp; !dp[i]; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(set.contains(s.substring(j,i))) dp[i] = dp[j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[s.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//背包算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] dp = new boolean[s.length()+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= s.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(String j : wordDict){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int len = j.length();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i &gt;= len &amp;&amp; dp[i-len] &amp;&amp; j.equals(s.substring(i-len,i))) dp[i] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[s.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 回溯法+记忆化</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Set&lt;String&gt; set;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] memo;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        set = new HashSet&lt;&gt;(wordDict);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        memo = new int[s.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return backtracking(s, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean backtracking(String s, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(startindex == s.length()) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(memo[startindex] == -1) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex+1; i &lt;= s.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            String sub = s.substring(startindex, i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!set.contains(sub)) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            boolean res = backtracking(s, i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(res) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        memo[startindex] = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="多重背包">多重背包<a href="#多重背包" class="hash-link" aria-label="Direct link to 多重背包" title="Direct link to 多重背包">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1066" target="_blank" rel="noopener noreferrer">题目</a></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Arrays;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Scanner;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class multi_pack {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">	public static void main(String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int C = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int N = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		in.nextLine();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int[] k = new int[N];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		String[][] str = new String[N][];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		for(int i = 0; i &lt; 3; i++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			String ss = in.nextLine();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			str[i] = ss.split(&quot; &quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		for(int i = 0; i &lt; str[2].length; i++) k[i] = Integer.valueOf(str[2][i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int len = Arrays.stream(k).sum();//物品的总数目</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int[] w = new int[len];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int[] v = new int[len];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		for(int j = 0; j &lt; str[0].length; j++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			for(int i = 0; i &lt; k[j]; i++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">				w[cnt] = Integer.valueOf(str[0][j]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">				v[cnt] = Integer.valueOf(str[1][j]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">				cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		int[] dp = new int[C+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		for(int i = 0; i &lt; len; i++) {//先遍历物品，再遍历背包</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			for(int j = C; j &gt;= w[i]; j--) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">				dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">			}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		System.out.println(dp[C]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">		in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">	}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="198打家劫舍">198.打家劫舍<a href="#198打家劫舍" class="hash-link" aria-label="Direct link to 198.打家劫舍" title="Direct link to 198.打家劫舍">​</a></h2>
<p><a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int rob(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (nums.length == 1) return nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[nums.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = Math.max(nums[0], nums[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 2; i &lt; nums.length; i++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[nums.length - 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="213打家劫舍ii">213.打家劫舍II<a href="#213打家劫舍ii" class="hash-link" aria-label="Direct link to 213.打家劫舍II" title="Direct link to 213.打家劫舍II">​</a></h2>
<p><a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数 数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int rob(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 1) return nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(robHelper(nums, 0, nums.length-2), robHelper(nums, 1, nums.length-1));// 分别考虑首尾，从而打破环</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int robHelper(int[] nums, int start, int end) {// 这里的robHelper函数来求解不是环时的最大收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(start &gt; end) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(start == end) return nums[start];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[end-start+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = nums[start];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = Math.max(nums[start], nums[start+1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = start + 2; i &lt;= end; i++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i-start] = Math.max(dp[i-start-1], nums[i] + dp[i-start-2]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[end-start];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="337打家劫舍-iii">337.打家劫舍 III<a href="#337打家劫舍-iii" class="hash-link" aria-label="Direct link to 337.打家劫舍 III" title="Direct link to 337.打家劫舍 III">​</a></h2>
<p><a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//暴力递归超时</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int rob(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null)  return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int left_res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int right_res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root.left != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res += rob(root.left.left) + rob(root.left.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            left_res = rob(root.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root.right != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res += rob(root.right.left) + rob(root.right.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            right_res = rob(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(res, left_res + right_res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 记录状态，超时</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int rob(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null)  return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;TreeNode, Integer&gt; memo = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return robHelper(root, memo);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int robHelper(TreeNode root, Map&lt;TreeNode, Integer&gt; memo){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null)  return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (memo.containsKey(root)) return memo.get(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root.left != null) res += rob(root.left.left) + rob(root.left.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root.right != null) res += rob(root.right.left) + rob(root.right.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res = Math.max(res, robHelper(root.left, memo) + robHelper(root.right, memo));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        memo.put(root, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//状态标记,great</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int rob(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (root == null)  return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = robHelper(root);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(res[0], res[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] robHelper(TreeNode root){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(root == null)  return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int mid = root.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] left_res = robHelper(root.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] right_res = robHelper(root.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res[0] = Math.max(left_res[0] ,left_res[1]) + Math.max(right_res[0], right_res[1]); // 不偷当前节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res[1] = mid + left_res[0] + right_res[0]; // 偷当前节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="121-买卖股票的最佳时机">121. 买卖股票的最佳时机<a href="#121-买卖股票的最佳时机" class="hash-link" aria-label="Direct link to 121. 买卖股票的最佳时机" title="Direct link to 121. 买卖股票的最佳时机">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该  股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//贪心算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 找到一个最小的购入点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int low = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // res不断更新，直到数组循环完毕</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            low = Math.min(prices[i], low);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res = Math.max(prices[i] - low, res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(prices.length &lt; 2) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[prices.length][2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // dp[i][0]代表第i天持有股票的最大收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // dp[i][1]代表第i天不持有股票的最大收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][0] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = Math.max(dp[i-1][0], -prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(dp[prices.length-1][0], dp[prices.length-1][1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP,一维数组</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(prices.length &lt; 2) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // dp[0]代表持有股票的最大收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // dp[1]代表不持有股票的最大收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0] = Math.max(dp[0], -prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[1] = Math.max(dp[1], dp[0] + prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(dp[0], dp[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="122买卖股票的最佳时机ii">122.买卖股票的最佳时机II<a href="#122买卖股票的最佳时机ii" class="hash-link" aria-label="Direct link to 122.买卖股票的最佳时机II" title="Direct link to 122.买卖股票的最佳时机II">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP,优化空间</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 0表示持有，1表示卖出</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 前一天持有;  既然不限制交易次数，那么再次买股票时，要加上之前的收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0] = Math.max(dp[0], dp[1] - prices[i-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 前一天卖出; 或当天卖出，当天卖出，得先持有</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[1] = Math.max(dp[1], dp[0] + prices[i-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//贪心</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[prices.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = dp[i-1] + Math.max(0, prices[i] - prices[i-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[prices.length-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="123买卖股票的最佳时机iii">123.买卖股票的最佳时机III<a href="#123买卖股票的最佳时机iii" class="hash-link" aria-label="Direct link to 123.买卖股票的最佳时机III" title="Direct link to 123.买卖股票的最佳时机III">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(prices == null || prices.length &lt; 2) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[prices.length][4];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][0] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][2] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = Math.max(dp[i-1][0], -prices[i]); // 第一次交易买入</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]); // 第一次交易卖出</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] - prices[i]); // 第二次交易买入</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] + prices[i]); // 第二次交易卖出</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[prices.length-1][3];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="188买卖股票的最佳时机iv">🌟188.买卖股票的最佳时机IV<a href="#188买卖股票的最佳时机iv" class="hash-link" aria-label="Direct link to 🌟188.买卖股票的最佳时机IV" title="Direct link to 🌟188.买卖股票的最佳时机IV">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int k, int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(k == 0 || prices.length &lt; 2) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // [天数][股票状态]</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 股票状态: 奇数表示第 k 次交易持有/买入, 偶数表示第 k 次交易不持有/卖出, 0 表示没有操作</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        k = Math.min(k, prices.length/2);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[prices.length][2*k+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; 2*k; i+=2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0][i] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; 2*k-1; j+=2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j] - prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[i][j+2] = Math.max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[prices.length-1][2*k];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="309最佳买卖股票时机含冷冻期">🌟309.最佳买卖股票时机含冷冻期<a href="#309最佳买卖股票时机含冷冻期" class="hash-link" aria-label="Direct link to 🌟309.最佳买卖股票时机含冷冻期" title="Direct link to 🌟309.最佳买卖股票时机含冷冻期">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(prices == null || prices.length &lt; 2) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[prices.length][2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //bad case</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][0] = -prices[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1][0] = Math.max(dp[0][0], -prices[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1][1] = Math.max(dp[0][1], dp[0][0] + prices[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 2; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = Math.max(dp[i-1][0], dp[i-2][1] - prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[prices.length-1][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="714买卖股票的最佳时机含手续费">714.买卖股票的最佳时机含手续费<a href="#714买卖股票的最佳时机含手续费" class="hash-link" aria-label="Direct link to 714.买卖股票的最佳时机含手续费" title="Direct link to 714.买卖股票的最佳时机含手续费">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices, int fee) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(prices == null || prices.length &lt; 2) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[prices.length][2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][0] = -prices[0] - fee;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i] - fee);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[prices.length-1][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="300最长递增子序列">300.最长递增子序列<a href="#300最长递增子序列" class="hash-link" aria-label="Direct link to 300.最长递增子序列" title="Direct link to 300.最长递增子序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int lengthOfLIS(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length &lt; 2) return nums.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[nums.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(dp, 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; i; j++){ //遍历前面的元素，与nums[i]组成的严格递增子序列长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums[i] &gt; nums[j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i] = Math.max(dp[i], dp[j]+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            max = Math.max(max, dp[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return max;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="674-最长连续递增序列">674. 最长连续递增序列<a href="#674-最长连续递增序列" class="hash-link" aria-label="Direct link to 674. 最长连续递增序列" title="Direct link to 674. 最长连续递增序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个未经排序的  整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findLengthOfLCIS(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length &lt; 2) return nums.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[nums.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(dp, 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[i] &gt; nums[i-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[i] = dp[i-1] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            max = Math.max(max, dp[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return max;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="718-最长重复子数组">718. 最长重复子数组<a href="#718-最长重复子数组" class="hash-link" aria-label="Direct link to 718. 最长重复子数组" title="Direct link to 718. 最长重复子数组">​</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findLength(int[] nums1, int[] nums2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums1.length == 0 || nums2.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[nums1.length+1][nums2.length+1]; //在i=0或j=0处加了个0，方便后续计算</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max_len = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= nums1.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= nums2.length; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums1[i-1] == nums2[j-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    max_len = Math.max(max_len, dp[i][j]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return max_len;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1143最长公共子序列">1143.最长公共子序列<a href="#1143最长公共子序列" class="hash-link" aria-label="Direct link to 1143.最长公共子序列" title="Direct link to 1143.最长公共子序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP,二维数组</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int longestCommonSubsequence(String text1, String text2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] nums1 = text1.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] nums2 = text2.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums1.length == 0 || nums2.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[nums1.length+1][nums2.length+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= nums1.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= nums2.length; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums1[i-1] == nums2[j-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); //由于两个字符串的长度大小未知，所以要用max，如果知道长度大小，可以用长度较长的字符串的前一个索引的dp值</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[nums1.length][nums2.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP,一维数组</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int longestCommonSubsequence(String text1, String text2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] nums1 = text1.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] nums2 = text2.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums1.length == 0 || nums2.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[nums2.length+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= nums1.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int pre = dp[0]; // 记录dp[i-1][j-1]的值</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= nums2.length; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int cur = dp[j]; //暂存dp[i-1][j-1]的值</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums1[i-1] == nums2[j-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[j] = pre + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[j] = Math.max(dp[j-1], dp[j]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                pre = cur;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[nums2.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1035不相交的线">1035.不相交的线<a href="#1035不相交的线" class="hash-link" aria-label="Direct link to 1035.不相交的线" title="Direct link to 1035.不相交的线">​</a></h2>
<p><a href="https://leetcode.cn/problems/uncrossed-lines/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
<p>解答：与上一题一样</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="53-最大子序和">53. 最大子序和<a href="#53-最大子序和" class="hash-link" aria-label="Direct link to 53. 最大子序和" title="Direct link to 53. 最大子序和">​</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxSubArray(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // dp[0]表示以当前元素结尾的最大子数组和，dp[1]表示不以当前元素结尾的最大子数组和</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[1] = Integer.MIN_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[1] = Math.max(dp[1], dp[0]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[0] = Math.max(dp[0] + nums[i], nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(dp[0], dp[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="392判断子序列">392.判断子序列<a href="#392判断子序列" class="hash-link" aria-label="Direct link to 392.判断子序列" title="Direct link to 392.判断子序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/is-subsequence/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP，二维数组</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSubsequence(String s, String t) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(s.length() == 0) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] str1 = s.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] str2 = t.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[str1.length+1][str2.length+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= str2.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= str1.length; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(str2[i-1] == str1[j-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[j][i] = dp[j-1][i-1] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(dp[j][i] == str1.length) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[j][i] = dp[j][i-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[str1.length][str2.length] == str1.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP，一维数组</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSubsequence(String s, String t) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(s.length() == 0) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] str1 = s.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] str2 = t.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[str1.length+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= str2.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = str1.length; j &gt;= 1; j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(str2[i-1] == str1[j-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[j] = dp[j-1] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(dp[j] == str1.length) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[str1.length] == str1.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="115不同的子序列">115.不同的子序列<a href="#115不同的子序列" class="hash-link" aria-label="Direct link to 115.不同的子序列" title="Direct link to 115.不同的子序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&quot;ACE&quot; 是 &quot;ABCDE&quot; 的一个子序列，而 &quot;AEC&quot; 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int numDistinct(String s, String t) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(t == null || t.length() == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[s.length()+1][t.length()+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= s.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= s.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= t.length(); j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(s.charAt(i-1) == t.charAt(j-1)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = dp[i-1][j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[s.length()][t.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="583-两个字符串的删除操作">583. 两个字符串的删除操作<a href="#583-两个字符串的删除操作" class="hash-link" aria-label="Direct link to 583. 两个字符串的删除操作" title="Direct link to 583. 两个字符串的删除操作">​</a></h2>
<p><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int minDistance(String word1, String word2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[word1.length() + 1][word2.length() + 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= word1.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= word2.length(); j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(word1.charAt(i-1) == word2.charAt(j-1)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return word1.length() + word2.length() - 2 * dp[word1.length()][word2.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="72-编辑距离">72. 编辑距离<a href="#72-编辑距离" class="hash-link" aria-label="Direct link to 72. 编辑距离" title="Direct link to 72. 编辑距离">​</a></h2>
<p><a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int minDistance(String word1, String word2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[word2.length() + 1][word1.length() + 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= word2.length(); i++) dp[i][0] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 0; j &lt;= word1.length(); j++) dp[0][j] = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= word2.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= word1.length(); j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(word2.charAt(i-1) == word1.charAt(j-1)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = dp[i-1][j-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    /*</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j-1]表示删除word1的第j个字符，</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i-1][j]表示在word1的的第j字符后面插入word2的第i个字符，</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i-1][j-1]表示替换word1的第j个字符。</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    */</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = Math.min(Math.min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1; </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[word2.length()][word1.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="647-回文子串">647. 回文子串<a href="#647-回文子串" class="hash-link" aria-label="Direct link to 647. 回文子串" title="Direct link to 647. 回文子串">​</a></h2>
<p><a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int countSubstrings(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[][] dp = new boolean[s.length()][s.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = s.length()-1; i &gt;= 0; i--){ //从右下角开始，横向遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = i; j &lt; s.length(); j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if((s.charAt(i) == s.charAt(j)) &amp;&amp; ((j-i &lt; 2) || dp[i+1][j-1])){ </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="516最长回文子序列">516.最长回文子序列<a href="#516最长回文子序列" class="hash-link" aria-label="Direct link to 516.最长回文子序列" title="Direct link to 516.最长回文子序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener noreferrer">力扣题目链接(opens new window)</a></p>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int longestPalindromeSubseq(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(s == null || s.length() == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dp = new int[s.length()][s.length()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int max = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = s.length() - 1; i &gt;= 0; i--) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = i; j &lt; s.length(); j++) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(s.charAt(i) == s.charAt(j)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(j - i &lt; 2) dp[i][j] = j - i + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    else dp[i][j] = dp[i+1][j-1] + 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                max = Math.max(max, dp[i][j]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return max;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/码农/刷题记录/贪心算法/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">贪心算法</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/码农/刷题记录/单调栈/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">单调栈</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础知识" class="table-of-contents__link toc-highlight">基础知识</a></li><li><a href="#509-斐波那契数" class="table-of-contents__link toc-highlight">509. 斐波那契数</a></li><li><a href="#70-爬楼梯" class="table-of-contents__link toc-highlight">70. 爬楼梯</a></li><li><a href="#746-使用最小花费爬楼梯" class="table-of-contents__link toc-highlight">746. 使用最小花费爬楼梯</a></li><li><a href="#62不同路径" class="table-of-contents__link toc-highlight">62.不同路径</a></li><li><a href="#63-不同路径-ii" class="table-of-contents__link toc-highlight">63. 不同路径 II</a></li><li><a href="#343-整数拆分" class="table-of-contents__link toc-highlight">343. 整数拆分</a></li><li><a href="#96不同的二叉搜索树" class="table-of-contents__link toc-highlight">96.不同的二叉搜索树</a></li><li><a href="#01背包理论基础" class="table-of-contents__link toc-highlight">🌟01背包理论基础</a></li><li><a href="#416-分割等和子集" class="table-of-contents__link toc-highlight">416. 分割等和子集</a></li><li><a href="#1049最后一块石头的重量ii" class="table-of-contents__link toc-highlight">1049.最后一块石头的重量II</a></li><li><a href="#494目标和" class="table-of-contents__link toc-highlight">494.目标和</a></li><li><a href="#474一和零" class="table-of-contents__link toc-highlight">474.一和零</a></li><li><a href="#完全背包理论基础" class="table-of-contents__link toc-highlight">完全背包理论基础</a></li><li><a href="#518零钱兑换ii" class="table-of-contents__link toc-highlight">518.零钱兑换II</a></li><li><a href="#377-组合总和-ⅳ" class="table-of-contents__link toc-highlight">377. 组合总和 Ⅳ</a></li><li><a href="#70-爬楼梯进阶版" class="table-of-contents__link toc-highlight">70. 爬楼梯（进阶版）</a></li><li><a href="#322-零钱兑换" class="table-of-contents__link toc-highlight">322. 零钱兑换</a></li><li><a href="#279完全平方数" class="table-of-contents__link toc-highlight">279.完全平方数</a></li><li><a href="#139单词拆分" class="table-of-contents__link toc-highlight">139.单词拆分</a></li><li><a href="#多重背包" class="table-of-contents__link toc-highlight">多重背包</a></li><li><a href="#198打家劫舍" class="table-of-contents__link toc-highlight">198.打家劫舍</a></li><li><a href="#213打家劫舍ii" class="table-of-contents__link toc-highlight">213.打家劫舍II</a></li><li><a href="#337打家劫舍-iii" class="table-of-contents__link toc-highlight">337.打家劫舍 III</a></li><li><a href="#121-买卖股票的最佳时机" class="table-of-contents__link toc-highlight">121. 买卖股票的最佳时机</a></li><li><a href="#122买卖股票的最佳时机ii" class="table-of-contents__link toc-highlight">122.买卖股票的最佳时机II</a></li><li><a href="#123买卖股票的最佳时机iii" class="table-of-contents__link toc-highlight">123.买卖股票的最佳时机III</a></li><li><a href="#188买卖股票的最佳时机iv" class="table-of-contents__link toc-highlight">🌟188.买卖股票的最佳时机IV</a></li><li><a href="#309最佳买卖股票时机含冷冻期" class="table-of-contents__link toc-highlight">🌟309.最佳买卖股票时机含冷冻期</a></li><li><a href="#714买卖股票的最佳时机含手续费" class="table-of-contents__link toc-highlight">714.买卖股票的最佳时机含手续费</a></li><li><a href="#300最长递增子序列" class="table-of-contents__link toc-highlight">300.最长递增子序列</a></li><li><a href="#674-最长连续递增序列" class="table-of-contents__link toc-highlight">674. 最长连续递增序列</a></li><li><a href="#718-最长重复子数组" class="table-of-contents__link toc-highlight">718. 最长重复子数组</a></li><li><a href="#1143最长公共子序列" class="table-of-contents__link toc-highlight">1143.最长公共子序列</a></li><li><a href="#1035不相交的线" class="table-of-contents__link toc-highlight">1035.不相交的线</a></li><li><a href="#53-最大子序和" class="table-of-contents__link toc-highlight">53. 最大子序和</a></li><li><a href="#392判断子序列" class="table-of-contents__link toc-highlight">392.判断子序列</a></li><li><a href="#115不同的子序列" class="table-of-contents__link toc-highlight">115.不同的子序列</a></li><li><a href="#583-两个字符串的删除操作" class="table-of-contents__link toc-highlight">583. 两个字符串的删除操作</a></li><li><a href="#72-编辑距离" class="table-of-contents__link toc-highlight">72. 编辑距离</a></li><li><a href="#647-回文子串" class="table-of-contents__link toc-highlight">647. 回文子串</a></li><li><a href="#516最长回文子序列" class="table-of-contents__link toc-highlight">516.最长回文子序列</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>