<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-码农/刷题记录/回溯" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">回溯 | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.middiy.top/码农/刷题记录/回溯/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="回溯 | Coisini"><meta data-rh="true" name="description" content="回溯算法理论基础"><meta data-rh="true" property="og:description" content="回溯算法理论基础"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.middiy.top/码农/刷题记录/回溯/"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/回溯/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/回溯/" hreflang="x-default"><meta name="google-site-verification" content="1FUPX6Qo4y3ecU623ShEurhgnjhSTjK49rRMhEDlzFA">
<link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.53ea8373.css">
<script src="/assets/js/runtime~main.e0496e1a.js" defer="defer"></script>
<script src="/assets/js/main.1f310fcb.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/分享/">Sharing</a><button aria-label="Expand sidebar category &#x27;Sharing&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/读书笔记/">读书笔记</a><button aria-label="Expand sidebar category &#x27;读书笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/技巧/">技巧</a><button aria-label="Expand sidebar category &#x27;技巧&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/数学/">数学</a><button aria-label="Expand sidebar category &#x27;数学&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/思考/">思考</a><button aria-label="Expand sidebar category &#x27;思考&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/学习/">学习</a><button aria-label="Expand sidebar category &#x27;学习&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/码农/"> 码农</a><button aria-label="Collapse sidebar category &#x27;码农&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/基础知识/">基础知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/面试题/">面试题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/java笔记/">java 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/数组/">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/链表/">链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/哈希表/">哈希表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/字符串/">字符串</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/双指针/">双指针总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/栈与队列/">栈与队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/二叉树/">二叉树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/码农/刷题记录/回溯/">回溯</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/贪心算法/">贪心算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/动态规划/">动态规划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/单调栈/">单调栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/图论/">图论</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/高级数据结构/">高级数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/其他/">其他</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/转码/">转码经验</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/How_browsers_work/">How browsers work</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/毛选/">毛选</a><button aria-label="Expand sidebar category &#x27;毛选&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/码农/"><span itemprop="name">码农</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">回溯</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>回溯</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="回溯算法理论基础">回溯算法理论基础<a href="#回溯算法理论基础" class="hash-link" aria-label="Direct link to 回溯算法理论基础" title="Direct link to 回溯算法理论基础">​</a></h2>
<p>题目分类：</p>
<!-- -->
<p>回溯法也可以叫做回溯搜索法,它是一种搜索的方式。回溯是<strong>递归</strong>的副产品,只要有递归就会有回溯。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="回溯法的效率">回溯法的效率<a href="#回溯法的效率" class="hash-link" aria-label="Direct link to 回溯法的效率" title="Direct link to 回溯法的效率">​</a></h3>
<p>虽然回溯法很难,很不好理解,但是回溯法并不是什么高效的算法。因为回溯的<strong>本质是穷举</strong>,穷举所有可能,然后选出我们想要的答案,如果想让回溯法高效一些,可以加一些剪枝的操作,但也改不了回溯法就是穷举的本质。</p>
<p>组合无序,排列有序</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="理解回溯法">理解回溯法<a href="#理解回溯法" class="hash-link" aria-label="Direct link to 理解回溯法" title="Direct link to 理解回溯法">​</a></h3>
<p>所有回溯法的问题都可以抽象为<strong>树形结构</strong>,因为回溯法解决的都是在集合中递归查找子集,<strong>集合的大小就构成了树的宽度,递归的深度就构成了树的深度</strong>。</p>
<p>递归要有终止条件,所以必然是一棵高度有限的树（N叉树）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="回溯法模板">回溯法模板<a href="#回溯法模板" class="hash-link" aria-label="Direct link to 回溯法模板" title="Direct link to 回溯法模板">​</a></h3>
<p>回溯三部曲：</p>
<ol>
<li>返回值以及参数
函数返回值一般为void,参数一般是先写逻辑才能确定</li>
<li>终止条件
终止条件从树中就可以看出,一般来说是搜到叶子节点</li>
<li>遍历过程
一般是在集合中递归搜索,集合的大小构成了树的宽度,递归的深度构成的树的深度</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="第77题-组合">第77题. 组合<a href="#第77题-组合" class="hash-link" aria-label="Direct link to 第77题. 组合" title="Direct link to 第77题. 组合">​</a></h2>
<p><a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定两个整数 n 和 k,返回 1 ... n 中所有可能的 k 个数的组合。</p>
<p>示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(n, k, 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int n, int k, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(deque.size() == k){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList&lt;&gt;(deque));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt;= n - (k - deque.size() - 1); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.offer(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(n, k, i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="216组合总和iii">216.组合总和III<a href="#216组合总和iii" class="hash-link" aria-label="Direct link to 216.组合总和III" title="Direct link to 216.组合总和III">​</a></h2>
<p><a href="https://leetcode.cn/problems/combination-sum-iii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数,并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(k, n, 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int k, int n, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(k == 0 || n == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(k == 0 &amp;&amp; n == 0) res.add(new ArrayList&lt;&gt;(deque));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt;= Math.min(n, 9); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.offer(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(k-1, n-i, i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="17电话号码的字母组合">17.电话号码的字母组合<a href="#17电话号码的字母组合" class="hash-link" aria-label="Direct link to 17.电话号码的字母组合" title="Direct link to 17.电话号码的字母组合">​</a></h2>
<p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个仅包含数字 2-9 的字符串,返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    StringBuilder temp = new StringBuilder();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; letterCombinations(String digits) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(digits == null || digits.length() == 0) return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        String[] s = {&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(digits, 0, s);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(String digits, int num, String[] s){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(num == digits.length()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(temp.toString());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        String str = s[digits.charAt(num) - &#x27;0&#x27;];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; str.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.append(str.charAt(i));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(digits, num + 1, s);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.deleteCharAt(temp.length() - 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="39-组合总和">39. 组合总和<a href="#39-组合总和" class="hash-link" aria-label="Direct link to 39. 组合总和" title="Direct link to 39. 组合总和">​</a></h2>
<p><a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ,找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(candidates == null || candidates.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(candidates, target, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] candidates, int target, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(target &lt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(target == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList&lt;&gt;(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; candidates.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(candidates[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(candidates, target-candidates[i], i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.remove(temp.size() - 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="40组合总和ii">40.组合总和II<a href="#40组合总和ii" class="hash-link" aria-label="Direct link to 40.组合总和II" title="Direct link to 40.组合总和II">​</a></h2>
<p><a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个数组 candidates 和一个目标数 target ,找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="used数组"><strong>used数组</strong><a href="#used数组" class="hash-link" aria-label="Direct link to used数组" title="Direct link to used数组">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    boolean[] used;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(candidates == null || candidates.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        used = new boolean[candidates.length];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 加标志数组,用来辅助判断同层节点是否已经遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(used, false);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(candidates);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(candidates, target, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] candidates, int target, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(target &lt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(target == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList&lt;&gt;(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; candidates.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // used[i - 1] == true,说明同⼀树⽀nums[i - 1]使⽤过</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // used[i - 1] == false,说明同⼀树层nums[i - 1]使⽤过</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; !used[i-1]) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(candidates[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            used[i] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 每个节点仅能选择一次,所以从下一位开始</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(candidates, target-candidates[i], i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            used[i] = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="不用used数组"><strong>不用used数组</strong><a href="#不用used数组" class="hash-link" aria-label="Direct link to 不用used数组" title="Direct link to 不用used数组">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(candidates == null || candidates.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(candidates);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(candidates, target, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] candidates, int target, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(target &lt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(target == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList&lt;&gt;(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; candidates.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i &gt; startindex &amp;&amp; candidates[i] == candidates[i-1]) continue;// 要对同一树层使用过的元素进行跳过</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(candidates[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(candidates, target-candidates[i], i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="131分割回文串">131.分割回文串<a href="#131分割回文串" class="hash-link" aria-label="Direct link to 131.分割回文串" title="Direct link to 131.分割回文串">​</a></h2>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个字符串 s,将 s 分割成一些子串,使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;String&gt;&gt; partition(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(s == null || s.length() == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(s);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(String s){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(s == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList(deque));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len1 = s.length();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(ishuiwen(s.substring(0,i+1))){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.offer(s.substring(0,i+1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i+1 &lt; len1) backtracking(s.substring(i+1,len1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else backtracking(null);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean ishuiwen(String s){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = s.length();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len/2; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(s.charAt(i) != s.charAt(len - i - 1)) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="93复原ip地址">93.复原IP地址<a href="#93复原ip地址" class="hash-link" aria-label="Direct link to 93.复原IP地址" title="Direct link to 93.复原IP地址">​</a></h2>
<p><a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个只包含数字的字符串,复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成,且不能含有前导 0）,整数之间用 &#x27;.&#x27; 分隔。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; restoreIpAddresses(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        StringBuilder sb = new StringBuilder(s);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(sb, 0, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(StringBuilder s, int startindex, int pointnum){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(pointnum == 3 &amp;&amp; check(s, startindex, s.length())){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(s.toString());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(pointnum &gt; 3) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; s.length() &amp;&amp; i &lt; startindex + 3; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(check(s, startindex, i+1)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                s.insert(i+1,&quot;.&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                backtracking(s, i+2, pointnum+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                s.deleteCharAt(i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean check(StringBuilder s, int start, int end){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(end-start &gt; 3 || end &gt; s.length() || start &gt;= end || Integer.valueOf(s.substring(start, end)) &gt; 255) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(s.charAt(start) == &#x27;0&#x27; &amp;&amp; end-start &gt; 1) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="78子集">78.子集<a href="#78子集" class="hash-link" aria-label="Direct link to 78.子集" title="Direct link to 78.子集">​</a></h2>
<p><a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一组不含重复元素的整数数组 nums,返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums, 0, nums.length-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] nums, int left, int right){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(left &gt; right){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        temp.add(nums[left]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums, left+1, right);//添加nums[left]元素的集合</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        temp.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums, left+1, right);//不添加nums[left]元素的集合</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="90子集ii">90.子集II<a href="#90子集ii" class="hash-link" aria-label="Direct link to 90.子集II" title="Direct link to 90.子集II">​</a></h2>
<p><a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个可能包含重复元素的整数数组 nums,返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] nums, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res.add(new ArrayList(temp));//「遍历这个树的时候,把所有节点都记录下来,就是要求的子集集合」</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //停止条件就是：i &lt; nums.length</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i &gt; startindex &amp;&amp; nums[i] == nums[i-1]) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(nums, i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="491递增子序列">491.递增子序列<a href="#491递增子序列" class="hash-link" aria-label="Direct link to 491.递增子序列" title="Direct link to 491.递增子序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列,递增子序列的长度至少是2。</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="暴力判断重复"><strong>暴力判断重复</strong><a href="#暴力判断重复" class="hash-link" aria-label="Direct link to 暴力判断重复" title="Direct link to 暴力判断重复">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] nums, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(temp.size() &gt; 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.get(temp.size()-1) &lt; temp.get(temp.size()-2)) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            boolean flag = false;//判断全集是否包含相同的元素</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = i-1; j &gt;= startindex; j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums[i] == nums[j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    flag = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(flag) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(nums, i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="map"><strong>Map</strong><a href="#map" class="hash-link" aria-label="Direct link to map" title="Direct link to map">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int[] nums, int startindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(temp.size() &gt; 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(temp.get(temp.size()-1) &lt; temp.get(temp.size()-2)) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(new ArrayList(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = startindex; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(map.getOrDefault(nums[i], 0) &gt; 0) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            map.put(nums[i], 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(nums, i+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.removeLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="46全排列">46.全排列<a href="#46全排列" class="hash-link" aria-label="Direct link to 46.全排列" title="Direct link to 46.全排列">​</a></h2>
<p><a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个 没有重复 数字的序列,返回其所有可能的全排列。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++) nums1.add(nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(List&lt;Integer&gt; nums1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums1.size() ==0) res.add(new ArrayList(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums1.size(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(nums1.remove(i));            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(nums1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            nums1.add(i, temp.remove(temp.size()-1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="47全排列-ii">47.全排列 II<a href="#47全排列-ii" class="hash-link" aria-label="Direct link to 47.全排列 II" title="Direct link to 47.全排列 II">​</a></h2>
<p><a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个可包含重复数字的序列 nums ,按任意顺序 返回所有不重复的全排列。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++) nums1.add(nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(nums1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(List&lt;Integer&gt; nums1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums1.size() ==0) res.add(new ArrayList(temp));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums1.size(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i &gt; 0 &amp;&amp; nums1.get(i) == nums1.get(i-1)) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp.add(nums1.remove(i));            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            backtracking(nums1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            nums1.add(i, temp.remove(temp.size()-1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="回溯算法去重问题的另一种写法">回溯算法去重问题的另一种写法<a href="#回溯算法去重问题的另一种写法" class="hash-link" aria-label="Direct link to 回溯算法去重问题的另一种写法" title="Direct link to 回溯算法去重问题的另一种写法">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="两种写法的性能分析">两种写法的性能分析<a href="#两种写法的性能分析" class="hash-link" aria-label="Direct link to 两种写法的性能分析" title="Direct link to 两种写法的性能分析">​</a></h3>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();//层去重</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">...</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">if (hashSet.contains(nums[i])) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">hashSet.add(nums[i]);//记录元素</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>需要注意的是：<strong>使用set去重的版本相对于used数组的版本效率都要低很多</strong>。</p>
<p>原因在<a href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html" target="_blank" rel="noopener noreferrer">回溯算法：递增子序列 </a>中也分析过,主要是因为程序运行的时候对unordered_set 频繁的insert,unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间,而且insert的时候其底层的符号表也要做相应的扩充,也是费时的。</p>
<p><strong>而使用used数组在时间复杂度上几乎没有额外负担！</strong></p>
<p><strong>使用set去重,不仅时间复杂度高了,空间复杂度也高了</strong>,在<a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201112%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html" target="_blank" rel="noopener noreferrer">本周小结！（回溯算法系列三） </a>中分析过,组合,子集,排列问题的空间复杂度都是O(n),但如果使用set去重,空间复杂度就变成了O(n^2),因为每一层递归都有一个set集合,系统栈空间是n,每一个空间都有set集合。</p>
<p>used数组可是全局变量,每层与每层之间公用一个used数组,所以空间复杂度是O(n + n),最终空间复杂度还是O(n)。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="332重新安排行程">332.重新安排行程<a href="#332重新安排行程" class="hash-link" aria-label="Direct link to 332.重新安排行程" title="Direct link to 332.重新安排行程">​</a></h2>
<p><a href="https://leetcode.cn/problems/reconstruct-itinerary/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个机票的字符串二维数组 [from, to],子数组中的两个成员分别表示飞机出发和降落的机场地点,对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生,所以该行程必须从 JFK 开始。</p>
<p>提示：</p>
<ul>
<li>如果存在多种有效的行程,请你按字符自然排序返回最小的行程组合。例如,行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小,排序更靠前</li>
<li>所有的机场都用三个大写字母表示（机场代码）。</li>
<li>假定所有机票至少存在一种合理的行程。</li>
<li>所有的机票必须都用一次 且 只能用一次。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Collections.sort(tickets, (a, b) -&gt; a.get(1).compareTo(b.get(1)));//排序</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(&quot;JFK&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        bakctracking(tickets);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void bakctracking(List&lt;List&lt;String&gt;&gt; tickets){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(tickets == null || tickets.size() == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            ArrayList&lt;String&gt; temp = new ArrayList&lt;&gt;(deque);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.addAll(temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; tickets.size(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(res.size() &gt; 0) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;String&gt; s = tickets.get(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(deque.peekLast().equals(s.get(0)) &amp;&amp; set.add(s.get(1))){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                set.add(s.get(1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.offer(s.get(1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                tickets.remove(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                bakctracking(tickets);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                tickets.add(i, s);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="51-n皇后">51. N皇后<a href="#51-n皇后" class="hash-link" aria-label="Direct link to 51. N皇后" title="Direct link to 51. N皇后">​</a></h2>
<p><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上,并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ,返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案,该方案中 &#x27;Q&#x27; 和 &#x27;.&#x27; 分别代表了皇后和空位。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    char[][] chessboard;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        chessboard = new char[n][n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(char[] c : chessboard){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Arrays.fill(c, &#x27;.&#x27;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(0, n, chessboard);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int row, int n, char[][] chessboard){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(row == n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(char[] c : chessboard){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                list.add(String.valueOf(c));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(list);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){//树的每一层遍历行</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(isvalid(row, i, n, chessboard)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                chessboard[row][i] = &#x27;Q&#x27;;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                backtracking(row+1, n, chessboard);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                chessboard[row][i] = &#x27;.&#x27;;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean isvalid(int row, int col, int n, char[][] chessboard){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //检查列</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; row; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(chessboard[i][col] == &#x27;Q&#x27;) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //45°</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = row, j = col; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(chessboard[i][j] == &#x27;Q&#x27;) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        //135°</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(chessboard[i][j] == &#x27;Q&#x27;) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="37-解数独">37. 解数独<a href="#37-解数独" class="hash-link" aria-label="Direct link to 37. 解数独" title="Direct link to 37. 解数独">​</a></h2>
<p><a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>编写一个程序,通过填充空格来解决数独问题。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    // 二进制中1表示 对应位置已经有值了</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] rows = new int[9];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] cols = new int[9];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[][] cells = new int[3][3];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    boolean flag = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void solveSudoku(char[][] board) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 9; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; 9; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                char c = board[i][j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(c == &#x27;.&#x27;){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    int n = c - &#x27;1&#x27;;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    fillNumber(i, j, n, true);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        backtracking(cnt, board);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void backtracking(int cnt, char[][] board){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(cnt == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            flag = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 获取候选数最少的位置</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] pos = getMinposition(board);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int row = pos[0], col = pos[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int rest = ~(rows[row] | cols[col] | cells[row/3][col/3]) &amp; ((1&lt;&lt;9) - 1);// 添加掩码,因为int是32位的！！！</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 9; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if((rest &amp; (1 &lt;&lt; i)) != 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                fillNumber(row, col, i, true);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                board[row][col] = (char)(i+1+&#x27;0&#x27;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                backtracking(cnt-1, board);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(flag) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                board[row][col] = &#x27;.&#x27;;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                fillNumber(row, col, i, false);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    // 获取候选项最少的位置</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] getMinposition(char[][] board){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int min = 10;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 9; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; 9; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(board[i][j] == &#x27;.&#x27;){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    int rest = ~(rows[i] | cols[j] | cells[i/3][j/3]) &amp; ((1&lt;&lt;9) - 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    int count = getCount(rest);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(count &lt; min){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        min = count;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        res[0] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        res[1] = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(min == 1) return res;// 找到最优解直接返回</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    //得到1的个数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int getCount(int rest){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(rest != 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            count += rest &amp; 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            rest = rest &gt;&gt; 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void fillNumber(int x, int y, int n, boolean fill){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // ture set 1, false set 0</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        rows[x] = fill ? rows[x] | (1&lt;&lt;n) : rows[x] &amp; ~(1&lt;&lt;n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        cols[y] = fill ? cols[y] | (1&lt;&lt;n) : cols[y] &amp; ~(1&lt;&lt;n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        cells[x/3][y/3] = fill ? cells[x/3][y/3] | (1&lt;&lt;n) : cells[x/3][y/3] &amp; ~(1&lt;&lt;n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
</div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/码农/刷题记录/二叉树/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">二叉树</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/码农/刷题记录/贪心算法/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">贪心算法</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#回溯算法理论基础" class="table-of-contents__link toc-highlight">回溯算法理论基础</a><ul><li><a href="#回溯法的效率" class="table-of-contents__link toc-highlight">回溯法的效率</a></li><li><a href="#理解回溯法" class="table-of-contents__link toc-highlight">理解回溯法</a></li><li><a href="#回溯法模板" class="table-of-contents__link toc-highlight">回溯法模板</a></li></ul></li><li><a href="#第77题-组合" class="table-of-contents__link toc-highlight">第77题. 组合</a></li><li><a href="#216组合总和iii" class="table-of-contents__link toc-highlight">216.组合总和III</a></li><li><a href="#17电话号码的字母组合" class="table-of-contents__link toc-highlight">17.电话号码的字母组合</a></li><li><a href="#39-组合总和" class="table-of-contents__link toc-highlight">39. 组合总和</a></li><li><a href="#40组合总和ii" class="table-of-contents__link toc-highlight">40.组合总和II</a></li><li><a href="#131分割回文串" class="table-of-contents__link toc-highlight">131.分割回文串</a></li><li><a href="#93复原ip地址" class="table-of-contents__link toc-highlight">93.复原IP地址</a></li><li><a href="#78子集" class="table-of-contents__link toc-highlight">78.子集</a></li><li><a href="#90子集ii" class="table-of-contents__link toc-highlight">90.子集II</a></li><li><a href="#491递增子序列" class="table-of-contents__link toc-highlight">491.递增子序列</a></li><li><a href="#46全排列" class="table-of-contents__link toc-highlight">46.全排列</a></li><li><a href="#47全排列-ii" class="table-of-contents__link toc-highlight">47.全排列 II</a></li><li><a href="#回溯算法去重问题的另一种写法" class="table-of-contents__link toc-highlight">回溯算法去重问题的另一种写法</a><ul><li><a href="#两种写法的性能分析" class="table-of-contents__link toc-highlight">两种写法的性能分析</a></li></ul></li><li><a href="#332重新安排行程" class="table-of-contents__link toc-highlight">332.重新安排行程</a></li><li><a href="#51-n皇后" class="table-of-contents__link toc-highlight">51. N皇后</a></li><li><a href="#37-解数独" class="table-of-contents__link toc-highlight">37. 解数独</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>