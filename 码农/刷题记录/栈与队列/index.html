<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-码农/刷题记录/栈与队列" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">栈与队列 | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.middiy.top/码农/刷题记录/栈与队列/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="栈与队列 | Coisini"><meta data-rh="true" name="description" content="基础知识"><meta data-rh="true" property="og:description" content="基础知识"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.middiy.top/码农/刷题记录/栈与队列/"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/栈与队列/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/栈与队列/" hreflang="x-default"><meta name="google-site-verification" content="1FUPX6Qo4y3ecU623ShEurhgnjhSTjK49rRMhEDlzFA">
<link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.53ea8373.css">
<script src="/assets/js/runtime~main.09cb5d2e.js" defer="defer"></script>
<script src="/assets/js/main.c95ab167.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/分享/">分享</a><button aria-label="Expand sidebar category &#x27;分享&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/读书笔记/">读书笔记</a><button aria-label="Expand sidebar category &#x27;读书笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/技巧/">技巧</a><button aria-label="Expand sidebar category &#x27;技巧&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/数学/">数学</a><button aria-label="Expand sidebar category &#x27;数学&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/思考/">思考</a><button aria-label="Expand sidebar category &#x27;思考&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/学习/">学习</a><button aria-label="Expand sidebar category &#x27;学习&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/码农/">码农</a><button aria-label="Collapse sidebar category &#x27;码农&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/自学之路/">自学之路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/Waking-Up/">Waking-Up</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/java笔记/">☕️java 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/python笔记/">python笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/Math/">Math</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/数组/">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/链表/">链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/哈希表/">哈希表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/字符串/">字符串</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/双指针/">双指针总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/码农/刷题记录/栈与队列/">栈与队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/二叉树/">二叉树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/回溯/">回溯</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/贪心算法/">贪心算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/动态规划/">动态规划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/单调栈/">单调栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/图论/">图论</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/高级数据结构/">高级数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/其他/">其他</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/转码/">转码经验</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/How_browsers_work/">How browsers work</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/毛选/">毛选</a><button aria-label="Expand sidebar category &#x27;毛选&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/左耳听风/">左耳听风</a><button aria-label="Expand sidebar category &#x27;左耳听风&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/码农/"><span itemprop="name">码农</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">栈与队列</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>栈与队列</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础知识">基础知识<a href="#基础知识" class="hash-link" aria-label="Direct link to 基础知识" title="Direct link to 基础知识">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="栈">栈<a href="#栈" class="hash-link" aria-label="Direct link to 栈" title="Direct link to 栈">​</a></h3>
<p>灵魂四问：</p>
<ol>
<li>C++中stack，queue 是容器么？</li>
<li>我们使用的stack，queue是属于那个版本的STL？</li>
<li>我们使用的STL中stack，queue是如何实现的？</li>
<li>stack，queue 提供迭代器来遍历空间么？</li>
</ol>
<p>栈和队列是STL（C++标准库）里面的两个数据结构，C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
<p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）</strong>。所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p>STL 中栈是用什么容器实现的？
栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p>
<p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="队列">队列<a href="#队列" class="hash-link" aria-label="Direct link to 队列" title="Direct link to 队列">​</a></h3>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构</strong>。</p>
<p>STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双端队列deque解释">双端队列Deque解释<a href="#双端队列deque解释" class="hash-link" aria-label="Direct link to 双端队列Deque解释" title="Direct link to 双端队列Deque解释">​</a></h3>
<p>Deque是一个双端队列接口，继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="deque有三种用途">Deque有三种用途：<a href="#deque有三种用途" class="hash-link" aria-label="Direct link to Deque有三种用途：" title="Direct link to Deque有三种用途：">​</a></h5>
<ul>
<li>普通队列(一端进另一端出):
<code>Queue queue = new LinkedList()</code>或<code>Deque deque = new LinkedList()</code></li>
<li>双端队列(两端都可进出)
<code>Deque deque = new LinkedList()</code></li>
<li>堆栈
<code>Deque deque = new LinkedList()</code></li>
</ul>
<blockquote>
<p>注意：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。Deque堆栈操作方法：push()、pop()、peek()。</p>
</blockquote>
<p>Deque是一个线性collection，支持在两端插入和移除元素。名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p>
<p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 Deque 实现设计的；在大多数实现中，插入操作不能失败。</p>
<p>下表总结了上述 12 种方法：</p>








































<table><thead><tr><th></th><th><strong>第一个元素 (头部)</strong></th><th><strong>最后一个元素 (尾部)</strong></th><th></th><th></th></tr></thead><tbody><tr><td></td><td><em>抛出异常</em></td><td><em>特殊值</em></td><td><em>抛出异常</em></td><td><em>特殊值</em></td></tr><tr><td><strong>插入</strong></td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td><strong>删除</strong></td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td><strong>检查</strong></td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table>
<p>Deque接口扩展(继承)了 Queue 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p>

































<table><thead><tr><th><strong>Queue方法</strong></th><th><strong>等效Deque方法</strong></th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table>
<p>双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p>





















<table><thead><tr><th><strong>堆栈方法</strong></th><th><strong>等效Deque方法</strong></th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td></tr><tr><td>pop()</td><td>removeFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="优先级队列">优先级队列<a href="#优先级队列" class="hash-link" aria-label="Direct link to 优先级队列" title="Direct link to 优先级队列">​</a></h3>
<p>其实就是一个披着队列外衣的<strong>堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p>
<p>什么是堆呢？</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="232用栈实现队列">232.用栈实现队列<a href="#232用栈实现队列" class="hash-link" aria-label="Direct link to 232.用栈实现队列" title="Direct link to 232.用栈实现队列">​</a></h2>
<p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>使用栈实现队列的下列操作：</p>
<p>push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class MyQueue {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Stack&lt;Integer&gt; stackIn;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Stack&lt;Integer&gt; stackOut;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public MyQueue() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        stackIn = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        stackOut = new Stack&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void push(int x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        stackIn.push(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int pop() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dumpstackIn();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return stackOut.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int peek() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dumpstackIn();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return stackOut.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private void dumpstackIn(){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(!stackOut.isEmpty()) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!stackIn.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            stackOut.push(stackIn.pop());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="225-用队列实现栈">225. 用队列实现栈<a href="#225-用队列实现栈" class="hash-link" aria-label="Direct link to 225. 用队列实现栈" title="Direct link to 225. 用队列实现栈">​</a></h2>
<p><a href="https://leetcode.cn/problems/implement-stack-using-queues/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) -- 元素 x 入栈</li>
<li>pop() -- 移除栈顶元素</li>
<li>top() -- 获取栈顶元素</li>
<li>empty() -- 返回栈是否为空</li>
</ul>
<p>注意:</p>
<ul>
<li>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//两个 Queue 实现</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class MyStack {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Queue&lt;Integer&gt; queue1; // 和栈中保持一样元素的队列</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Queue&lt;Integer&gt; queue2; // 辅助队列</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public MyStack() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue1 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue2 = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void push(int x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue2.offer(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!queue1.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            queue2.offer(queue1.poll());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Queue&lt;Integer&gt; queue_temp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue_temp = queue1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue1 = queue2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue2 = queue_temp;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int pop() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return queue1.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int top() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return queue1.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return queue1.isEmpty();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 优化，使用一个 Queue 实现</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class MyStack {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Queue&lt;Integer&gt; queue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public MyStack() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    ////每 offer 一个数（A）进来，都重新排列，把这个数（A）放到队列的队首</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void push(int x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue.offer(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int size = queue.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(size-- &gt; 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            queue.offer(queue.poll());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int pop() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return queue.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int top() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return queue.peek();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return queue.isEmpty();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="20-有效的括号">20. 有效的括号<a href="#20-有效的括号" class="hash-link" aria-label="Direct link to 20. 有效的括号" title="Direct link to 20. 有效的括号">​</a></h2>
<p><a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;{&#x27;，&#x27;}&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p>示例 1:</p>
<ul>
<li>输入: &quot;()&quot;</li>
<li>输出: true</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: &quot;()[]{}&quot;</li>
<li>输出: true</li>
</ul>
<p>示例 3:</p>
<ul>
<li>输入: &quot;(]&quot;</li>
<li>输出: false</li>
</ul>
<p>示例 4:</p>
<ul>
<li>输入: &quot;([)]&quot;</li>
<li>输 出: false</li>
</ul>
<p>示例 5:</p>
<ul>
<li>输入: &quot;{[]}&quot;</li>
<li>输出: true</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isValid(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Character&gt; deque= new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] ss = s.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = ss.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(len%2 == 1) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(char c : ss){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(c == &#x27;(&#x27;){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(&#x27;)&#x27;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else if(c == &#x27;[&#x27;){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(&#x27;]&#x27;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else if(c == &#x27;{&#x27;){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(&#x27;}&#x27;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.isEmpty() || c != deque.pop()) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return deque.isEmpty();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1047-删除字符串中的所有相邻重复项">1047. 删除字符串中的所有相邻重复项<a href="#1047-删除字符串中的所有相邻重复项" class="hash-link" aria-label="Direct link to 1047. 删除字符串中的所有相邻重复项" title="Direct link to 1047.   删除字符串中的所有相邻重复项">​</a></h2>
<p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<ul>
<li>输入：&quot;abbaca&quot;</li>
<li>输出：&quot;ca&quot;</li>
<li>解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S 仅由小写英文字母组成。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public String removeDuplicates(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] ss = s.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(char c : ss){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(deque.peek() == c){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.push(c);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] res = new char[deque.size()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; res.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res[i] = deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return new String(res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="150-逆波兰表达式求值">150. 逆波兰表达式求值<a href="#150-逆波兰表达式求值" class="hash-link" aria-label="Direct link to 150. 逆波兰表达式求值" title="Direct link to 150. 逆波兰表达式求值">​</a></h2>
<p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：</p>
<ul>
<li>输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot; * &quot;]</li>
<li>输出: 9</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</li>
<li>输出: 6</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li>
</ul>
<p>示例 3：</p>
<ul>
<li>
<p>输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot; * &quot;, &quot;/&quot;, &quot; * &quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</p>
</li>
<li>
<p>输出: 22</p>
</li>
<li>
<p>解释:该算式转化为常见的中缀算术表达式为：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">((10 * (6 / ((9 + 3) * -11))) + 17) + 5       </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">= ((10 * (6 / -132)) + 17) + 5     </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">= ((10 * 0) + 17) + 5     </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">= (0 + 17) + 5    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">= 17 + 5    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">= 22    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</li>
</ul>
<p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p>
<p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int evalRPN(String[] tokens) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int temp1 = 0, temp2 = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(String c : tokens){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(c.equals(&quot;+&quot;)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp1 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp2 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(temp2 + temp1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else if(c.equals(&quot;-&quot;)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp1 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp2 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(temp2 - temp1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else if(c.equals(&quot;*&quot;)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp1 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp2 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(temp2 * temp1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else if(c.equals(&quot;/&quot;)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp1 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp2 = deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(temp2 / temp1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.push(Integer.valueOf(c));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return deque.pop();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="239-滑动窗口最大值">239. 滑动窗口最大值<a href="#239-滑动窗口最大值" class="hash-link" aria-label="Direct link to 239. 滑动窗口最大值" title="Direct link to 239. 滑动窗口最大值">​</a></h2>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值</p>
<p>进阶：</p>
<p>你能在线性时间复杂度内解决此题吗？</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] maxSlidingWindow(int[] nums, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[nums.length - k + 1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int index = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，因为出现大数时，数组中前面的小数就没用了</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            deque.offer(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i &gt;= k - 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[index++] = nums[deque.peek()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="347前-k-个高频元素">347.前 K 个高频元素<a href="#347前-k-个高频元素" class="hash-link" aria-label="Direct link to 347.前 K 个高频元素" title="Direct link to 347.前 K 个高频元素">​</a></h2>
<p><a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<ul>
<li>输入: nums = [1,1,1,2,2,3], k = 2</li>
<li>输出: [1,2]</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: nums = [1], k = 1</li>
<li>输出: [1]</li>
</ul>
<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//基于大顶堆实现</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] topKFrequent(int[] nums, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[k];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : nums){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            map.put(i, map.getOrDefault(i, 0) + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair2[1] - pair1[1]);//lambda表达式，表达式为正时，右边的数  先进队列，pair[1]在后面表示map的Value</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; k; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res[i] = pq.poll()[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//基于小顶堆实现</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] topKFrequent(int[] nums, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[k];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : nums){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            map.put(i, map.getOrDefault(i, 0) + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1] - pair2[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(pq.size() &lt; k){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(entry.getValue() &gt; pq.peek()[1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    pq.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; k; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res[i] = pq.poll()[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>在栈与队列系列中，我们强调栈与队列的基础。使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。</p>
<p>我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：<strong>单调队列</strong>和<strong>优先级队列</strong>，这是特殊场景解决问题的利器。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/码农/刷题记录/双指针/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">双指针总结</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/码农/刷题记录/二叉树/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">二叉树</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础知识" class="table-of-contents__link toc-highlight">基础知识</a><ul><li><a href="#栈" class="table-of-contents__link toc-highlight">栈</a></li><li><a href="#队列" class="table-of-contents__link toc-highlight">队列</a></li><li><a href="#双端队列deque解释" class="table-of-contents__link toc-highlight">双端队列Deque解释</a></li><li><a href="#优先级队列" class="table-of-contents__link toc-highlight">优先级队列</a></li></ul></li><li><a href="#232用栈实现队列" class="table-of-contents__link toc-highlight">232.用栈实现队列</a></li><li><a href="#225-用队列实现栈" class="table-of-contents__link toc-highlight">225. 用队列实现栈</a></li><li><a href="#20-有效的括号" class="table-of-contents__link toc-highlight">20. 有效的括号</a></li><li><a href="#1047-删除字符串中的所有相邻重复项" class="table-of-contents__link toc-highlight">1047. 删除字符串中的所有相邻重复项</a></li><li><a href="#150-逆波兰表达式求值" class="table-of-contents__link toc-highlight">150. 逆波兰表达式求值</a></li><li><a href="#239-滑动窗口最大值" class="table-of-contents__link toc-highlight">239. 滑动窗口最大值</a></li><li><a href="#347前-k-个高频元素" class="table-of-contents__link toc-highlight">347.前 K 个高频元素</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>