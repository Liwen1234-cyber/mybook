<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-码农/刷题记录/贪心算法" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">贪心算法 | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.middiy.top/码农/刷题记录/贪心算法/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="贪心算法 | Coisini"><meta data-rh="true" name="description" content="题目分类"><meta data-rh="true" property="og:description" content="题目分类"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.middiy.top/码农/刷题记录/贪心算法/"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/贪心算法/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.middiy.top/码农/刷题记录/贪心算法/" hreflang="x-default"><meta name="google-site-verification" content="1FUPX6Qo4y3ecU623ShEurhgnjhSTjK49rRMhEDlzFA">
<link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.53ea8373.css">
<script src="/assets/js/runtime~main.256d00d0.js" defer="defer"></script>
<script src="/assets/js/main.541591df.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/分享/">Sharing</a><button aria-label="Expand sidebar category &#x27;Sharing&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/读书笔记/">读书笔记</a><button aria-label="Expand sidebar category &#x27;读书笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/技巧/">技巧</a><button aria-label="Expand sidebar category &#x27;技巧&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/数学/">数学</a><button aria-label="Expand sidebar category &#x27;数学&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/思考/">思考</a><button aria-label="Expand sidebar category &#x27;思考&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/学习/">学习</a><button aria-label="Expand sidebar category &#x27;学习&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/码农/"> 码农</a><button aria-label="Collapse sidebar category &#x27;码农&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/基础知识/">基础知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/八股文/面试题/">面试题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/java笔记/">java 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/数组/">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/链表/">链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/哈希表/">哈希表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/字符串/">字符串</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/双指针/">双指针总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/栈与队列/">栈与队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/二叉树/">二叉树</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/回溯/">回溯</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/码农/刷题记录/贪心算法/">贪心算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/动态规划/">动态规划</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/单调栈/">单调栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/图论/">图论</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/高级数据结构/">高级数据结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/刷题记录/其他/">其他</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/转码/">转码经验</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/码农/How_browsers_work/">How browsers work</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/毛选/">毛选</a><button aria-label="Expand sidebar category &#x27;毛选&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/码农/"><span itemprop="name">码农</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">贪心算法</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>贪心算法</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="题目分类">题目分类<a href="#题目分类" class="hash-link" aria-label="Direct link to 题目分类" title="Direct link to 题目分类">​</a></h2>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="理论基础">理论基础<a href="#理论基础" class="hash-link" aria-label="Direct link to 理论基础" title="Direct link to 理论基础">​</a></h2>
<p>贪心的本质是选择每一阶段的局  部最优，从而达到全局最优。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="贪心的套路">贪心的套路<a href="#贪心的套路" class="hash-link" aria-label="Direct link to 贪心的套路" title="Direct link to 贪心的套路">​</a></h3>
<p>唯一的难点就是如何通过局部最优，推出整体最优。</p>
<p>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心。</p>
<p>有时候通过（accept）了贪心的题目，但都不知道自己用了贪心算法，**因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</p>
<p>题目：<a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html" target="_blank" rel="noopener noreferrer">链表：环找到了，那入口呢？</a>，这种题目确实需要数学简单推导。</p>
<p>贪心一般解题步骤：想清楚<strong>局部最优</strong>是什么，如何推导出全局最优。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="455分发饼干">455.分发饼干<a href="#455分发饼干" class="hash-link" aria-label="Direct link to 455.分发饼干" title="Direct link to 455.分发饼干">​</a></h2>
<p><a href="https://leetcode.cn/problems/assign-cookies/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findContentChildren(int[] g, int[] s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(g);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(s);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int j = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; s.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(j &lt; g.length &amp;&amp; s[i] &gt;= g[j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                j++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return cnt;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="376-摆动序列">376. 摆动序列<a href="#376-摆动序列" class="hash-link" aria-label="Direct link to 376. 摆动序列" title="Direct link to 376. 摆动序列">​</a></h2>
<p><a href="https://leetcode.cn/problems/wiggle-subsequence/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int wiggleMaxLength(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 1) return nums.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int i = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(i &lt; nums.length &amp;&amp; nums[i] == nums[i -1]) i++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(i == nums.length) return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean flag = (nums[i-1] &gt; nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[i-1] == nums[i]) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(flag == (nums[i-1] &gt; nums[i])){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                flag = !flag;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return ++cnt;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int wiggleMaxLength(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 0 i 作为波峰的最大长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 1 i 作为波谷的最大长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int dp[][] = new int[nums.length][2];//记录摆动序列的最大长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0][0] = dp[0][1] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i][0] = dp[i][1] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; i; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums[j] &gt; nums[i]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nums[j] &lt; nums[i]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }       </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(dp[nums.length-1][0], dp[nums.length-1][1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//j</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int wiggleMaxLength(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length &lt;= 1) return nums.length;  //如果数组长度为0或1，则返回数组长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int up = 1, down = 1;  //记录上升和下降摆动序列的最大长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[i] &gt; nums[i-1]) up = down + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else if(nums[i] &lt; nums[i-1]) down = up + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.max(up, down); //返回上升和下降摆动序列的最大长度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="53-最大子序和">53. 最大子序和<a href="#53-最大子序和" class="hash-link" aria-label="Direct link to 53. 最 大子序和" title="Direct link to 53. 最大子序和">​</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxSubArray(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int maxSum = nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int curSum = nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            curSum = Math.max(nums[i], curSum + nums[i]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            maxSum = Math.max(curSum, maxSum);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return maxSum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="122买卖股票的最佳时机-ii">122.买卖股票的最佳时机 II<a href="#122买卖股票的最佳时机-ii" class="hash-link" aria-label="Direct link to 122.买卖股票的最佳时机 II" title="Direct link to 122.买卖股票的最佳时机 II">​</a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxProfit(int[] prices) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[prices.length];//存放第i天时的最大收益</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; prices.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = dp[i-1] + Math.max(0, prices[i]-prices[i-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[prices.length-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="55-跳跃游戏">55. 跳跃游戏<a href="#55-跳跃游戏" class="hash-link" aria-label="Direct link to 55. 跳跃游戏" title="Direct link to 55. 跳跃游戏">​</a></h2>
<p><a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DP</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean canJump(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = nums.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] dp = new boolean[len];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; len-1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int j = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(dp[i] &amp;&amp; j+i &lt; len &amp;&amp; j &lt;= nums[i]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dp[j+i] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(j++ +i == len-1) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return dp[len-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean canJump(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums.length == 1) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int coverage = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= coverage; i++){//判断的条件很关键</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            coverage = Math.max(coverage, nums[i] + i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(coverage &gt;= nums.length-1) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="45跳跃游戏-ii">45.跳跃游戏 II<a href="#45跳跃游戏-ii" class="hash-link" aria-label="Direct link to 45.跳跃游戏 II" title="Direct link to 45.跳跃游戏 II">​</a></h2>
<p><a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int jump(int[] nums) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0 || nums.length == 1) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int maxcoverage = nums[0], curcoverage = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            maxcoverage = Math.max(maxcoverage, nums[i] + i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(maxcoverage &gt;= nums.length-1) return ++cnt;//达到条件就跳出</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(curcoverage == i){//超过覆盖范围就跳转，其他情况是还在范围内可以不跳转</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                curcoverage = maxcoverage;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1005k次取反后最大化的数组和">1005.K次取反后最大化的数组和<a href="#1005k次取反后最大化的数组和" class="hash-link" aria-label="Direct link to 1005.K次取反后最大化的数组和" title="Direct link to 1005.K次取反后最大化的数组和">​</a></h2>
<p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p>
<p>以这种方式修改数组后，返回数组可能的最大和。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//常规做法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int largestSumAfterKNegations(int[] nums, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int negative_cnt = 0;//负数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[i] &lt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                negative_cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(negative_cnt &lt;= k) nums[i] = -nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i == negative_cnt){//此时i为第一个正数的索引</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(negative_cnt &lt; k){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(i &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        if(nums[i] &gt; nums[i-1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            sum -= nums[i-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            sum += (((k-negative_cnt) &amp; 1) == 0) ? nums[i-1] : -nums[i-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            nums[i] = (((k-negative_cnt) &amp; 1) == 0) ? nums[i] : -nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    } else {//全为正数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        nums[0] = (((k-negative_cnt) &amp; 1) == 0) ? nums[0] : -nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            sum += nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(negative_cnt == nums.length &amp;&amp; k &gt; negative_cnt) sum =  (((k-negative_cnt) &amp; 1) == 0) ? sum : sum-2*nums[nums.length-1];//全为负数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//贪心算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int largestSumAfterKNegations(int[] nums, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        nums = IntStream.of(nums)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                .boxed()</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                .sorted((a, b) -&gt; Math.abs(b) - Math.abs(a))</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                .mapToInt(Integer::intValue)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                .toArray();//按照绝对值排序</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[i] &lt; 0 &amp;&amp; k &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                k--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                nums[i] = -nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i == nums.length-1){//消化剩余的k</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                nums[i] = ((k &amp; 1) == 0) ? nums[i] : -nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            sum += nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int largestSumAfterKNegations(int[] nums, int k) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(nums == null || nums.length == 0) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int negative_cnt = 0;//负数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; nums.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nums[i] &lt; 0 &amp;&amp; k &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                k--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                nums[i] = -nums[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(nums);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(k &gt; 0){//消化剩余的k</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            nums[0] = ((k &amp; 1) == 0) ? nums[0] : -nums[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        sum = Arrays.stream(nums).sum();//</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Absolute value sorting:</p>
<ol>
<li><code>IntStream.of(nums)</code>: Creates an IntStream from the input array <code>nums</code></li>
<li><code>.boxed()</code>: Converts the IntStream of primitive <code>int</code> values into a Stream<integer> of wrapped Integer objects. This is necessary because the next operation (sorting) needs to work with objects, not primitives.</integer></li>
<li><code>.sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))</code>:
<ul>
<li>Sorts the stream using a custom comparator</li>
<li><code>Math.abs()</code> takes the absolute value of each number</li>
<li>The comparison <code>o2 - o1</code> (rather than <code>o1 - o2</code>) creates a descending order</li>
<li>So numbers are sorted by their absolute values in descending order</li>
<li>For example: [-5, 2, -3, 1] would be sorted as [-5, -3, 2, 1]</li>
</ul>
</li>
<li><code>.mapToInt(Integer::intValue)</code>: Converts the Stream<integer> back to an IntStream by extracting the primitive int value from each Integer object</integer></li>
<li><code>.toArray()</code>: Finally converts the IntStream into a regular int array</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="134-加油站">134. 加油站<a href="#134-加油站" class="hash-link" aria-label="Direct link to 134. 加油站" title="Direct link to 134. 加油站">​</a></h2>
<p><a href="https://leetcode.cn/problems/gas-station/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明:</p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int canCompleteCircuit(int[] gas, int[] cost) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int past = 0, cur = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; gas.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            cur += gas[i] - cost[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur &lt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                past += cur;//记录负的</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cur = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res = i+1;//从正的开始</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(past + cur &lt; 0) return -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="135-分发糖果">135. 分发糖果<a href="#135-分发糖果" class="hash-link" aria-label="Direct link to 135. 分发糖果" title="Direct link to 135. 分发糖果">​</a></h2>
<p><a href="https://leetcode.cn/problems/candy/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int candy(int[] ratings) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = ratings.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(len &lt; 1) return len;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int result = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] dp = new int[len];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dp[0] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; len; i++){//Left</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = (ratings[i] &gt; ratings[i-1]) ? dp[i-1]+1 : 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = len-2; i &gt;= 0; i--){/</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dp[i] = (ratings[i] &gt; ratings[i+1]) ? Math.max(dp[i+1]+1, dp[i]) : dp[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        result = Arrays.stream(dp).sum();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="406根据身高重建队列">406.根据身高重建队列<a href="#406根据身高重建队列" class="hash-link" aria-label="Direct link to 406.根据身高重建队列" title="Direct link to 406.根据身高重建队列">​</a></h2>
<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[][] reconstructQueue(int[][] people) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(people, (a, b) -&gt; {//lambda表达式，内部类</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(a[0] == b[0]) return a[1] - b[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return b[0] - a[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        });</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int[] arr : people){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            que.add(arr[1], arr);//Linkedlist.add(index, value)，会将value插入到指定index里。</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    return que.toArray(new int[people.length][2]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="452-用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球<a href="#452-用最少数量的箭引爆气球" class="hash-link" aria-label="Direct link to 452. 用最少数量的箭引爆气球" title="Direct link to 452. 用最少数量的箭引爆气球">​</a></h2>
<p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int findMinArrowShots(int[][] points) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(points, (a, b) -&gt; {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(a[0] == b[0]) return Integer.compare(a[1], b[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return Integer.compare(a[0], b[0]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        });</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = points.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int temp = points[0][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; points.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(points[i][0] &lt;=  temp){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp = Math.min(temp, points[i][1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else temp = points[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="435-无重叠区间">435. 无重叠区间<a href="#435-无重叠区间" class="hash-link" aria-label="Direct link to 435. 无重叠区间" title="Direct link to 435. 无重叠区间">​</a></h2>
<p><a href="https://leetcode.cn/problems/non-overlapping-intervals/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int eraseOverlapIntervals(int[][] intervals) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(intervals, (a, b) -&gt; {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(a[0] == b[0]) return Integer.compare(a[1], b[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return Integer.compare(a[0], b[0]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        });</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int temp = intervals[0][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; intervals.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(intervals[i][0] &lt;  temp){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(intervals[i][1] &lt;  temp) temp = intervals[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else temp = intervals[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="763划分字母区间">763.划分字母区间<a href="#763划分字母区间" class="hash-link" aria-label="Direct link to 763.划分字母区间" title="Direct link to 763.划分字母区间">​</a></h2>
<p><a href="https://leetcode.cn/problems/partition-labels/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public List&lt;Integer&gt; partitionLabels(String s) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] arr = new int[128];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] ss = s.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; ss.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            arr[ss[i] - &#x27;a&#x27;] = i;//字母出现的最后w</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int maxindex = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int last = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; ss.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            maxindex = Math.max(arr[ss[i]-&#x27;a&#x27;], maxindex);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(maxindex == ss.length-1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                list.add(ss.length-1 - last);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i == maxindex){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                list.add(maxindex - last);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                last = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return list;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="56-合并区间">56. 合并区间<a href="#56-合并区间" class="hash-link" aria-label="Direct link to 56. 合并区间" title="Direct link to 56. 合并区间">​</a></h2>
<p><a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[][] merge(int[][] intervals) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(intervals.length == 0 || intervals.length == 1) return intervals;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.sort(intervals, (a, b) -&gt; {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(a[0] == b[0]) return Integer.compare(a[1], b[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return Integer.compare(a[0], b[0]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        });</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        LinkedList&lt;int[]&gt; res = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int temp = intervals[0][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int pre = intervals[0][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; intervals.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(intervals[i][0] &gt;  temp){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res.add(new int[]{pre, temp});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                pre = intervals[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp = intervals[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else temp = Math.max(intervals[i][1], temp);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i == intervals.length - 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res.add(new int[]{pre, temp});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res.toArray(new int[res.size()][2]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="738单调递增的数字">738.单调递增的数字<a href="#738单调递增的数字" class="hash-link" aria-label="Direct link to 738.单调递增的数字" title="Direct link to 738.单调递增的数字">​</a></h2>
<p><a href="https://leetcode.cn/problems/monotone-increasing-digits/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们  称这个整数是单调递增的。）</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="int"><strong>int[]</strong><a href="#int" class="hash-link" aria-label="Direct link to int" title="Direct link to int">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int monotoneIncreasingDigits(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(n &lt; 10) return n;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; num = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(n &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            num.addFirst(n%10);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            n /= 10;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[num.size()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        res[0] = num.get(0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int start = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Boolean flag = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; num.size(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(res[i-1] &gt; num.get(i)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                flag = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[i] = num.get(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            start = res[i-1] == num.get(i) ? start : i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int sum = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; res.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(flag){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i &lt;= start) sum = 10*sum + res[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else sum *= 10;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i == res.length-1) sum--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                sum = 10*sum + res[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return sum;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="char"><strong>char[]</strong><a href="#char" class="hash-link" aria-label="Direct link to char" title="Direct link to char">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int monotoneIncreasingDigits(int n) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(n &lt; 10) return n;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        String s = String.valueOf(n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        char[] ss = s.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int start = ss.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = ss.length-2; i &gt;= 0; i--){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(ss[i] &gt; ss[i+1]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                start = i+1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                ss[i]--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = start; i &lt; ss.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            ss[i] = &#x27;9&#x27;;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Integer.valueOf(String.valueOf(ss));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="968监控二叉树">968.监控二叉树<a href="#968监控二叉树" class="hash-link" aria-label="Direct link to 968.监控二叉树" title="Direct link to 968.监控二叉树">​</a></h2>
<p><a href="https://leetcode.cn/problems/binary-tree-cameras/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">/**</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> * Definition for a binary tree node.</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> * public class TreeNode {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     TreeNode left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     TreeNode right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     TreeNode() {}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     TreeNode(int val) { this.val = val; }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *         this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *         this.left = left;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *         this.right = right;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> *     }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> * }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"> */</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int minCameraCover(TreeNode root) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 对根节点的状态做检验,防止根节点是无覆盖状态.</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(CameraCover(root) == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     节点的状态值：</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">       0 表示无覆盖</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">       1 表示 有摄像头</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">       2 表示有覆盖</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    后序遍历，根据左右节点的情况,来判读 自己的状态</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">     */</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int CameraCover(TreeNode node) {//后序遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(node == null) return 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int left = CameraCover(node.left);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int right = CameraCover(node.right);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(left == 2 &amp;&amp; right == 2){// 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else if(left == 0 || right == 0){// 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        } else{// 左右节点的 状态为 (1,1) (1,2) (2,1) 也就是左右节点至少存在 1个摄像头，</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>贪心专题汇聚为一张图：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/贪心总结water-ad7177436e77feffb74618a90b7ea80f.png" width="5000" height="6845" class="img_ev3q"></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/码农/刷题记录/回溯/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">回溯</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/码农/刷题记录/动态规划/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">动态规划</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#题目分类" class="table-of-contents__link toc-highlight">题目分类</a></li><li><a href="#理论基础" class="table-of-contents__link toc-highlight">理论基础</a><ul><li><a href="#贪心的套路" class="table-of-contents__link toc-highlight">贪心的套路</a></li></ul></li><li><a href="#455分发饼干" class="table-of-contents__link toc-highlight">455.分发饼干</a></li><li><a href="#376-摆动序列" class="table-of-contents__link toc-highlight">376. 摆动序列</a></li><li><a href="#53-最大子序和" class="table-of-contents__link toc-highlight">53. 最大子序和</a></li><li><a href="#122买卖股票的最佳时机-ii" class="table-of-contents__link toc-highlight">122.买卖股票的最佳时机 II</a></li><li><a href="#55-跳跃游戏" class="table-of-contents__link toc-highlight">55. 跳跃游戏</a></li><li><a href="#45跳跃游戏-ii" class="table-of-contents__link toc-highlight">45.跳跃游戏 II</a></li><li><a href="#1005k次取反后最大化的数组和" class="table-of-contents__link toc-highlight">1005.K次取反后最大化的数组和</a></li><li><a href="#134-加油站" class="table-of-contents__link toc-highlight">134. 加油站</a></li><li><a href="#135-分发糖果" class="table-of-contents__link toc-highlight">135. 分发糖果</a></li><li><a href="#406根据身高重建队列" class="table-of-contents__link toc-highlight">406.根据身高重建队列</a></li><li><a href="#452-用最少数量的箭引爆气球" class="table-of-contents__link toc-highlight">452. 用最少数量的箭引爆气球</a></li><li><a href="#435-无重叠区间" class="table-of-contents__link toc-highlight">435. 无重叠区间</a></li><li><a href="#763划分字母区间" class="table-of-contents__link toc-highlight">763.划分字母区间</a></li><li><a href="#56-合并区间" class="table-of-contents__link toc-highlight">56. 合并区间</a></li><li><a href="#738单调递增的数字" class="table-of-contents__link toc-highlight">738.单调递增的数字</a></li><li><a href="#968监控二叉树" class="table-of-contents__link toc-highlight">968.监控二叉树</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>